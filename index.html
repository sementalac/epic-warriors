<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8">
  <link rel="icon"
    href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>âš”ï¸</text></svg>">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Epic Warriors Online v1.38</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323:wght@400&family=MedievalSharp&display=swap"
    rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <!-- Datos estÃ¡ticos del juego (NPC_CASTLES) â€” debe cargarse antes del script principal -->
  <script src="game-data.js"></script>
  <script src="game-simulator.js?v=1.38"></script>
  <script src="game-admin.js?v=1.38"></script>
  <link rel="stylesheet" href="epic-warriors.css?v=1.38">
</head>

<body>
  <div class="stars" id="stars"></div>
  <div class="notif-wrap" id="notifWrap"></div>

  <!-- AUTH -->
  <div class="auth-screen" id="authScreen">
    <div class="auth-box">
      <div class="auth-logo">&#x2B21; EPIC WARRIORS</div>
      <div class="auth-tagline">CONQUISTA EL MUNDO</div>
      <div class="auth-tabs">
        <button class="auth-tab active" id="btnTL" onclick="switchTab('login')">Iniciar Sesion</button>
        <button class="auth-tab" id="btnTR" onclick="switchTab('register')">Registrarse</button>
      </div>
      <div id="tabL">
        <div class="auth-field"><label class="auth-label">Email</label><input class="auth-input" type="email"
            id="lEmail" placeholder="comandante@galaxia.com" onkeypress="if(event.key==='Enter')doLogin()"></div>
        <div class="auth-field"><label class="auth-label">Contrasena</label><input class="auth-input" type="password"
            id="lPass" placeholder="..." onkeypress="if(event.key==='Enter')doLogin()"></div>
        <button class="auth-btn" id="lBtn" onclick="doLogin()">Entrar</button>
      </div>
      <div id="tabR" style="display:none">
        <div class="auth-field"><label class="auth-label">Nombre de usuario</label><input class="auth-input" type="text"
            id="rUser" oninput="onUserInput()" placeholder="Ej: Jesus_33" maxlength="15" autocapitalize="off"
            autocomplete="nickname"></div>

        <div class="auth-field"><label class="auth-label">Email</label><input class="auth-input" type="email"
            id="rEmail" placeholder="comandante@galaxia.com" onkeypress="if(event.key==='Enter')doRegister()"></div>
        <div class="auth-field"><label class="auth-label">Contrasena</label><input class="auth-input" type="password"
            id="rPass" placeholder="Min. 6 caracteres" onkeypress="if(event.key==='Enter')doRegister()"></div>
        <div class="auth-msg" id="userMsg" style="text-align:left;margin:-6px 0 8px;min-height:18px;"></div>
        <button class="auth-btn" id="rBtn" onclick="doRegister()">Crear Cuenta</button>
      </div>
      <div class="auth-msg" id="authMsg"></div>
    </div>
  </div>

  <!-- GAME -->
  <div class="game-wrapper" id="gameWrapper">
    <header class="topbar">
      <div class="logo">&#x2B21; EPIC</div>
      <div class="res-bar">

        <div class="res-chip ma">
          <div class="res-chip-top"><span class="res-icon">ğŸŒ²</span>
            <div class="res-info"><span class="res-name">Madera</span><span class="res-val" id="rMadera">0</span><span
                class="res-rate" id="rMaderaR">+0/h</span></div>
          </div>
          <div class="cap-bar-wrap">
            <div class="cap-bar ok" id="capBarMa" style="width:0%"></div>
          </div>
        </div>

        <div class="res-chip pi">
          <div class="res-chip-top"><span class="res-icon">â›°ï¸</span>
            <div class="res-info"><span class="res-name">Piedra</span><span class="res-val" id="rPiedra">0</span><span
                class="res-rate" id="rPiedraR">+0/h</span></div>
          </div>
          <div class="cap-bar-wrap">
            <div class="cap-bar ok" id="capBarPi" style="width:0%"></div>
          </div>
        </div>

        <div class="res-chip hi">
          <div class="res-chip-top"><span class="res-icon">âš™ï¸</span>
            <div class="res-info"><span class="res-name">Hierro</span><span class="res-val" id="rHierro">0</span><span
                class="res-rate" id="rHierroR">+0/h</span></div>
          </div>
          <div class="cap-bar-wrap">
            <div class="cap-bar ok" id="capBarHi" style="width:0%"></div>
          </div>
        </div>

        <div class="res-chip pr">
          <div class="res-chip-top"><span class="res-icon">ğŸŒ¾</span>
            <div class="res-info"><span class="res-name">Provisiones</span><span class="res-val"
                id="rProv">0</span><span class="res-rate" id="rProvR">+0/h</span></div>
          </div>
          <div class="cap-bar-wrap">
            <div class="cap-bar ok" id="capBarPr" style="width:0%"></div>
          </div>
        </div>

        <div class="res-chip es">
          <div class="res-chip-top"><span class="res-icon">âœ¨</span>
            <div class="res-info"><span class="res-name">Esencia</span><span class="res-val" id="rEsencia">0</span><span
                class="res-rate" id="rEsenciaR">+0/h</span></div>
          </div>
          <div class="cap-bar-wrap" style="background:rgba(192,96,255,.12)">
            <div class="cap-bar" style="width:0%;background:var(--esencia);" id="capBarEs"></div>
          </div>
        </div>

        <div class="res-chip" style="color:var(--aldeanos);border-color:rgba(255,221,96,.3)">
          <div class="res-chip-top"><span class="res-icon">ğŸ‘¤</span>
            <div class="res-info">
              <span class="res-name" style="color:var(--dim)">Aldeanos</span>
              <span class="res-val" style="color:var(--aldeanos)" id="rAldeanos">0</span>
              <div style="display:flex;justify-content:space-between;align-items:center;gap:6px;">
                <span class="res-rate" id="rTropasBase" style="color:var(--dim);">0</span>
                <span class="res-rate" id="rBarrCap" style="color:var(--dim);">/ 0</span>
              </div>
            </div>
          </div>
          <div class="cap-bar-wrap">
            <div class="cap-bar ok" id="capBarAld" style="width:0%;background:var(--aldeanos);"></div>
          </div>
        </div>

      </div>
      <div class="topbar-right">
        <div class="save-dot" id="saveDot"></div>
        <span class="save-txt" id="saveTxt">guardado</span>
        <span id="activePlayers"
          style="font-size:.65rem;color:var(--ok);letter-spacing:.05em;padding:2px 8px;background:rgba(79,255,176,.08);border:1px solid rgba(79,255,176,.2);border-radius:4px;">ğŸŸ¢
          0 online</span>
        <select class="village-sel" id="villageSel" onchange="switchVillage(this.value)"></select>
        <button id="adminBtn" onclick="openAdmin()"
          style="display:none;background:rgba(255,61,90,.08);border:1px solid rgba(255,61,90,.3);border-radius:4px;color:rgba(255,61,90,.7);padding:5px 10px;font-size:.68rem;cursor:pointer;font-family:'VT323',monospace;letter-spacing:.06em;">âš™
          ADMIN</button>
        <button onclick="openProfile()"
          style="background:rgba(240,192,64,.08);border:1px solid rgba(240,192,64,.25);border-radius:4px;color:var(--gold);padding:5px 10px;font-size:.68rem;cursor:pointer;font-family:'VT323',monospace;letter-spacing:.06em;">ğŸ‘¤
          <span id="topbarUsername">...</span></button>
        <button id="alertsBtn" onclick="toggleAlertsPanel()">
          ğŸ”” <span id="alertsBtnLabel">Alertas</span>
          <span id="alertsBadge"
            style="display:none;position:absolute;top:-6px;right:-6px;background:var(--danger);color:#fff;font-size:.55rem;width:16px;height:16px;border-radius:50%;align-items:center;justify-content:center;font-weight:bold;">0</span>
        </button>
        <button class="logout-btn" onclick="doLogout()">Salir</button>
      </div>
    </header>
    <div class="main-layout">
      <nav class="sidebar">
        <div class="nav-section">
          <div class="nav-label">Colonia</div>
          <div class="nav-item active" onclick="showPage('overview',this)"><span class="nav-icon">&#x1F310;</span>
            Vision General</div>
          <div class="nav-item" onclick="showPage('buildings',this)"><span class="nav-icon">&#x1F3D7;</span> Edificios
          </div>
          <div class="nav-item" onclick="showPage('recursos',this)"><span class="nav-icon">&#x1F33E;</span> Recursos
          </div>
        </div>
        <div class="nav-section">
          <div class="nav-label">Mundo</div>
          <div class="nav-item" onclick="showPage('map',this)"><span class="nav-icon">&#x1F5FA;</span> Mapa</div>
        </div>
        <div class="nav-section">
          <div class="nav-label">Militar</div>
          <div class="nav-item" onclick="showPage('fleet',this)"><span class="nav-icon">âš”ï¸</span> Tropas</div>
          <div class="nav-item" onclick="showPage('creatures',this)"><span class="nav-icon">ğŸ‰</span> Criaturas</div>
          <div class="nav-item" onclick="showPage('defense',this)"><span class="nav-icon">&#x1F6E1;</span> Defensa</div>
          <div class="nav-item" onclick="window.open('battle-simulator.html','_blank')"><span
              class="nav-icon">&#x2694;&#xFE0F;</span> Simulador</div>
        </div>
        <div class="nav-section">
          <div class="nav-label">Ciencia</div>
          <div class="nav-item" onclick="showPage('research',this)"><span class="nav-icon">&#x1F52C;</span>
            Investigacion</div>
        </div>
        <div class="nav-section">
          <div class="nav-label">Social</div>
          <div class="nav-item" onclick="showPage('ranking',this)"><span class="nav-icon">&#x1F3C6;</span> Ranking</div>
          <div class="nav-item" onclick="showPage('alliances',this)"><span class="nav-icon">&#x1F6E1;</span> Alianzas
          </div>
          <div class="nav-item" id="navMessages" onclick="showPage('messages',this)"><span
              class="nav-icon">&#x1F4E8;</span> Mensajes<span id="msgBadge" class="msg-badge"
              style="display:none;">0</span>
          </div>
        </div>
      </nav>
      <main class="content">
        <div class="page active" id="page-overview">
          <div class="page-title">VISION GENERAL</div>

          <!-- Player profile card -->
          <div class="card" style="margin-bottom:14px;">
            <div style="display:flex;align-items:center;gap:16px;flex-wrap:wrap;margin-bottom:16px;">
              <div style="font-size:3.5rem;line-height:1;">ğŸ‘‘</div>
              <div style="flex:1;min-width:0;">
                <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px;flex-wrap:wrap;">
                  <span style="font-size:1.5rem;color:var(--accent);font-family:VT323,monospace;" id="ovUser">--</span>
                  <span style="font-size:.8rem;color:var(--accent2);" id="ovAlliance"></span>
                </div>
                <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
                  <span class="planet-name-big" id="ovVillageName"
                    style="font-size:1rem;color:var(--dim);">Cargando...</span>
                  <button onclick="startRename()"
                    style="background:rgba(0,212,255,.08);border:1px solid rgba(0,212,255,.3);border-radius:4px;color:var(--accent);font-family:'VT323',monospace;font-size:.62rem;padding:2px 7px;cursor:pointer;">âœ</button>
                </div>
                <div id="renameForm" style="display:none;margin-top:8px;">
                  <input id="renameInput"
                    style="background:rgba(255,255,255,.05);border:1px solid var(--accent);border-radius:4px;padding:5px 10px;color:var(--text);font-family:'VT323',monospace;font-size:.82rem;outline:none;width:200px;"
                    placeholder="Nuevo nombre...">
                  <button onclick="confirmRename()"
                    style="margin-left:6px;background:rgba(79,255,176,.1);border:1px solid var(--ok);border-radius:4px;color:var(--ok);font-family:'VT323',monospace;font-size:.72rem;padding:5px 10px;cursor:pointer;">âœ“</button>
                  <button onclick="cancelRename()"
                    style="margin-left:4px;background:rgba(255,61,90,.08);border:1px solid rgba(255,61,90,.3);border-radius:4px;color:var(--danger);font-family:'VT323',monospace;font-size:.72rem;padding:5px 10px;cursor:pointer;">âœ•</button>
                </div>
                <div class="planet-coords" id="ovVillageCoords"
                  style="font-size:.68rem;color:var(--dim);margin-top:4px;">--</div>
              </div>
            </div>

            <!-- Stats: XP + Battles solo, sin recursos -->
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
              <div
                style="background:var(--panel2);border-radius:8px;padding:14px;text-align:center;border:1px solid rgba(240,192,64,.15);">
                <div style="font-size:.62rem;color:var(--dim);letter-spacing:.12em;margin-bottom:6px;">â­ EXPERIENCIA
                </div>
                <div style="font-size:1.6rem;color:var(--gold);font-weight:bold;font-family:VT323,monospace;"
                  id="ovExperience">0</div>
              </div>
              <div
                style="background:var(--panel2);border-radius:8px;padding:14px;text-align:center;border:1px solid rgba(255,61,90,.12);">
                <div style="font-size:.62rem;color:var(--dim);letter-spacing:.12em;margin-bottom:6px;">âš”ï¸ BATALLAS JvJ
                </div>
                <div style="font-size:1.2rem;margin-top:2px;font-family:VT323,monospace;">
                  <span style="color:var(--ok);" id="ovBattlesWon">0</span>
                  <span style="color:var(--dim);font-size:.9rem;"> V Â· </span>
                  <span style="color:var(--danger);" id="ovBattlesLost">0</span>
                  <span style="color:var(--dim);font-size:.9rem;"> D</span>
                </div>
                <div style="font-size:.58rem;color:var(--dim);margin-top:2px;">Solo contra jugadores</div>
              </div>
              <div
                style="background:var(--panel2);border-radius:8px;padding:14px;text-align:center;border:1px solid rgba(80,208,144,.12);grid-column:1/-1;">
                <div style="font-size:.62rem;color:var(--dim);letter-spacing:.12em;margin-bottom:6px;">ğŸ° VICTORIAS NPC
                </div>
                <div style="font-size:1.6rem;color:var(--ok);font-weight:bold;font-family:VT323,monospace;"
                  id="ovBattlesNPC">0</div>
                <div style="font-size:.58rem;color:var(--dim);margin-top:2px;">Castillos + Aldeas fantasma</div>
              </div>
            </div>
          </div>

          <!-- Troop movement alerts -->
          <div class="card" style="margin-bottom:14px;">
            <div class="h2">âš ï¸ Movimientos de tropas</div>
            <div id="ovAlertsBox" style="margin-top:8px;font-size:.8rem;color:var(--dim);">Sin alertas activas.</div>
          </div>

          <!-- Refuerzos estacionados en esta aldea -->
          <div class="card" style="margin-bottom:14px;" id="ovReinforcementsCard" style="display:none;">
            <div class="h2">ğŸ›¡ï¸ Refuerzos estacionados</div>
            <div id="ovReinforcementsBox" style="margin-top:8px;font-size:.8rem;color:var(--dim);">Sin refuerzos.</div>
          </div>

          <!-- Build queue -->
          <div class="queue-panel">
            <div class="queue-title">CONSTRUCCION EN CURSO</div>
            <div class="queue-empty" id="qEmptyOv">Sin construcciones activas.</div>
            <div id="qItemsOv"></div>
          </div>
        </div>

        <!-- RECURSOS PAGE -->
        <div class="page" id="page-recursos">
          <div class="page-title">RECURSOS</div>
          <div class="page-sub">Asigna aldeanos a cada recurso para aumentar su producciÃ³n. Los edificios garantizan una
            base mÃ­nima.</div>

          <!-- Resumen aldeanos -->
          <div class="queue-panel" style="border-color:rgba(255,221,96,.2);margin-bottom:14px;">
            <div style="display:flex;gap:20px;flex-wrap:wrap;align-items:center;">
              <span style="font-size:.8rem;">ğŸ‘¤ Libres: <b id="recAldLibres" style="color:var(--aldeanos)">0</b></span>
              <span style="font-size:.8rem;">âš’ï¸ Trabajando: <b id="recAldWorking"
                  style="color:var(--accent2)">0</b></span>
              <span style="font-size:.8rem;">ğŸ  Barracas: <b id="recAldCap" style="color:var(--dim)">0</b> plazas</span>
              <span style="font-size:.8rem;">ğŸ“¦ AlmacÃ©n: <b id="recAlmPct" style="color:var(--gold)">0%</b>
                ocupado</span>
            </div>
          </div>

          <!-- Cards de recursos con barras -->
          <div class="recursos-grid" id="recursosGrid"></div>
        </div>

        <!-- ADMIN USUARIOS PAGE -->
        <div class="page" id="page-buildings">
          <div class="page-title">EDIFICIOS</div>
          <div class="page-sub">Construye y mejora las estructuras de tu colonia</div>
          <div class="queue-panel">
            <div class="queue-title">COLA DE CONSTRUCCION</div>
            <div class="queue-empty" id="qEmpty">Sin construcciones activas.</div>
            <div id="qItems"></div>
          </div>
          <div class="bld-grid" id="bldGrid"></div>
        </div>

        <div class="page" id="page-map">
          <div class="page-title">MAPA MUNDIAL</div>
          <div class="page-sub">Vista 15Ã—15 centrada â€” usa â†‘â†“â†â†’ o WASD para moverte. Mapa de 380Ã—380</div>
          <div class="map-page-layout">
            <div class="map-main-col">
              <div class="map-container">
                <div class="map-header">
                  <div class="map-legend">
                    <div class="legend-item">
                      <div class="legend-dot" style="background:rgba(0,212,255,.5)"></div><span>Tu aldea</span>
                    </div>
                    <div class="legend-item">
                      <div class="legend-dot" style="background:rgba(255,61,90,.5)"></div><span>Aldea enemiga</span>
                    </div>
                    <div class="legend-item">
                      <div class="legend-dot" style="background:rgba(255,230,0,.5)"></div><span>Castillo
                        Caballero</span>
                    </div>
                    <div class="legend-item">
                      <div class="legend-dot" style="background:rgba(255,255,255,.04)"></div><span>Vacio</span>
                    </div>
                  </div>
                  <div class="map-nav-pad">
                    <div class="map-nav-row"><button class="map-nav-btn" onclick="panMap(0,-1)"
                        title="Arriba">â†‘</button>
                    </div>
                    <div class="map-nav-row">
                      <button class="map-nav-btn" onclick="panMap(-1,0)" title="Izquierda">â†</button>
                      <button class="map-nav-btn" onclick="panMap(0,0,true)" title="Centrar en tu aldea">âŒ‚</button>
                      <button class="map-nav-btn" onclick="panMap(1,0)" title="Derecha">â†’</button>
                    </div>
                    <div class="map-nav-row"><button class="map-nav-btn" onclick="panMap(0,1)" title="Abajo">â†“</button>
                    </div>
                  </div>
                </div>
                <div class="map-coords-display" id="mapCoordsDisplay">Cargando mapa...</div>
                <div style="display:flex;gap:6px;align-items:center;margin-top:6px;">
                  <span style="font-size:.68rem;color:var(--dim);">Ir a:</span>
                  <input id="mapGoX" type="number" placeholder="X"
                    style="width:54px;background:rgba(255,255,255,.06);border:1px solid var(--border);border-radius:4px;padding:3px 6px;color:var(--text);font-family:VT323,monospace;font-size:.8rem;text-align:center;">
                  <span style="color:var(--dim);">,</span>
                  <input id="mapGoY" type="number" placeholder="Y"
                    style="width:54px;background:rgba(255,255,255,.06);border:1px solid var(--border);border-radius:4px;padding:3px 6px;color:var(--text);font-family:VT323,monospace;font-size:.8rem;text-align:center;">
                  <button onclick="goToCoords()"
                    style="background:rgba(0,212,255,.1);border:1px solid var(--accent);border-radius:4px;color:var(--accent);font-family:VT323,monospace;font-size:.75rem;padding:3px 10px;cursor:pointer;">Ir</button>
                </div>
                <div class="map-grid-wrap">
                  <div class="map-grid" id="mapGrid"></div>
                </div>
                <div class="map-panel" id="mapPanel">
                  <div class="map-panel-title" id="mapPanelTitle">--</div>
                  <div class="map-panel-sub" id="mapPanelSub">--</div>
                  <div class="map-actions" id="mapActions"></div>
                </div>
              </div>
            </div><!-- /map-main-col -->
            <div class="map-mini-col">
              <div class="minimap-box">
                <div class="minimap-title">ğŸ—º RADAR â€” 30Ã—30</div>
                <canvas id="minimapCanvas" width="270" height="270"
                  title="Radar â€” vista amplia no interactiva"></canvas>
                <div class="minimap-legend">
                  <div class="minimap-legend-item">
                    <div class="minimap-legend-dot" style="background:rgba(0,212,255,.8)"></div>Tu aldea
                  </div>
                  <div class="minimap-legend-item">
                    <div class="minimap-legend-dot" style="background:rgba(96,208,96,.8)"></div>Aliado
                  </div>
                  <div class="minimap-legend-item">
                    <div class="minimap-legend-dot" style="background:rgba(255,61,90,.8)"></div>Enemigo
                  </div>
                  <div class="minimap-legend-item">
                    <div class="minimap-legend-dot" style="background:rgba(255,230,0,.7)"></div>NPC
                  </div>
                </div>
              </div>
            </div><!-- /map-mini-col -->
          </div><!-- /map-page-layout -->
        </div>

        <div class="page" id="page-fleet">
          <div class="page-title">TROPAS</div>
          <div class="page-sub">Entrenamiento y unidades disponibles</div>

          <div class="card" style="margin-bottom:14px;">
            <div class="h2">â³ Cola de entrenamiento</div>
            <div id="trainingQueueBox" style="margin-top:10px;"></div>
          </div>

          <div class="card" style="margin-bottom:14px;">
            <div class="h2">âš”ï¸ Entrenar tropas</div>
            <div class="muted" style="font-size:.7rem;margin-bottom:10px;">Pulsa el icono para ver estadÃ­sticas. Los
              aldeanos se descuentan y materiales al encolar.</div>
            <div id="trainOptionsBox" style="margin-top:10px;"></div>
          </div>

          <!-- troopsListBox eliminado â€” integrado en trainOptionsBox -->
          <div id="troopsListBox" style="display:none;"></div>
        </div>
        <div class="page" id="page-creatures">
          <div class="page-title">ğŸ‰ CRIATURAS</div>
          <div class="page-sub">Criaturas invocadas - No ocupan barracas ni consumen provisiones</div>

          <div class="card" style="margin-bottom:14px;">
            <div class="h2">ğŸ”® Torre de InvocaciÃ³n</div>
            <div id="torreInvocacionInfo" style="font-size:.82rem;margin-top:8px;color:var(--gold);">â€”</div>
            <div class="muted" style="margin-top:4px;font-size:.7rem;">Cada nivel reduce -5% el tiempo de invocaciÃ³n.
            </div>
          </div>

          <div class="card" style="margin-bottom:14px;">
            <div class="h2">ğŸ“‹ Cola de InvocaciÃ³n</div>
            <div id="summoningQueueBox" style="margin-top:10px;">â€”</div>
          </div>

          <div class="card" style="margin-bottom:14px;">
            <div class="h2">ğŸ‘¹ Criaturas Disponibles</div>
            <div id="creaturesListBox" style="margin-top:10px;"></div>
          </div>

          <div class="card">
            <div class="h2">âš¡ Invocar Criatura</div>
            <div id="summonBox" style="margin-top:10px;"></div>
          </div>
        </div>
        <div class="page" id="page-defense">
          <div class="coming-soon">
            <div class="cs-icon">&#x1F6E1;</div>
            <div class="cs-title">MODULO DE DEFENSA</div>
            <div>Proximamente</div>
          </div>
        </div>

        <div class="page" id="page-simulator">
          <div class="page-title">âš”ï¸ SIMULADOR DE BATALLA</div>
          <div class="page-sub">Prueba combinaciones de tropas antes de atacar</div>
          <div id="simulatorContent" style="padding:16px;">
            <p style="color:var(--dim);font-size:.85rem;">Selecciona un caballero desde el mapa y pulsa "Simular" para
              ver el resultado estimado del combate antes de enviar tus tropas.</p>
          </div>
        </div>
        <div class="page" id="page-research">
          <div class="page-title">CENTRO DE INVESTIGACIÃ“N</div>
          <div class="page-sub">Mejora el nivel de tus tropas gastando experiencia</div>

          <!-- XP disponible -->
          <div class="card" style="margin-bottom:14px;display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:8px;">
            <div>
              <div class="muted" style="font-size:.72rem;margin-bottom:2px;">TU EXPERIENCIA DISPONIBLE</div>
              <div id="researchXPDisplay" style="font-size:1.3rem;color:var(--gold);font-weight:700;">â€”</div>
            </div>
            <button class="btn btn-sm" onclick="renderResearch()">â†» Actualizar</button>
          </div>

          <!-- Tabla de tropas -->
          <div class="card" id="researchTroopGrid" style="display:grid;gap:12px;">
            <div class="muted">Cargandoâ€¦</div>
          </div>

          <!-- Leyenda stats -->
          <div class="card" style="margin-top:14px;font-size:.72rem;color:var(--dim);line-height:1.8;">
            <div style="color:var(--accent);font-weight:700;margin-bottom:6px;">ğŸ“– Efectos por nivel de tropa</div>
            <div>Cada nivel sube los stats segÃºn la tabla oficial (HP, DaÃ±o, Defensa, etc.).</div>
            <div>Nivel mÃ¡ximo: <strong style="color:var(--gold);">30</strong> &nbsp;|&nbsp; Los aldeanos cuestan XP reducida (Ã—2 en lugar de Ã—10).</div>
          </div>
        </div>

        <div class="page" id="page-ranking">
          <div class="page-title">RANKING</div>
          <div class="page-sub">ClasificaciÃ³n militar â€” cada tropa cuenta 1 punto</div>
          <div class="card">
            <div style="display:flex;gap:10px;align-items:center;justify-content:space-between;">
              <div class="muted">Se actualiza automÃ¡ticamente cada 6 horas.</div>
              <button class="btn" onclick="forceRefreshRanking()">â†» Forzar actualizaciÃ³n</button>
            </div>
            <div id="rankingBox" style="margin-top:12px;"></div>
          </div>
        </div>

        <div class="page" id="page-alliances">
          <div class="page-title">ALIANZAS</div>
          <div class="page-sub">Crear, solicitar, gestionar y comunicarse</div>

          <!-- CABECERA MI ALIANZA -->
          <div class="card" style="margin-bottom:14px;">
            <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:10px;">
              <div class="h2">Mi alianza</div>
              <button class="btn btn-sm" onclick="renderAlliances()">&#x21BB; Actualizar</button>
            </div>
            <div id="myAllianceBox" class="muted">Cargando&#x2026;</div>
          </div>

          <!-- SIN ALIANZA -->
          <div id="alNoAlliancePanel">
            <div class="grid2">
              <div class="card">
                <div class="h2">Crear alianza</div>
                <div class="muted" style="margin-bottom:10px;">Nombre + Tag (2-6 letras). Ser&#xE1;s el l&#xED;der.
                </div>
                <div style="display:grid;grid-template-columns:1fr 110px;gap:8px;">
                  <input id="alName" class="input" placeholder="Nombre de alianza" maxlength="40" />
                  <input id="alTag" class="input" placeholder="TAG" maxlength="6" style="text-transform:uppercase;" />
                </div>
                <button class="btn" style="margin-top:10px;" onclick="createAlliance()">&#x2694; Crear alianza</button>
                <div id="createAllianceMsg" class="muted" style="margin-top:8px;min-height:16px;"></div>
              </div>
              <div class="card">
                <div class="h2">Solicitar unirse</div>
                <div class="muted" style="margin-bottom:10px;">Busca una alianza en la lista y pulsa Solicitar. El
                  l&#xED;der deber&#xE1; aceptarte.</div>
                <div id="alPendingMsg" class="muted" style="min-height:16px;"></div>
              </div>
            </div>
            <div class="card" style="margin-top:14px;">
              <div class="h2">Alianzas activas</div>
              <div id="alliancesBox" style="margin-top:8px;"></div>
            </div>
          </div>

          <!-- MIEMBRO ACTIVO (no l&#xED;der) -->
          <div id="alMemberPanel" style="display:none;">
            <div class="card" style="margin-bottom:14px;border-left:3px solid var(--accent);">
              <div class="h2" style="margin-bottom:6px;">ğŸ“¢ TablÃ³n de anuncios</div>
              <div id="alAnnouncementDisplay" class="muted"
                style="font-size:.8rem;line-height:1.5;white-space:pre-wrap;min-height:32px;">Sin anuncios.</div>
            </div>
            <div class="grid2">
              <div class="card">
                <div class="h2">Miembros</div>
                <div id="alMembersList" class="muted">Cargando&#x2026;</div>
              </div>
              <div class="card">
                <div class="h2">Acciones</div>
                <button class="btn" style="width:100%;margin-bottom:8px;" onclick="openAllianceChat()">&#x1F4AC; Chat de
                  alianza</button>
                <button class="btn"
                  style="width:100%;background:rgba(224,64,64,.1);border-color:var(--danger);color:var(--danger);"
                  onclick="leaveAlliance()">&#x1F6AA; Salir de la alianza</button>
              </div>
            </div>
          </div>

          <!-- L&#xCD;DER -->
          <div id="alLeaderPanel" style="display:none;">
            <div class="grid2">
              <div class="card">
                <div class="h2">Miembros activos</div>
                <div id="alLeaderMembersList" class="muted">Cargando&#x2026;</div>
              </div>
              <div class="card">
                <div class="h2">Solicitudes pendientes</div>
                <div id="alPendingList" class="muted">Cargando&#x2026;</div>
              </div>
            </div>
            <div class="card" style="margin-top:14px;">
              <div class="h2">Invitar jugador</div>
              <div style="display:flex;gap:8px;margin-top:8px;">
                <input id="alInviteUser" class="input" placeholder="Nombre de usuario&#x2026;" style="flex:1;"
                  onkeydown="if(event.key==='Enter') inviteToAlliance()" />
                <button class="btn" onclick="inviteToAlliance()">Invitar</button>
              </div>
              <div id="alInviteMsg" class="muted" style="margin-top:8px;min-height:16px;"></div>
            </div>
            <div class="card" style="margin-top:14px;border-left:3px solid var(--accent);">
              <div class="h2" style="margin-bottom:6px;">ğŸ“¢ TablÃ³n de anuncios</div>
              <div class="muted" style="font-size:.72rem;margin-bottom:8px;">Visible para todos los miembros al entrar
                en Alianzas.</div>
              <textarea id="alAnnouncementInput" class="input" rows="3"
                placeholder="Escribe un anuncio para tu alianzaâ€¦"
                style="width:100%;resize:vertical;font-family:VT323,monospace;font-size:.85rem;line-height:1.4;"></textarea>
              <button class="btn" style="margin-top:8px;" onclick="saveAllianceAnnouncement()">ğŸ’¾ Guardar
                anuncio</button>
              <div id="alAnnouncementMsg" class="muted" style="margin-top:6px;min-height:14px;font-size:.72rem;"></div>
            </div>
            <div class="card" style="margin-top:14px;">
              <div class="h2">Acciones de l&#xED;der</div>
              <div style="display:flex;gap:8px;flex-wrap:wrap;">
                <button class="btn" onclick="openAllianceChat()">&#x1F4AC; Chat de alianza</button>
                <button class="btn"
                  style="background:rgba(224,64,64,.1);border-color:var(--danger);color:var(--danger);"
                  onclick="dissolveAlliance()">&#x1F4A3; Disolver alianza</button>
              </div>
            </div>
          </div>

          <!-- PENDIENTE / INVITADO -->
          <div id="alPendingPanel" style="display:none;">
            <div class="card">
              <div id="alPendingStatusBox" class="muted">Cargando&#x2026;</div>
              <div style="display:flex;gap:8px;margin-top:12px;flex-wrap:wrap;" id="alPendingActions"></div>
            </div>
          </div>
          <!-- v1.22: Ranking colectivo de alianzas -->
          <div class="card" style="margin-top:14px;">
            <div class="h2">ğŸ† Ranking de alianzas</div>
            <div id="allianceRankingBox" class="muted" style="margin-top:8px;">Cargando&#x2026;</div>
          </div>
        </div>

        <div class="page" id="page-messages">
          <div class="page-title">MENSAJES</div>
          <div class="page-sub">Sistema Â· Alianza Â· Mensajes directos</div>

          <div
            style="display:grid;grid-template-columns:280px 360px 1fr;gap:16px;height:calc(100vh - 200px);min-height:420px;">

            <!-- â”€â”€ PANEL IZQUIERDO: bandeja â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
            <div
              style="display:flex;flex-direction:column;gap:0;background:var(--panel);border:1px solid var(--border);border-radius:8px;overflow:hidden;">

              <!-- Cabecera + acciones rÃ¡pidas -->
              <div style="padding:14px 14px 10px;border-bottom:1px solid var(--border);">
                <div style="font-size:.7rem;letter-spacing:.12em;color:var(--accent);margin-bottom:10px;">ğŸ“¬ BANDEJA
                </div>

                <!-- DM -->
                <div style="display:flex;gap:6px;margin-bottom:8px;">
                  <input id="dmUser" placeholder="Username para DMâ€¦"
                    style="flex:1;background:rgba(255,255,255,.04);border:1px solid var(--border);border-radius:4px;padding:6px 8px;color:var(--text);font-family:VT323,monospace;font-size:.78rem;outline:none;"
                    onkeydown="if(event.key==='Enter') startDM()" />
                  <button onclick="startDM()"
                    style="padding:5px 10px;background:rgba(240,192,64,.1);border:1px solid var(--accent);border-radius:4px;color:var(--accent);font-family:VT323,monospace;font-size:.75rem;cursor:pointer;white-space:nowrap;">âœ‰
                    DM</button>
                </div>

                <!-- Botones rÃ¡pidos -->
                <div style="display:flex;gap:6px;">
                  <button onclick="openAllianceChat()"
                    style="flex:1;padding:5px 4px;background:rgba(96,208,96,.08);border:1px solid var(--accent2);border-radius:4px;color:var(--accent2);font-family:VT323,monospace;font-size:.72rem;cursor:pointer;">âš”
                    Alianza</button>
                  <button onclick="openSystemThread()"
                    style="flex:1;padding:5px 4px;background:rgba(192,96,255,.08);border:1px solid var(--esencia);border-radius:4px;color:var(--esencia);font-family:VT323,monospace;font-size:.72rem;cursor:pointer;">ğŸ””
                    Sistema</button>
                  <button onclick="renderThreads()"
                    style="flex:1;padding:5px 4px;background:rgba(255,255,255,.04);border:1px solid var(--border);border-radius:4px;color:var(--dim);font-family:VT323,monospace;font-size:.72rem;cursor:pointer;">â†»</button>
                </div>
              </div>

              <!-- Lista de hilos -->
              <div id="threadsBox" style="flex:1;overflow-y:auto;padding:6px 0;"></div>
            </div>

            <!-- â”€â”€ PANEL CENTRAL: lista de reportes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
            <div id="reportsList"
              style="display:none;flex-direction:column;background:var(--panel);border:1px solid var(--border);border-radius:8px;overflow:hidden;">

              <!-- Header con acciones -->
              <div
                style="padding:10px 14px;border-bottom:1px solid var(--border);display:flex;flex-direction:column;gap:8px;">
                <!-- Fila 1: tÃ­tulo + marcar leÃ­dos -->
                <div style="display:flex;align-items:center;justify-content:space-between;">
                  <div style="font-size:.8rem;color:var(--accent);letter-spacing:.08em;">ğŸ“‹ INFORMES</div>
                  <button onclick="markAllSystemAsRead()"
                    style="padding:4px 8px;background:rgba(96,208,96,.1);border:1px solid var(--accent2);border-radius:4px;color:var(--accent2);font-family:VT323,monospace;font-size:.65rem;cursor:pointer;">âœ“
                    Marcar leÃ­dos</button>
                </div>
                <!-- Fila 2: selecciÃ³n mÃºltiple -->
                <div style="display:flex;align-items:center;gap:8px;">
                  <label
                    style="display:flex;align-items:center;gap:4px;font-size:.65rem;color:var(--dim);cursor:pointer;user-select:none;">
                    <input type="checkbox" id="selectAllReportsChk"
                      style="width:13px;height:13px;cursor:pointer;accent-color:var(--danger);"
                      onchange="selectAllReports(this.checked)">
                    Todo
                  </label>
                  <span id="reportsSelCount" style="flex:1;font-size:.62rem;color:var(--dim);"></span>
                  <button id="reportsDeleteSelBtn" onclick="deleteSelectedReports()"
                    style="display:none;padding:3px 10px;background:rgba(224,64,64,.12);border:1px solid var(--danger);border-radius:4px;color:var(--danger);font-family:VT323,monospace;font-size:.65rem;cursor:pointer;">ğŸ—‘
                    Eliminar sel.</button>
                </div>
              </div>

              <!-- Lista scrolleable -->
              <div id="reportsListBox" style="flex:1;overflow-y:auto;padding:6px;"></div>
            </div>

            <!-- â”€â”€ PANEL DERECHO: reporte completo o chat â”€â”€â”€â”€â”€â”€â”€ -->
            <div
              style="display:flex;flex-direction:column;background:var(--panel);border:1px solid var(--border);border-radius:8px;overflow:hidden;">

              <!-- Cabecera -->
              <div id="chatHeader"
                style="padding:12px 16px;border-bottom:1px solid var(--border);display:flex;align-items:center;gap:10px;min-height:48px;">
                <span style="color:var(--dim);font-size:.78rem;">Selecciona una conversaciÃ³nâ€¦</span>
              </div>

              <!-- Contenido: chat o reporte -->
              <div id="chatBox" style="flex:1;overflow-y:auto;padding:14px 16px;"></div>

              <!-- Input envÃ­o (oculto hasta que haya hilo activo) -->
              <div id="chatInputArea"
                style="padding:10px 14px;border-top:1px solid var(--border);display:none;gap:8px;align-items:center;">
                <input id="chatMsg" placeholder="Escribe un mensajeâ€¦"
                  style="flex:1;background:rgba(255,255,255,.04);border:1px solid var(--border);border-radius:6px;padding:8px 12px;color:var(--text);font-family:VT323,monospace;font-size:.85rem;outline:none;"
                  onkeydown="if(event.key==='Enter') sendChatMsg()" />
                <button onclick="sendChatMsg()"
                  style="padding:7px 16px;background:rgba(240,192,64,.12);border:1px solid var(--accent);border-radius:6px;color:var(--accent);font-family:VT323,monospace;font-size:.82rem;cursor:pointer;">Enviar</button>
              </div>
            </div>
          </div>
        </div>

        <!-- v1.17: PÃ¡gina de usuarios admin (solo para sementalac@gmail.com) -->
        <div class="page" id="page-admin-users">
          <div class="page-title">GESTIÃ“N DE USUARIOS</div>
          <div class="page-sub">AdministraciÃ³n de cuentas</div>
          <div class="card">
            <div
              style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;margin-bottom:15px;">
              <div style="display:flex;gap:8px;flex:1;">
                <input type="text" id="adminUsersSearch" placeholder="Buscar usuario..."
                  style="flex:1;padding:8px 12px;background:rgba(255,255,255,.03);border:1px solid var(--border);border-radius:4px;color:var(--text);font-family:VT323,monospace;font-size:.85rem;"
                  oninput="filterAdminUsersPage()">
                <button onclick="loadAdminUsersPage()"
                  style="padding:8px 16px;background:rgba(0,212,255,.15);border:1px solid var(--accent);border-radius:4px;color:var(--accent);cursor:pointer;font-family:VT323,monospace;font-size:.85rem;">â†»
                  Actualizar</button>
              </div>
            </div>
            <div id="adminUsersPageList" style="font-size:.75rem;"></div>
          </div>
        </div>
      </main>
    </div>
  </div>

  <script>
    // ============================================================
    // CONFIG
    // ============================================================
    // --- Supabase (DEV) ---
    // NOTE: The anon key is safe to include in the client for development, but your database must enforce RLS.
    // For convenience during development, you can paste credentials once in the in-app "Supabase Setup" prompt.
    // They are stored in localStorage (browser-only) so you don't have to edit this file every time.
    let SUPABASE_URL = 'https://plrsfepvdgxlaxzejfbu.supabase.co';
    let SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBscnNmZXB2ZGd4bGF4emVqZmJ1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzEwMjIzNjksImV4cCI6MjA4NjU5ODM2OX0.7ypfPPSwvNCyU-QdQe-58gjBYV7glm3fD9yPLHQstTc';

    // Try to load dev credentials from localStorage (so you can just open the file and play).
    try {
      const lsUrl = localStorage.getItem('EW_SUPABASE_URL');
      const lsKey = localStorage.getItem('EW_SUPABASE_KEY');
      if (lsUrl && lsKey) { SUPABASE_URL = lsUrl; SUPABASE_KEY = lsKey; }
    } catch (e) { }


    const GAME_VERSION = '0.71';
    const MAP_SIZE = 380;
    const MAP_VIEW = 7;  // 15Ã—15 grid (2*7+1)

    // sessionStorage persiste entre F5 pero no entre pestaÃ±as
    // Edge y Firefox bloquean localStorage de CDNs externos, pero sessionStorage funciona
    const sbClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY, {
      auth: {
        storage: window.sessionStorage,
        persistSession: true,
        autoRefreshToken: true,
        detectSessionInUrl: false
      }
    });


    // â”€â”€ Estado del jugador y mundo â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let currentUser = null;
    let myVillages = [];
    let activeVillage = null;
    let activeVillageId = null;   // sincronÃ­a logout/doLogin
    let allVillages = [];

    // â”€â”€ Timers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let uiTimer = null;
    let autoSaveTimer = null;      // LEGACY â€” ya no se usa en el modelo reactivo
    // mantenido por compatibilidad con doLogout()

    // â”€â”€ Guardado â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let isFlushing = false;
    let pendingFlush = false;
    let _stateDirty = false;      // true cuando hay cambios en memoria sin guardar

    // â”€â”€ Modelo evento-reactivo (v0.98+) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // _missionWatchScheduled evita lanzar resolveMissions() dos veces
    // si la misiÃ³n tarda mÃ¡s de 1 tick en resolverse (async).
    // Se pone a true justo antes del await y a false en el .then()/.catch().
    let _missionWatchScheduled = false;

    // NPC_CASTLES cargado desde game-data.js (ver <head> del HTML)
    let playerObjectives = []; // Progress for current user

    // ============================================================
    // TROOP TYPES â€” normal (ocupa barracas + gasta provisiones) vs criatura
    // ============================================================

    // Rango de visiÃ³n/ataque (distancia Chebyshev en casillas del mapa)
    function getTorreRange(blds) {
      var lvl = (blds && blds.torre && blds.torre.level) || 0;
      return lvl * 10; // v1.21: nivel 1=10, +10 por nivel
    }

    // TROOP_TYPES â€” stats alineados con battle-simulator-v0_1
    // type: 'normal' â†’ ocupa barracas + consume provisiones al enviarse
    // type: 'creature' â†’ no ocupa barracas, no consume provisiones
    const TROOP_TYPES = {
      aldeano: {
        name: 'Aldeano', icon: 'ğŸ‘¤', type: 'normal',
        attackChance: 8, hp: 10, attacksPerTurn: 1, damage: 2,
        defense: 10, armor: 0, weapon: 0, dexterity: 5,
        speed: 1, capacity: 10,
        cost: { madera: 0, hierro: 0, prov: 1 },
        time: 60, barracasSlots: 1,
        desc: 'Tropa bÃ¡sica. Ocupa 1 plaza en barracas y consume 1 provisiÃ³n al enviarse.'
      },
      soldado: {
        name: 'Guerrero', icon: 'âš”ï¸', type: 'normal',
        attackChance: 12, hp: 25, attacksPerTurn: 1, damage: 8,
        defense: 14, armor: 2, weapon: 2, dexterity: 8,
        speed: 2, capacity: 20,
        cost: { madera: 0, hierro: 10, prov: 2 },
        time: 180, barracasSlots: 1,
        desc: 'Soldado de infanterÃ­a. MÃ¡s HP y daÃ±o que el aldeano. Requiere hierro.'
      },
      mago: {
        name: 'Mago', icon: 'ğŸ§™', type: 'normal',
        attackChance: 15, hp: 15, attacksPerTurn: 2, damage: 12,
        defense: 10, armor: 0, weapon: 4, dexterity: 12,
        speed: 1, capacity: 5,
        cost: { madera: 0, hierro: 0, prov: 3, esencia: 20 },
        time: 300, barracasSlots: 1,
        desc: 'Ataca 2 veces por turno con magia. DaÃ±o alto, defensa baja.'
      },
      druida: {
        name: 'Druida', icon: 'ğŸŒ¿', type: 'normal',
        attackChance: 14, hp: 20, attacksPerTurn: 1, damage: 6,
        defense: 12, armor: 1, weapon: 1, dexterity: 10,
        speed: 1, capacity: 15,
        cost: { madera: 5, hierro: 0, prov: 2, esencia: 10 },
        time: 240, barracasSlots: 1,
        desc: 'Equilibrado entre ataque y defensa. Gran capacidad de carga.'
      },
      explorador: {
        name: 'Explorador', icon: 'ğŸ¹', type: 'normal',
        attackChance: 16, hp: 12, attacksPerTurn: 2, damage: 5,
        defense: 11, armor: 0, weapon: 1, dexterity: 15,
        speed: 4, capacity: 8,
        cost: { madera: 5, hierro: 5, prov: 1 },
        time: 120, barracasSlots: 1,
        desc: 'Muy rÃ¡pido en el mapa. Ideal para saqueo y exploraciÃ³n.'
      },
      asesino: {
        name: 'Asesino', icon: 'ğŸ¯', type: 'normal',
        attackChance: 18, hp: 8, attacksPerTurn: 1, damage: 14,
        defense: 9, armor: 0, weapon: 6, dexterity: 20,
        speed: 3, capacity: 5,
        cost: { madera: 10, hierro: 30, esencia: 15, prov: 3 },
        time: 400, barracasSlots: 1,
        desc: 'Especialista en eliminaciÃ³n. DaÃ±o y destreza extremos. FrÃ¡gil.'
      },
      paladin: {
        name: 'PaladÃ­n', icon: 'ğŸ›¡ï¸', type: 'normal',
        attackChance: 10, hp: 35, attacksPerTurn: 1, damage: 5,
        defense: 18, armor: 8, weapon: 2, dexterity: 6,
        speed: 1, capacity: 10,
        cost: { madera: 0, piedra: 20, hierro: 40, prov: 4 },
        time: 450, barracasSlots: 1,
        desc: 'Tanque pesado. Armadura y HP formidables. Lento pero resistente.'
      },
      chaman: {
        name: 'ChamÃ¡n', icon: 'ğŸ”®', type: 'normal',
        attackChance: 14, hp: 18, attacksPerTurn: 1, damage: 10,
        defense: 11, armor: 1, weapon: 3, dexterity: 11,
        speed: 1, capacity: 8,
        cost: { madera: 15, piedra: 10, esencia: 25, prov: 3 },
        time: 350, barracasSlots: 1,
        desc: 'Gala la fuerza de la naturaleza. EstadÃ­sticas mÃ¡gicas equilibradas.'
      },
      invocador: {
        name: 'Invocador', icon: 'ğŸ§™â€â™‚ï¸', type: 'normal',
        attackChance: 6, hp: 7, attacksPerTurn: 1, damage: 1,
        defense: 7, armor: 0, weapon: 0, dexterity: 5,
        speed: 1, capacity: 8,
        cost: { madera: 5, hierro: 5, esencia: 10, prov: 1 },
        time: 120, barracasSlots: 1,
        desc: 'Tropa dÃ©bil que permite invocar criaturas poderosas. Requisito para invocaciones.'
      }
    };

    const CREATURE_TYPES = {
      // â”€â”€ TIER 1 â€” 1 invocador â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      orco: {
        name: 'Orco', icon: 'ğŸ‘¹', tier: 1,
        attackChance: 10, hp: 30, attacksPerTurn: 1, damage: 10,
        defense: 12, armor: 0, weapon: 0, dexterity: 6,
        speed: 2, capacity: 0,
        summonersNeeded: 1, cost: { esencia: 50 }, time: 300, // 5 min
        desc: 'Guerrero brutal de primera lÃ­nea. Tier 1.'
      },
      hada: {
        name: 'Hada', icon: 'ğŸ§š', tier: 1,
        attackChance: 14, hp: 20, attacksPerTurn: 2, damage: 8,
        defense: 10, armor: 0, weapon: 0, dexterity: 15,
        speed: 3, capacity: 0,
        summonersNeeded: 1, cost: { esencia: 50 }, time: 300,
        desc: 'Criatura veloz con doble ataque. Tier 1.'
      },
      // â”€â”€ TIER 2 â€” 8 invocadores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      golem: {
        name: 'GÃ³lem', icon: 'ğŸ—¿', tier: 2,
        attackChance: 8, hp: 80, attacksPerTurn: 1, damage: 18,
        defense: 18, armor: 0, weapon: 0, dexterity: 4,
        speed: 1, capacity: 0,
        summonersNeeded: 8, cost: { esencia: 150 }, time: 540, // 9 min
        desc: 'Tanque de piedra casi indestructible. Tier 2.'
      },
      espectro: {
        name: 'Espectro', icon: 'ğŸ‘»', tier: 2,
        attackChance: 16, hp: 50, attacksPerTurn: 1, damage: 22,
        defense: 8, armor: 0, weapon: 0, dexterity: 18,
        speed: 2, capacity: 0,
        summonersNeeded: 8, cost: { esencia: 150 }, time: 540,
        desc: 'Asesino etÃ©reo con alta precisiÃ³n. Tier 2.'
      },
      // â”€â”€ TIER 3 â€” 20 invocadores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      kobold: {
        name: 'Kobold', icon: 'ğŸ‘º', tier: 3,
        attackChance: 15, hp: 40, attacksPerTurn: 1, damage: 12,
        defense: 10, armor: 0, weapon: 0, dexterity: 22,
        speed: 4, capacity: 0,
        summonersNeeded: 20, cost: { esencia: 250 }, time: 840, // 14 min
        desc: 'Criatura Ã¡gil y escurridiza. Alta destreza. Tier 3.'
      },
      silfide: {
        name: 'SÃ­lfide', icon: 'ğŸŒ¬ï¸', tier: 3,
        attackChance: 16, hp: 30, attacksPerTurn: 2, damage: 9,
        defense: 8, armor: 0, weapon: 0, dexterity: 24,
        speed: 3, capacity: 0,
        summonersNeeded: 20, cost: { esencia: 250 }, time: 840,
        desc: 'EspÃ­ritu del aire con doble ataque y extrema agilidad. Tier 3.'
      },
      // â”€â”€ TIER 4 â€” 45 invocadores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      troll: {
        name: 'Troll', icon: 'ğŸ§Œ', tier: 4,
        attackChance: 9, hp: 140, attacksPerTurn: 1, damage: 22,
        defense: 24, armor: 0, weapon: 0, dexterity: 5,
        speed: 1, capacity: 0,
        summonersNeeded: 45, cost: { esencia: 350 }, time: 1500, // 25 min
        desc: 'Bestia montaÃ±esa de enorme resistencia. Tier 4.'
      },
      banshee: {
        name: 'Banshee', icon: 'ğŸ’€', tier: 4,
        attackChance: 19, hp: 75, attacksPerTurn: 1, damage: 32,
        defense: 10, armor: 0, weapon: 0, dexterity: 22,
        speed: 2, capacity: 0,
        summonersNeeded: 45, cost: { esencia: 350 }, time: 1500,
        desc: 'Espectro de alta precisiÃ³n y daÃ±o devastador. Tier 4.'
      },
      // â”€â”€ TIER 5 â€” 90 invocadores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      grifo: {
        name: 'Grifo', icon: 'ğŸ¦…', tier: 5,
        attackChance: 15, hp: 165, attacksPerTurn: 2, damage: 36,
        defense: 16, armor: 0, weapon: 0, dexterity: 18,
        speed: 4, capacity: 0,
        summonersNeeded: 90, cost: { esencia: 550 }, time: 3000, // 50 min
        desc: 'Bestia alada con doble ataque y gran velocidad. Tier 5.'
      },
      quimera: {
        name: 'Quimera', icon: 'ğŸ”¥', tier: 5,
        attackChance: 14, hp: 130, attacksPerTurn: 2, damage: 32,
        defense: 15, armor: 0, weapon: 0, dexterity: 14,
        speed: 2, capacity: 0,
        summonersNeeded: 90, cost: { esencia: 550 }, time: 3000,
        desc: 'Bestia tricÃ©fala de fuego con doble ataque. Tier 5.'
      },
      // â”€â”€ TIER 6 â€” 150 invocadores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      hidra: {
        name: 'Hidra', icon: 'ğŸ‰', tier: 6,
        attackChance: 13, hp: 250, attacksPerTurn: 3, damage: 27,
        defense: 18, armor: 0, weapon: 0, dexterity: 11,
        speed: 2, capacity: 0,
        summonersNeeded: 150, cost: { esencia: 750 }, time: 4500, // 75 min
        desc: 'Monstruo de mÃºltiples cabezas con triple ataque. Tier 6.'
      },
      ciclope: {
        name: 'CÃ­clope', icon: 'ğŸ‘ï¸', tier: 6,
        attackChance: 10, hp: 210, attacksPerTurn: 1, damage: 55,
        defense: 20, armor: 0, weapon: 0, dexterity: 6,
        speed: 1, capacity: 0,
        summonersNeeded: 150, cost: { esencia: 750 }, time: 4500,
        desc: 'Gigante de un ojo con golpe devastador. Tier 6.'
      },
      // â”€â”€ TIER 7 â€” 230 invocadores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      basilisco: {
        name: 'Basilisco', icon: 'ğŸ', tier: 7,
        attackChance: 21, hp: 140, attacksPerTurn: 1, damage: 58,
        defense: 12, armor: 0, weapon: 0, dexterity: 20,
        speed: 2, capacity: 0,
        summonersNeeded: 230, cost: { esencia: 1000 }, time: 6600, // 110 min
        desc: 'Serpiente letal de mirada paralizante y veneno mortal. Tier 7.'
      },
      valquiria: {
        name: 'Valquiria', icon: 'âš”ï¸', tier: 7,
        attackChance: 17, hp: 200, attacksPerTurn: 2, damage: 42,
        defense: 22, armor: 0, weapon: 0, dexterity: 20,
        speed: 3, capacity: 0,
        summonersNeeded: 230, cost: { esencia: 1000 }, time: 6600,
        desc: 'Guerrera divina equilibrada en ataque y defensa. Tier 7.'
      },
      // â”€â”€ TIER 8 â€” 320 invocadores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      minotauro: {
        name: 'Minotauro', icon: 'ğŸ‚', tier: 8,
        attackChance: 12, hp: 320, attacksPerTurn: 1, damage: 50,
        defense: 26, armor: 0, weapon: 0, dexterity: 8,
        speed: 1, capacity: 0,
        summonersNeeded: 320, cost: { esencia: 1400 }, time: 9000, // 150 min
        desc: 'Bestia mitad hombre mitad toro, coloso imparable. Tier 8.'
      },
      salamandra: {
        name: 'Salamandra', icon: 'ğŸ¦', tier: 8,
        attackChance: 15, hp: 220, attacksPerTurn: 2, damage: 65,
        defense: 15, armor: 0, weapon: 0, dexterity: 16,
        speed: 2, capacity: 0,
        summonersNeeded: 320, cost: { esencia: 1400 }, time: 9000,
        desc: 'Criatura Ã­gnea con doble ataque abrasador. Tier 8.'
      },
      // â”€â”€ TIER 9 â€” 410 invocadores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      manticora: {
        name: 'Manticora', icon: 'ğŸ¦', tier: 9,
        attackChance: 17, hp: 270, attacksPerTurn: 3, damage: 48,
        defense: 18, armor: 0, weapon: 0, dexterity: 19,
        speed: 3, capacity: 0,
        summonersNeeded: 410, cost: { esencia: 1800 }, time: 12600, // 210 min
        desc: 'LeÃ³n alado con cola de escorpiÃ³n y triple ataque. Tier 9.'
      },
      ondina: {
        name: 'Ondina', icon: 'ğŸ’§', tier: 9,
        attackChance: 20, hp: 190, attacksPerTurn: 1, damage: 55,
        defense: 17, armor: 0, weapon: 0, dexterity: 26,
        speed: 3, capacity: 0,
        summonersNeeded: 410, cost: { esencia: 1800 }, time: 12600,
        desc: 'EspÃ­ritu del agua de extrema agilidad y precisiÃ³n. Tier 9.'
      },
      // â”€â”€ TIER 10 â€” 500 invocadores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      centauro: {
        name: 'Centauro', icon: 'ğŸ‡', tier: 10,
        attackChance: 16, hp: 350, attacksPerTurn: 2, damage: 60,
        defense: 22, armor: 0, weapon: 0, dexterity: 22,
        speed: 4, capacity: 0,
        summonersNeeded: 500, cost: { esencia: 2500 }, time: 18000, // 300 min
        desc: 'Guerrero mitad hombre mitad caballo, rÃ¡pido y poderoso. Tier 10.'
      },
      medusa: {
        name: 'Medusa', icon: 'ğŸŒ€', tier: 10,
        attackChance: 23, hp: 260, attacksPerTurn: 1, damage: 80,
        defense: 15, armor: 0, weapon: 0, dexterity: 22,
        speed: 2, capacity: 0,
        summonersNeeded: 500, cost: { esencia: 2500 }, time: 18000,
        desc: 'Gorgona de mirada letal y daÃ±o excepcional. Tier 10.'
      },
      // â”€â”€ TIER 11 â€” 850 invocadores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      wyvern: {
        name: 'Wyvern', icon: 'ğŸ²', tier: 11,
        attackChance: 17, hp: 380, attacksPerTurn: 2, damage: 75,
        defense: 21, armor: 0, weapon: 0, dexterity: 24,
        speed: 4, capacity: 0,
        summonersNeeded: 850, cost: { esencia: 3200 }, time: 25200, // 420 min
        desc: 'DragÃ³n menor de dos alas, rÃ¡pido y letal. Tier 11.'
      },
      nereida: {
        name: 'Nereida', icon: 'ğŸ§œ', tier: 11,
        attackChance: 21, hp: 290, attacksPerTurn: 1, damage: 70,
        defense: 18, armor: 0, weapon: 0, dexterity: 28,
        speed: 3, capacity: 0,
        summonersNeeded: 850, cost: { esencia: 3200 }, time: 25200,
        desc: 'Ninfa marina de destreza sin igual. Tier 11.'
      },
      // â”€â”€ TIER 12 â€” 1.200 invocadores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      gigante: {
        name: 'Gigante', icon: 'ğŸ”ï¸', tier: 12,
        attackChance: 10, hp: 650, attacksPerTurn: 1, damage: 75,
        defense: 38, armor: 0, weapon: 0, dexterity: 4,
        speed: 1, capacity: 0,
        summonersNeeded: 1200, cost: { esencia: 4000 }, time: 36000, // 600 min
        desc: 'Colosal titan de roca y fuerza inmensurable. Tier 12.'
      },
      harpia: {
        name: 'HarpÃ­a', icon: 'ğŸ¦¤', tier: 12,
        attackChance: 19, hp: 320, attacksPerTurn: 3, damage: 68,
        defense: 17, armor: 0, weapon: 0, dexterity: 26,
        speed: 4, capacity: 0,
        summonersNeeded: 1200, cost: { esencia: 4000 }, time: 36000,
        desc: 'Criatura alada con triple ataque devastador. Tier 12.'
      },
      // â”€â”€ TIER 13 â€” 1.550 invocadores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      fenix: {
        name: 'FÃ©nix', icon: 'ğŸ”¥', tier: 13,
        attackChance: 18, hp: 460, attacksPerTurn: 2, damage: 62,
        defense: 16, armor: 0, weapon: 0, dexterity: 22,
        speed: 3, capacity: 0,
        summonersNeeded: 1550, cost: { esencia: 5500 }, time: 50400, // 840 min
        desc: 'Ave inmortal de fuego que renace de sus cenizas. Tier 13.'
      },
      cerbero: {
        name: 'Cerbero', icon: 'ğŸ•', tier: 13,
        attackChance: 16, hp: 500, attacksPerTurn: 3, damage: 65,
        defense: 24, armor: 0, weapon: 0, dexterity: 14,
        speed: 2, capacity: 0,
        summonersNeeded: 1550, cost: { esencia: 5500 }, time: 50400,
        desc: 'Can tricÃ©falo guardiÃ¡n del inframundo. Triple ataque. Tier 13.'
      },
      // â”€â”€ TIER 14 â€” 1.850 invocadores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      behemot: {
        name: 'Behemot', icon: 'ğŸ¦', tier: 14,
        attackChance: 11, hp: 760, attacksPerTurn: 1, damage: 98,
        defense: 33, armor: 0, weapon: 0, dexterity: 7,
        speed: 1, capacity: 0,
        summonersNeeded: 1850, cost: { esencia: 7000 }, time: 72000, // 1200 min
        desc: 'Coloso indestructible de fuerza primordial. Tier 14.'
      },
      quetzal: {
        name: 'Quetzal', icon: 'ğŸ¦œ', tier: 14,
        attackChance: 19, hp: 430, attacksPerTurn: 2, damage: 90,
        defense: 18, armor: 0, weapon: 0, dexterity: 24,
        speed: 4, capacity: 0,
        summonersNeeded: 1850, cost: { esencia: 7000 }, time: 72000,
        desc: 'Serpiente emplumada sagrada, veloz y poderosa. Tier 14.'
      },
      // â”€â”€ TIER 15 â€” 2.150 invocadores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      leviatan: {
        name: 'LeviatÃ¡n', icon: 'ğŸŒŠ', tier: 15,
        attackChance: 12, hp: 920, attacksPerTurn: 1, damage: 105,
        defense: 40, armor: 0, weapon: 0, dexterity: 6,
        speed: 1, capacity: 0,
        summonersNeeded: 2150, cost: { esencia: 8500 }, time: 86400, // 1440 min = 24h
        desc: 'Serpiente marina primordial de tamaÃ±o colosal. Tier 15.'
      },
      serafin: {
        name: 'SerafÃ­n', icon: 'ğŸ˜‡', tier: 15,
        attackChance: 20, hp: 610, attacksPerTurn: 2, damage: 112,
        defense: 28, armor: 0, weapon: 0, dexterity: 22,
        speed: 2, capacity: 0,
        summonersNeeded: 2150, cost: { esencia: 8500 }, time: 86400,
        desc: 'Ãngel de seis alas equilibrado en toda su magnificencia. Tier 15.'
      },
      // â”€â”€ TIER 16 â€” 2.450 invocadores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      titan: {
        name: 'TitÃ¡n', icon: 'â›°ï¸', tier: 16,
        attackChance: 11, hp: 1100, attacksPerTurn: 1, damage: 115,
        defense: 45, armor: 0, weapon: 0, dexterity: 5,
        speed: 1, capacity: 0,
        summonersNeeded: 2450, cost: { esencia: 10500 }, time: 108000, // 30h
        desc: 'Dios primordial de fuerza inconmensurable. Tier 16.'
      },
      lich: {
        name: 'Lich', icon: 'ğŸ’€', tier: 16,
        attackChance: 24, hp: 560, attacksPerTurn: 1, damage: 145,
        defense: 16, armor: 0, weapon: 0, dexterity: 24,
        speed: 2, capacity: 0,
        summonersNeeded: 2450, cost: { esencia: 10500 }, time: 108000,
        desc: 'Archimago no-muerto de precisiÃ³n y daÃ±o extremos. Tier 16.'
      },
      // â”€â”€ TIER 17 â€” 2.750 invocadores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      pegaso: {
        name: 'Pegaso', icon: 'ğŸ', tier: 17,
        attackChance: 18, hp: 660, attacksPerTurn: 2, damage: 102,
        defense: 22, armor: 0, weapon: 0, dexterity: 28,
        speed: 5, capacity: 0,
        summonersNeeded: 2750, cost: { esencia: 13000 }, time: 129600, // 36h
        desc: 'Caballo alado divino, el mÃ¡s veloz de los cielos. Tier 17.'
      },
      naga: {
        name: 'Naga', icon: 'ğŸ', tier: 17,
        attackChance: 16, hp: 760, attacksPerTurn: 3, damage: 92,
        defense: 26, armor: 0, weapon: 0, dexterity: 18,
        speed: 2, capacity: 0,
        summonersNeeded: 2750, cost: { esencia: 13000 }, time: 129600,
        desc: 'Serpiente divina de triple ataque y enorme resistencia. Tier 17.'
      },
      // â”€â”€ TIER 18 â€” 3.000 invocadores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      yeti: {
        name: 'Yeti', icon: 'â„ï¸', tier: 18,
        attackChance: 10, hp: 1320, attacksPerTurn: 1, damage: 125,
        defense: 48, armor: 0, weapon: 0, dexterity: 5,
        speed: 1, capacity: 0,
        summonersNeeded: 3000, cost: { esencia: 16000 }, time: 151200, // 42h
        desc: 'Bestia de las nieves eternas, tanque glacial supremo. Tier 18.'
      },
      satiro: {
        name: 'SÃ¡tiro', icon: 'ğŸ­', tier: 18,
        attackChance: 20, hp: 720, attacksPerTurn: 2, damage: 132,
        defense: 20, armor: 0, weapon: 0, dexterity: 28,
        speed: 4, capacity: 0,
        summonersNeeded: 3000, cost: { esencia: 16000 }, time: 151200,
        desc: 'Ser salvaje de gran agilidad y doble ataque certero. Tier 18.'
      },
      // â”€â”€ TIER 19 â€” 3.250 invocadores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      simurgh: {
        name: 'Simurgh', icon: 'ğŸ¦…', tier: 19,
        attackChance: 18, hp: 860, attacksPerTurn: 3, damage: 118,
        defense: 24, armor: 0, weapon: 0, dexterity: 26,
        speed: 4, capacity: 0,
        summonersNeeded: 3250, cost: { esencia: 19000 }, time: 172800, // 48h
        desc: 'Ave divina persa de triple ataque y gran sabidurÃ­a. Tier 19.'
      },
      gorgona: {
        name: 'Gorgona', icon: 'ğŸŒ‘', tier: 19,
        attackChance: 25, hp: 720, attacksPerTurn: 1, damage: 168,
        defense: 18, armor: 0, weapon: 0, dexterity: 24,
        speed: 2, capacity: 0,
        summonersNeeded: 3250, cost: { esencia: 19000 }, time: 172800,
        desc: 'Hermana mayor de Medusa, precisiÃ³n y daÃ±o legendarios. Tier 19.'
      },
      // â”€â”€ TIER 20 â€” 3.500 invocadores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      kraken: {
        name: 'Kraken', icon: 'ğŸ¦‘', tier: 20,
        attackChance: 14, hp: 1240, attacksPerTurn: 4, damage: 135,
        defense: 35, armor: 0, weapon: 0, dexterity: 12,
        speed: 1, capacity: 0,
        summonersNeeded: 3500, cost: { esencia: 23000 }, time: 201600, // 56h
        desc: 'Bestia marina colosal con cuÃ¡druple ataque demoledor. Tier 20.'
      },
      angelcaido: {
        name: 'Ãngel CaÃ­do', icon: 'ğŸ˜ˆ', tier: 20,
        attackChance: 22, hp: 920, attacksPerTurn: 2, damage: 188,
        defense: 22, armor: 0, weapon: 0, dexterity: 22,
        speed: 3, capacity: 0,
        summonersNeeded: 3500, cost: { esencia: 23000 }, time: 201600,
        desc: 'Ãngel corrompido de poder oscuro equilibrado. Tier 20.'
      },
      // â”€â”€ TIER 21 â€” 3.750 invocadores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      ammit: {
        name: 'Ammit', icon: 'âš–ï¸', tier: 21,
        attackChance: 13, hp: 1520, attacksPerTurn: 1, damage: 158,
        defense: 42, armor: 0, weapon: 0, dexterity: 8,
        speed: 1, capacity: 0,
        summonersNeeded: 3750, cost: { esencia: 28000 }, time: 230400, // 64h
        desc: 'Devorador de almas egipcio, tanque del inframundo. Tier 21.'
      },
      roc: {
        name: 'Roc', icon: 'ğŸ¦…', tier: 21,
        attackChance: 19, hp: 970, attacksPerTurn: 2, damage: 148,
        defense: 24, armor: 0, weapon: 0, dexterity: 26,
        speed: 5, capacity: 0,
        summonersNeeded: 3750, cost: { esencia: 28000 }, time: 230400,
        desc: 'Ave colosal de los mares, la mÃ¡s veloz del mundo. Tier 21.'
      },
      // â”€â”€ TIER 22 â€” 3.950 invocadores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      dragon: {
        name: 'DragÃ³n', icon: 'ğŸ²', tier: 22,
        attackChance: 20, hp: 1420, attacksPerTurn: 3, damage: 128,
        defense: 26, armor: 0, weapon: 0, dexterity: 16,
        speed: 3, capacity: 0,
        summonersNeeded: 3950, cost: { esencia: 35000 }, time: 259200, // 72h
        desc: 'DragÃ³n antiguo de poder legendario. Tier 22.'
      },
      arconte: {
        name: 'Arconte', icon: 'ğŸ‘¼', tier: 22,
        attackChance: 22, hp: 1200, attacksPerTurn: 2, damage: 108,
        defense: 38, armor: 0, weapon: 0, dexterity: 20,
        speed: 2, capacity: 0,
        summonersNeeded: 3950, cost: { esencia: 35000 }, time: 259200,
        desc: 'Ser celestial supremo de poder equilibrado. Tier 22.'
      },
      // â”€â”€ TIER 23 â€” 4.150 invocadores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      coloso: {
        name: 'Coloso', icon: 'âš™ï¸', tier: 23,
        attackChance: 11, hp: 2050, attacksPerTurn: 1, damage: 175,
        defense: 55, armor: 0, weapon: 0, dexterity: 4,
        speed: 1, capacity: 0,
        summonersNeeded: 4150, cost: { esencia: 42000 }, time: 288000, // 80h
        desc: 'Gigante de metal y piedra, el mayor tanque conocido. Tier 23.'
      },
      sleipnir: {
        name: 'Sleipnir', icon: 'ğŸ´', tier: 23,
        attackChance: 21, hp: 1130, attacksPerTurn: 2, damage: 188,
        defense: 22, armor: 0, weapon: 0, dexterity: 30,
        speed: 5, capacity: 0,
        summonersNeeded: 4150, cost: { esencia: 42000 }, time: 288000,
        desc: 'Corcel de ocho patas de OdÃ­n, velocidad sobrenatural. Tier 23.'
      },
      // â”€â”€ TIER 24 â€” 4.350 invocadores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      abismo: {
        name: 'Abismo', icon: 'ğŸŒ‘', tier: 24,
        attackChance: 12, hp: 2450, attacksPerTurn: 2, damage: 185,
        defense: 52, armor: 0, weapon: 0, dexterity: 5,
        speed: 1, capacity: 0,
        summonersNeeded: 4350, cost: { esencia: 50000 }, time: 316800, // 88h
        desc: 'Entidad del vacÃ­o eterno de resistencia absoluta. Tier 24.'
      },
      nemea: {
        name: 'Nemea', icon: 'ğŸ¦', tier: 24,
        attackChance: 22, hp: 1340, attacksPerTurn: 2, damage: 235,
        defense: 24, armor: 0, weapon: 0, dexterity: 22,
        speed: 3, capacity: 0,
        summonersNeeded: 4350, cost: { esencia: 50000 }, time: 316800,
        desc: 'LeÃ³n de Nemea de piel invulnerable y zarpa mortal. Tier 24.'
      },
      // â”€â”€ TIER 25 â€” 4.500 invocadores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      tifon: {
        name: 'TifÃ³n', icon: 'ğŸŒªï¸', tier: 25,
        attackChance: 18, hp: 1850, attacksPerTurn: 4, damage: 215,
        defense: 32, armor: 0, weapon: 0, dexterity: 16,
        speed: 2, capacity: 0,
        summonersNeeded: 4500, cost: { esencia: 60000 }, time: 345600, // 96h
        desc: 'Padre de todos los monstruos, cuÃ¡druple ataque titÃ¡nico. Tier 25.'
      },
      equidna: {
        name: 'Equidna', icon: 'ğŸ', tier: 25,
        attackChance: 20, hp: 1650, attacksPerTurn: 2, damage: 225,
        defense: 36, armor: 0, weapon: 0, dexterity: 20,
        speed: 2, capacity: 0,
        summonersNeeded: 4500, cost: { esencia: 60000 }, time: 345600,
        desc: 'Madre de todos los monstruos, equilibrio supremo. Tier 25.'
      },
      // â”€â”€ TIER 26 â€” 4.650 invocadores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      tarasca: {
        name: 'Tarasca', icon: 'ğŸŠ', tier: 26,
        attackChance: 12, hp: 2850, attacksPerTurn: 1, damage: 228,
        defense: 60, armor: 0, weapon: 0, dexterity: 4,
        speed: 1, capacity: 0,
        summonersNeeded: 4650, cost: { esencia: 72000 }, time: 374400, // 104h
        desc: 'Bestia medieval de coraza impenetrable. Tanque absoluto. Tier 26.'
      },
      garuda: {
        name: 'Garuda', icon: 'ğŸ¦…', tier: 26,
        attackChance: 21, hp: 1750, attacksPerTurn: 2, damage: 285,
        defense: 26, armor: 0, weapon: 0, dexterity: 26,
        speed: 5, capacity: 0,
        summonersNeeded: 4650, cost: { esencia: 72000 }, time: 374400,
        desc: 'Ave divina hinduista, seÃ±ora de los cielos y la velocidad. Tier 26.'
      },
      // â”€â”€ TIER 27 â€” 4.800 invocadores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      jormungandr: {
        name: 'JÃ¶rmungandr', icon: 'ğŸ', tier: 27,
        attackChance: 15, hp: 3050, attacksPerTurn: 3, damage: 248,
        defense: 44, armor: 0, weapon: 0, dexterity: 10,
        speed: 1, capacity: 0,
        summonersNeeded: 4800, cost: { esencia: 88000 }, time: 403200, // 112h
        desc: 'Serpiente del mundo nÃ³rdica que rodea los mares. Tier 27.'
      },
      valquiriaoscura: {
        name: 'Valquiria Oscura', icon: 'ğŸ–¤', tier: 27,
        attackChance: 25, hp: 1850, attacksPerTurn: 2, damage: 325,
        defense: 28, armor: 0, weapon: 0, dexterity: 24,
        speed: 3, capacity: 0,
        summonersNeeded: 4800, cost: { esencia: 88000 }, time: 403200,
        desc: 'Guerrera caÃ­da de precisiÃ³n y daÃ±o legendarios. Tier 27.'
      },
      // â”€â”€ TIER 28 â€” 4.900 invocadores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      primordio: {
        name: 'Primordio', icon: 'ğŸª¨', tier: 28,
        attackChance: 11, hp: 3550, attacksPerTurn: 1, damage: 268,
        defense: 65, armor: 0, weapon: 0, dexterity: 4,
        speed: 1, capacity: 0,
        summonersNeeded: 4900, cost: { esencia: 105000 }, time: 432000, // 120h
        desc: 'Entidad de la creaciÃ³n, resistencia mÃ¡s allÃ¡ de lo comprensible. Tier 28.'
      },
      azrael: {
        name: 'Azrael', icon: 'âš°ï¸', tier: 28,
        attackChance: 26, hp: 2050, attacksPerTurn: 2, damage: 385,
        defense: 24, armor: 0, weapon: 0, dexterity: 26,
        speed: 3, capacity: 0,
        summonersNeeded: 4900, cost: { esencia: 105000 }, time: 432000,
        desc: 'Ãngel de la muerte, precisiÃ³n y daÃ±o absolutos. Tier 28.'
      },
      // â”€â”€ TIER 29 â€” 4.950 invocadores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      ignisrex: {
        name: 'Ignis Rex', icon: 'ğŸ”´', tier: 29,
        attackChance: 20, hp: 2550, attacksPerTurn: 3, damage: 348,
        defense: 35, armor: 0, weapon: 0, dexterity: 18,
        speed: 2, capacity: 0,
        summonersNeeded: 4950, cost: { esencia: 125000 }, time: 460800, // 128h
        desc: 'Rey del fuego primordial, triple ataque devastador. Tier 29.'
      },
      fenrir: {
        name: 'Fenrir', icon: 'ğŸº', tier: 29,
        attackChance: 22, hp: 2250, attacksPerTurn: 3, damage: 365,
        defense: 28, armor: 0, weapon: 0, dexterity: 28,
        speed: 4, capacity: 0,
        summonersNeeded: 4950, cost: { esencia: 125000 }, time: 460800,
        desc: 'Lobo apocalÃ­ptico nÃ³rdico que destrozarÃ¡ el mundo. Tier 29.'
      },
      // â”€â”€ TIER 30 â€” 5.000 invocadores â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      moloch: {
        name: 'Moloch', icon: 'ğŸ”±', tier: 30,
        attackChance: 18, hp: 4050, attacksPerTurn: 2, damage: 510,
        defense: 50, armor: 0, weapon: 0, dexterity: 12,
        speed: 2, capacity: 0,
        summonersNeeded: 5000, cost: { esencia: 155000 }, time: 518400, // 144h
        desc: 'Dios devorador del fuego eterno, destrucciÃ³n encarnada. Tier 30.'
      },
      metatron: {
        name: 'MetatrÃ³n', icon: 'âœ¨', tier: 30,
        attackChance: 24, hp: 3100, attacksPerTurn: 3, damage: 462,
        defense: 44, armor: 0, weapon: 0, dexterity: 24,
        speed: 3, capacity: 0,
        summonersNeeded: 5000, cost: { esencia: 155000 }, time: 518400,
        desc: 'ArcÃ¡ngel supremo, equilibrio perfecto entre poder y divinidad. Tier 30.'
      }
    };

    // ============================================================
    // SCALING LOGIC
    // ============================================================
    function getTroopStatsWithLevel(type, level) {
      const base = TROOP_TYPES[type];
      if (!base) return null;
      if (!level || level < 1) level = 1;

      // New balanced scaling: ~4% bonus per level for HP/Damage
      // Fixed small increment for Chance/Defense/Dexterity
      const growth = 1 + (level - 1) * 0.04;

      return {
        ...base,
        level: level,
        hp: Math.floor(base.hp * growth),
        damage: Math.floor(base.damage * growth),
        attackChance: base.attackChance + (level - 1) * 0.5,
        defense: base.defense + (level - 1) * 0.5,
        dexterity: base.dexterity + (level - 1) * 0.5,
        // Speed remains constant, capacity scales slowly
        speed: base.speed,
        capacity: base.capacity + (level - 1) * 1
      };
    }

    // ============================================================
    // BUILDINGS â€” todos empiezan en nivel 1, producen desde nivel 1
    // Coste nivel 0 â†’ 1 es muy barato (casi gratis, es la "mejora inicial")
    // â”€â”€ FÃ³rmula unificada tres fases â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // COSTES:  Ã—2/nivel  hasta nv.10  |  Ã—1.30/nivel nv.11-30  |  Ã—1.05/nivel nv.31+
    // TIEMPOS: Ã—1.6/nivel hasta nv.10 |  Ã—1.20/nivel nv.11-30  |  Ã—1.05/nivel nv.31+
    // ============================================================
    function phasedVal(l, base, m1, e1, m2, e2, m3) {
      if (l <= e1) return base * Math.pow(m1, l);
      var v1 = base * Math.pow(m1, e1);
      if (l <= e2) return v1 * Math.pow(m2, l - e1);
      var v2 = v1 * Math.pow(m2, e2 - e1);
      return v2 * Math.pow(m3, l - e2);
    }

    const BUILDINGS = [
      // â”€â”€ RECURSOS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      {
        id: 'aserradero', name: 'Aserradero', icon: 'ğŸŒ²',
        desc: 'Produce madera por hora de forma pasiva. Los aldeanos asignados multiplican la producciÃ³n. Nivel 1 activo desde el inicio. Coste nv.10: ~67k madera / 16k piedra. Coste nv.30: ~13M madera / 3M piedra.',
        prod: function (l) { return { madera: Math.floor(30 + 40 * l * Math.pow(1.1, l)) }; },
        cost: function (l) {
          if (l === 0) return { madera: 0, piedra: 0 };
          return {
            madera: Math.floor(phasedVal(l, 65, 2, 10, 1.3, 30, 1.05)),
            piedra: Math.floor(phasedVal(l, 16, 2, 10, 1.3, 30, 1.05))
          };
        },
        time: function (l) { return l === 0 ? 0 : Math.floor(Math.max(10, phasedVal(l, 15, 1.6, 10, 1.2, 30, 1.05))); }
      },

      {
        id: 'cantera', name: 'Cantera', icon: 'â›°ï¸',
        desc: 'Produce piedra por hora de forma pasiva. Los aldeanos asignados multiplican la producciÃ³n. Nivel 1 activo desde el inicio. Coste nv.10: ~51k madera / 35k piedra. Coste nv.30: ~10M madera / 7M piedra.',
        prod: function (l) { return { piedra: Math.floor(20 + 30 * l * Math.pow(1.1, l)) }; },
        cost: function (l) {
          if (l === 0) return { madera: 0, piedra: 0 };
          return {
            madera: Math.floor(phasedVal(l, 50, 2, 10, 1.3, 30, 1.05)),
            piedra: Math.floor(phasedVal(l, 34, 2, 10, 1.3, 30, 1.05))
          };
        },
        time: function (l) { return l === 0 ? 0 : Math.floor(Math.max(10, phasedVal(l, 15, 1.6, 10, 1.2, 30, 1.05))); }
      },

      {
        id: 'minehierro', name: 'Mina de Hierro', icon: 'âš’ï¸',
        desc: 'Produce hierro por hora de forma pasiva. Los aldeanos asignados multiplican la producciÃ³n. Nivel 1 activo desde el inicio. Coste nv.10: ~87k madera / 70k piedra / 26k hierro. Coste nv.30: ~17M madera / 14M piedra / 5M hierro.',
        prod: function (l) { return { hierro: Math.floor(10 + 20 * l * Math.pow(1.1, l)) }; },
        cost: function (l) {
          if (l === 0) return { madera: 0, piedra: 0, hierro: 0 };
          return {
            madera: Math.floor(phasedVal(l, 85, 2, 10, 1.3, 30, 1.05)),
            piedra: Math.floor(phasedVal(l, 68, 2, 10, 1.3, 30, 1.05)),
            hierro: Math.floor(phasedVal(l, 25, 2, 10, 1.3, 30, 1.05))
          };
        },
        time: function (l) { return l === 0 ? 0 : Math.floor(Math.max(10, phasedVal(l, 18, 1.6, 10, 1.2, 30, 1.05))); }
      },

      // â”€â”€ GRANJA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      {
        id: 'granja', name: 'Granja', icon: 'ğŸŒ¾',
        desc: 'Aumenta las provisiones generadas por aldeano asignado. Nivel 1 = 6 prov./aldeano/h, +1 por nivel. Las provisiones se consumen al enviar tropas en misiÃ³n y no se recuperan al volver. Coste nv.10: ~51k madera / 35k piedra. Coste nv.30: ~10M madera / 7M piedra.',
        prod: function () { return {}; },
        cost: function (l) {
          if (l === 0) return { madera: 0, piedra: 0 };
          return {
            madera: Math.floor(phasedVal(l, 50, 2, 10, 1.3, 30, 1.05)),
            piedra: Math.floor(phasedVal(l, 34, 2, 10, 1.3, 30, 1.05))
          };
        },
        time: function (l) { return l === 0 ? 0 : Math.floor(Math.max(10, phasedVal(l, 15, 1.6, 10, 1.2, 30, 1.05))); }
      },

      // â”€â”€ MÃGICO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      {
        id: 'circulo', name: 'CÃ­rculo MÃ­stico', icon: 'âœ¨',
        desc: 'Canaliza la Esencia. La Esencia no ocupa almacÃ©n. Requiere madera, piedra y Esencia para subir. Coste nv.10: ~174k madera+piedra / 38k esencia. Coste nv.30: ~34M madera+piedra / 7M esencia.',
        prod: function (l) { return { esencia: Math.floor(5 + 15 * l * Math.pow(1.1, l)) }; },
        cost: function (l) {
          if (l === 0) return { madera: 0, piedra: 0, esencia: 0 };
          return {
            madera: Math.floor(phasedVal(l, 170, 2, 10, 1.3, 30, 1.05)),
            piedra: Math.floor(phasedVal(l, 170, 2, 10, 1.3, 30, 1.05)),
            esencia: Math.floor(phasedVal(l, 37, 2, 10, 1.3, 30, 1.05))
          };
        },
        time: function (l) { return l === 0 ? 0 : Math.floor(Math.max(20, phasedVal(l, 30, 1.6, 10, 1.2, 30, 1.05))); }
      },

      // â”€â”€ ALMACENAMIENTO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      {
        id: 'almacen', name: 'AlmacÃ©n', icon: 'ğŸ›ï¸',
        desc: 'Aumenta la capacidad mÃ¡xima de madera, piedra, hierro y provisiones. Nv.0 = 1.000 | Nv.10 â‰ˆ 1M | Nv.30 â‰ˆ 195M. Es el edificio mÃ¡s caro de subir â€” debes priorizar el AlmacÃ©n antes que el resto. La Esencia tiene lÃ­mite separado.',
        prod: function () { return {}; },
        cost: function (l) {
          if (l === 0) return { madera: 0, piedra: 0, hierro: 0 };
          return {
            madera: Math.floor(phasedVal(l, 500, 2, 10, 1.3, 30, 1.05)),
            piedra: Math.floor(phasedVal(l, 500, 2, 10, 1.3, 30, 1.05)),
            hierro: Math.floor(phasedVal(l, 250, 2, 10, 1.3, 30, 1.05))
          };
        },
        time: function (l) { return l === 0 ? 0 : Math.floor(Math.max(15, phasedVal(l, 60, 1.6, 10, 1.2, 30, 1.05))); }
      },

      // â”€â”€ MILITAR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      {
        id: 'barracas', name: 'Barracas', icon: 'ğŸ°',
        desc: 'Capacidad mÃ¡xima de tropas normales (no criaturas). Nivel 1 = 50 plazas, Ã—1.40 por nivel. Las tropas en misiÃ³n no ocupan plaza. Coste nv.10: ~205k madera / 307k piedra / 102k hierro. Coste nv.30: ~40M madera / 61M piedra / 20M hierro.',
        prod: function () { return {}; },
        cost: function (l) {
          if (l === 0) return { madera: 0, piedra: 0, hierro: 0 };
          return {
            madera: Math.floor(phasedVal(l, 200, 2, 10, 1.3, 30, 1.05)),
            piedra: Math.floor(phasedVal(l, 300, 2, 10, 1.3, 30, 1.05)),
            hierro: Math.floor(phasedVal(l, 100, 2, 10, 1.3, 30, 1.05))
          };
        },
        time: function (l) { return l === 0 ? 0 : Math.floor(Math.max(15, phasedVal(l, 40, 1.6, 10, 1.2, 30, 1.05))); }
      },

      {
        id: 'reclutamiento', name: 'Reclutamiento', icon: 'âš”ï¸',
        desc: 'Genera aldeanos automÃ¡ticamente. Nv.1 â‰ˆ 9 min 54s por aldeano. Cada nivel reduce el intervalo un 1% (nv.50 = 5 min, mÃ­nimo 1 min desde nv.90). Los aldeanos se pierden si las Barracas estÃ¡n llenas. Coste nv.10: ~133k madera / 92k piedra / 46k hierro. Coste nv.30: ~26M madera / 18M piedra / 9M hierro.',
        prod: function () { return {}; },
        cost: function (l) {
          if (l === 0) return { madera: 0, piedra: 0, hierro: 0 };
          return {
            madera: Math.floor(phasedVal(l, 130, 2, 10, 1.3, 30, 1.05)),
            piedra: Math.floor(phasedVal(l, 90, 2, 10, 1.3, 30, 1.05)),
            hierro: Math.floor(phasedVal(l, 45, 2, 10, 1.3, 30, 1.05))
          };
        },
        time: function (l) { return l === 0 ? 0 : Math.floor(Math.max(10, phasedVal(l, 25, 1.6, 10, 1.2, 30, 1.05))); }
      },

      {
        id: 'muralla', name: 'Muralla', icon: 'ğŸ°',
        desc: 'Escudo de la aldea con HP propio. El atacante debe destruirla antes de daÃ±ar tus tropas. +500 HP por nivel. Solo requiere piedra y hierro. Coste nv.10: ~358k piedra / 143k hierro. Coste nv.30: ~70M piedra / 28M hierro.',
        prod: function () { return {}; },
        cost: function (l) {
          if (l === 0) return { piedra: 0, hierro: 0 };
          return {
            piedra: Math.floor(phasedVal(l, 350, 2, 10, 1.3, 30, 1.05)),
            hierro: Math.floor(phasedVal(l, 140, 2, 10, 1.3, 30, 1.05))
          };
        },
        time: function (l) { return l === 0 ? 0 : Math.floor(Math.max(30, phasedVal(l, 50, 1.6, 10, 1.2, 30, 1.05))); }
      },

      {
        id: 'lab', name: 'Laboratorio', icon: 'ğŸ“œ',
        desc: 'Permite investigar nuevas tecnologÃ­as (prÃ³ximamente activo). Uno de los edificios mÃ¡s caros: requiere madera, piedra y Esencia. Coste nv.10: ~287k madera / 430k piedra / 102k esencia. Coste nv.30: ~56M madera / 84M piedra / 20M esencia.',
        prod: function () { return {}; },
        cost: function (l) {
          if (l === 0) return { madera: 0, piedra: 0, esencia: 0 };
          return {
            madera: Math.floor(phasedVal(l, 280, 2, 10, 1.3, 30, 1.05)),
            piedra: Math.floor(phasedVal(l, 420, 2, 10, 1.3, 30, 1.05)),
            esencia: Math.floor(phasedVal(l, 100, 2, 10, 1.3, 30, 1.05))
          };
        },
        time: function (l) { return l === 0 ? 0 : Math.floor(Math.max(15, phasedVal(l, 45, 1.6, 10, 1.2, 30, 1.05))); }
      },

      {
        id: 'cuarteles', name: 'Cuarteles', icon: 'ğŸ–ï¸',
        desc: 'Reduce el tiempo de entrenamiento de tropas (excepto aldeanos y criaturas) un 1% por nivel, hasta un mÃ¡ximo del 50% en nv.50. Coste nv.10: ~225k madera / 307k piedra / 123k hierro. Coste nv.30: ~44M madera / 61M piedra / 24M hierro.',
        prod: function () { return {}; },
        cost: function (l) {
          if (l === 0) return { madera: 0, piedra: 0, hierro: 0 };
          return {
            madera: Math.floor(phasedVal(l, 220, 2, 10, 1.3, 30, 1.05)),
            piedra: Math.floor(phasedVal(l, 300, 2, 10, 1.3, 30, 1.05)),
            hierro: Math.floor(phasedVal(l, 120, 2, 10, 1.3, 30, 1.05))
          };
        },
        time: function (l) { return l === 0 ? 0 : Math.floor(Math.max(20, phasedVal(l, 40, 1.6, 10, 1.2, 30, 1.05))); }
      },

      {
        id: 'torre', name: 'Torre de VigÃ­a', icon: 'ğŸ—¼',
        desc: 'Controla el alcance de tu aldea. Nivel 1 = 10 casillas de alcance, +10 por nivel (radio circular real). Sin Torre no puedes atacar, espiar ni fundar nuevas aldeas. Coste nv.10: ~72k madera / 143k piedra. Coste nv.30: ~14M madera / 28M piedra.',
        prod: function () { return {}; },
        cost: function (l) {
          if (l === 0) return { madera: 0, piedra: 0 };
          return {
            madera: Math.floor(phasedVal(l, 70, 2, 10, 1.3, 30, 1.05)),
            piedra: Math.floor(phasedVal(l, 140, 2, 10, 1.3, 30, 1.05))
          };
        },
        time: function (l) { return l === 0 ? 0 : Math.floor(Math.max(20, phasedVal(l, 35, 1.6, 10, 1.2, 30, 1.05))); }
      },

      {
        id: 'torreinvocacion', name: 'Torre de InvocaciÃ³n', icon: 'ğŸ”®',
        desc: 'Desbloquea la invocaciÃ³n de criaturas poderosas. Reduce un 5% el tiempo de invocaciÃ³n por nivel. Necesitas Invocadores entrenados. Requiere madera, piedra y Esencia. Coste nv.10: ~205k madera / 307k piedra / 102k esencia. Coste nv.30: ~40M madera / 61M piedra / 20M esencia.',
        prod: function () { return {}; },
        cost: function (l) {
          if (l === 0) return { madera: 0, piedra: 0, esencia: 0 };
          return {
            madera: Math.floor(phasedVal(l, 200, 2, 10, 1.3, 30, 1.05)),
            piedra: Math.floor(phasedVal(l, 300, 2, 10, 1.3, 30, 1.05)),
            esencia: Math.floor(phasedVal(l, 100, 2, 10, 1.3, 30, 1.05))
          };
        },
        time: function (l) { return l === 0 ? 0 : Math.floor(Math.max(40, phasedVal(l, 55, 1.6, 10, 1.2, 30, 1.05))); }
      },
    ];

    // Capacidad barracas â€” lee el edificio 'barracas'
    // Nivel 1: 50 plazas. +20 por cada nivel adicional.
    function getCuartelesReduction(blds) {
      // Each level of Cuarteles = 1% faster training (max 50%)
      var lvl = (blds && blds['cuarteles'] && blds['cuarteles'].level) || 0;
      return Math.min(0.5, lvl * 0.01);
    }

    function getBarracksCapacity(blds) {
      var lvl = (blds['barracas'] && blds['barracas'].level) || 0;
      if (lvl === 0) return 0;
      // v1.30: fÃ³rmula exponencial base 1.40
      // lvl1=50, lvl5=192, lvl10=1.033, lvl15=5.556, lvl20=29.882
      return Math.round(50 * Math.pow(1.40, lvl - 1));
    }

    // ============================================================
    // BARRACAS â€” fuente de verdad para plazas ocupadas
    // Regla: plazas = aldeanos + tropas_militares - tropas_en_mision
    // Las tropas en misiÃ³n (ataque, espionaje, movimiento) NO ocupan plaza.
    // ============================================================
    function getBarracksUsed(vs) {
      if (!vs) return 0;
      var troops = vs.troops || {};
      var missions = vs.mission_queue || [];

      // Contar tropas actualmente EN MISIÃ“N (tipo attack, spy, o move/return saliente)
      var inMission = {};
      missions.forEach(function (m) {
        if (!m.troops) return;
        // Las misiones 'return' ya vienen hacia casa â€” aÃºn estÃ¡n fuera, no ocupan plaza
        Object.keys(m.troops).forEach(function (k) {
          inMission[k] = (inMission[k] || 0) + (m.troops[k] || 0);
        });
      });

      var used = 0;
      // troops.aldeano = TOTAL de aldeanos en base (libres + trabajando).
      // Los trabajadores (aldeanos_assigned) son un SUBCONJUNTO de troops.aldeano, NO se suman aparte.
      var aldInBase = Math.max(0, (troops.aldeano || 0) - (inMission.aldeano || 0));
      used += aldInBase;

      // Tropas militares que NO son aldeano
      Object.keys(TROOP_TYPES).forEach(function (k) {
        if (k === 'aldeano') return;
        var inBase = Math.max(0, (troops[k] || 0) - (inMission[k] || 0));
        used += inBase * (TROOP_TYPES[k].barracasSlots || 1);
      });

      // v1.17: Tropas EN ENTRENAMIENTO reservan su espacio desde que entran en cola.
      // AsÃ­ funciona en Ogame/Ikariam â€” el slot estÃ¡ ocupado durante toda la transformaciÃ³n.
      // Sin esto: aldeano se resta de troops pero el slot que va a ocupar la tropa
      // final no se reserva, producciÃ³n de aldeanos lo llena, y al llegar la tropa â†’ overflow.
      var trainingQueue = vs.training_queue || [];
      trainingQueue.forEach(function (t) {
        if (t.type && TROOP_TYPES[t.type] && t.type !== 'aldeano') {
          used += (TROOP_TYPES[t.type].barracasSlots || 1);
        }
      });

      return used;
    }

    // Tasa de producciÃ³n de aldeanos/hora â€” edificio 'reclutamiento'
    function getAldeanosProd(blds) {
      // LEGACY: devuelve 0 â€” la producciÃ³n de aldeanos ahora es discreta (ver calcAldeanosTick)
      return 0;
    }

    // Minutos entre un aldeano y el siguiente segÃºn nivel del edificio reclutamiento.
    // v1.30: FÃ³rmula: 10 * (1 - 0.01 * lvl). MÃ­nimo: 1 min (a partir del nivel 90).
    // Ejemplos: lvl1â‰ˆ9:54, lvl25=7:30, lvl50=5:00, lvl90=1:00
    function getAldeanosIntervalMs(blds) {
      var lvl = (blds['reclutamiento'] && blds['reclutamiento'].level) || 0;
      if (lvl === 0) return Infinity; // sin edificio = sin producciÃ³n
      var baseMin = 10;
      var mins = baseMin * (1 - 0.01 * lvl);
      mins = Math.max(1, mins); // mÃ­nimo 1 minuto
      return Math.round(mins * 60 * 1000); // en milisegundos
    }

    // Calcula cuÃ¡ntos aldeanos se han producido desde last_aldeano_at
    // y actualiza el estado. Llamar antes de cualquier acciÃ³n que use aldeanos.
    // Regla: si barracas llenas â†’ aldeanos producidos se pierden (producciÃ³n no se pausa).
    function calcAndApplyAldeanos(vs) {
      var barrCap = getBarracksCapacity(vs.buildings);
      if (!vs.troops) vs.troops = {};

      var intervalMs = getAldeanosIntervalMs(vs.buildings);
      if (intervalMs === Infinity) return;

      var now = Date.now();
      var lastAld = vs.last_aldeano_at ? new Date(vs.last_aldeano_at).getTime() : now;
      var elapsed = now - lastAld;

      var newAldeanos = Math.floor(elapsed / intervalMs);
      if (newAldeanos <= 0) return;

      // Siempre avanzar el timer â€” la producciÃ³n no se pausa aunque se pierdan aldeanos
      var remainder = elapsed - (newAldeanos * intervalMs);
      vs.last_aldeano_at = new Date(now - remainder).toISOString();

      // Calcular espacio disponible usando la fuente de verdad
      var used = getBarracksUsed(vs);
      var free = Math.max(0, barrCap - used);

      if (free <= 0) return; // barracas llenas â€” aldeanos producidos se pierden en silencio

      // Solo aÃ±adir los que caben
      var toAdd = Math.min(newAldeanos, free);
      vs.troops.aldeano = (vs.troops.aldeano || 0) + toAdd;
    }

    // Provisiones por aldeano en granja: base 5 + nivel granja (nivel 1 = 6/h por aldeano)

    // Capacidad del almacen: tres fases
    // nv.0=1.000 | nv.10â‰ˆ1.024.000 | nv.30â‰ˆ195M | nv.50â‰ˆ517M
    function almacenCapForLevel(l) {
      if (l <= 10) return 1000 * Math.pow(2, l);
      var v10 = 1000 * Math.pow(2, 10); // 1.024.000
      if (l <= 30) return v10 * Math.pow(1.3, l - 10);
      var v30 = v10 * Math.pow(1.3, 20); // ~194.6M
      return v30 * Math.pow(1.05, l - 30);
    }
    function getCapacity(blds) {
      var lvl = (blds['almacen'] && blds['almacen'].level) || 0;
      return Math.floor(almacenCapForLevel(lvl));
    }

    // Recursos que cuentan para el almacen
    function getStoredTotal(res) {
      return (res.madera || 0) + (res.piedra || 0) + (res.hierro || 0) + (res.provisiones || 0);
    }

    // ============================================================
    // TROPAS
    // ============================================================
    function renderTroops() {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      var res = calcRes(vs);
      var w = vs.aldeanos_assigned || defaultAssignments();
      var range = getTorreRange(vs.buildings);
      var lvl = (vs.buildings.torre && vs.buildings.torre.level) || 0;

      renderTrainingQueue();
      renderTrainOptions();

      var box = document.getElementById('troopsListBox');
      if (!box) return;

      var troops = vs.troops || defaultTroops();
      var barrCap = getBarracksCapacity(vs.buildings);

      var usedSlots = getBarracksUsed(vs);
      // Tropas militares (no aldeanos) para mostrar en desglose
      var usedTroopSlots = 0;
      Object.keys(TROOP_TYPES).forEach(function (k) {
        if (k === 'aldeano') return;
        usedTroopSlots += (troops[k] || 0) * (TROOP_TYPES[k].barracasSlots || 1);
      });

      var aldWorking = res.aldeanos_working || 0;
      var aldTotal = res.aldeanos_total || 0;

      var html = '<div style="display:flex;justify-content:space-between;align-items:center;padding:8px 0 12px;border-bottom:2px solid var(--border);margin-bottom:8px;">'
        + '<span style="font-size:.75rem;color:var(--dim);">PLAZAS OCUPADAS</span>'
        + '<span style="font-size:.85rem;color:var(--accent);"><b>' + usedSlots + '</b> / ' + barrCap + '</span>'
        + '</div>'
        + '<div style="background:var(--panel2);border:1px solid var(--border);border-radius:6px;padding:8px 12px;margin-bottom:10px;font-size:.72rem;">'
        + '<div style="display:flex;justify-content:space-between;margin-bottom:6px;">'
        + '<span style="color:var(--dim)">ğŸ‘¤ Aldeanos</span>'
        + '<span style="color:var(--aldeanos);font-size:.85rem;"><b>' + aldTotal + '</b></span>'
        + '</div>'
        + '<div style="display:flex;justify-content:space-between;">'
        + '<span style="color:var(--dim)">âš”ï¸ Tropas militares (plazas)</span>'
        + '<span style="color:var(--text)">' + usedTroopSlots + '</span>'
        + '</div>'
        + '</div>'
        + '<div style="margin-bottom:4px;"></div>';

      // troopsListBox ya no se usa â€” la lista estÃ¡ integrada en renderTrainOptions
      box.innerHTML = '';
    }

    // ============================================================
    // CREATURES UI RENDERING
    // ============================================================

    function renderCreatures() {
      if (!activeVillage) return;
      var vs = activeVillage.state;

      // Torre de InvocaciÃ³n info
      var torreLevel = (vs.buildings.torreinvocacion && vs.buildings.torreinvocacion.level) || 0;
      var torreInfo = document.getElementById('torreInvocacionInfo');
      if (torreInfo) {
        if (torreLevel === 0) {
          torreInfo.innerHTML = '<span style="color:var(--danger);">âš ï¸ Torre de InvocaciÃ³n no construida</span>';
        } else {
          var reduction = torreLevel * 5;
          torreInfo.innerHTML = 'Nivel ' + torreLevel + ' â€¢ <span style="color:var(--ok);">-' + reduction + '% tiempo de invocaciÃ³n</span>';
        }
      }

      // Cola de invocaciÃ³n
      renderSummoningQueue();

      // Lista de criaturas actuales
      renderCreaturesList();

      // Botones de invocaciÃ³n
      renderSummonOptions();
    }

    function renderSummoningQueue() {
      var box = document.getElementById('summoningQueueBox');
      if (!box || !activeVillage) return;

      var vs = activeVillage.state;
      var queue = vs.summoning_queue || [];

      if (queue.length === 0) {
        box.innerHTML = '<div style="color:var(--dim);font-size:.8rem;">No hay invocaciones en curso</div>';
        return;
      }

      var html = '';
      var now = Date.now();

      // First item: active with progress bar
      var active = queue[0];
      var cData = CREATURE_TYPES[active.creature];
      if (cData) {
        var finish = new Date(active.finish_at).getTime();
        var timeLeft = Math.max(0, Math.ceil((finish - now) / 1000));
        var start = new Date(active.start_at).getTime();
        var total = Math.max(1, (finish - start) / 1000);
        var pct = Math.min(100, Math.round(((total - timeLeft) / total) * 100));
        var paused = active.paused;
        if (paused) pct = 0;

        html += '<div style="background:var(--panel2);padding:8px 10px;border-radius:6px;margin-bottom:8px;">';
        html += '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:5px;">';
        html += '<span style="font-size:.9rem;">' + cData.icon + ' ' + cData.name + '</span>';
        html += '<span style="font-size:.75rem;color:var(--ok);">' + fmtTime(timeLeft) + '</span>';
        html += '</div>';
        html += '<div style="background:var(--bg);height:7px;border-radius:4px;overflow:hidden;">';
        html += '<div style="width:' + pct + '%;height:100%;background:var(--ok);transition:width 1s linear;"></div>';
        html += '</div>';
        if (paused) {
          var inv = vs.troops.invocador || 0;
          html += '<div style="color:var(--danger);font-size:.68rem;margin-top:4px;">âš ï¸ PAUSADA â€” Faltan ' + (active.summonersNeeded - inv) + ' invocadores</div>';
        }
        html += '</div>';
      }

      // Remaining items: grouped by creature type, just count
      if (queue.length > 1) {
        var waiting = queue.slice(1);
        var counts = {};
        waiting.forEach(function (s) {
          counts[s.creature] = (counts[s.creature] || 0) + 1;
        });
        var lastFinishQ = new Date(queue[queue.length - 1].finish_at);
        var lastStrQ = lastFinishQ.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        var totalLeft = Math.max(0, Math.ceil((lastFinishQ.getTime() - Date.now()) / 1000));
        html += '<div style="background:var(--panel2);padding:7px 10px;border-radius:6px;">';
        html += '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:5px;">';
        html += '<div style="font-size:.68rem;color:var(--dim);letter-spacing:.08em;">EN ESPERA</div>';
        html += '<div style="font-size:.63rem;color:var(--dim);">Cola completa: <span style="color:var(--accent);">' + fmtTime(totalLeft) + '</span> Â· <b>' + lastStrQ + '</b></div>';
        html += '</div>';
        html += '<div style="display:flex;flex-wrap:wrap;gap:6px;">';
        Object.keys(counts).forEach(function (key) {
          var cd = CREATURE_TYPES[key];
          if (!cd) return;
          html += '<div style="display:flex;align-items:center;gap:4px;background:var(--bg);padding:3px 8px;border-radius:4px;font-size:.78rem;">';
          html += cd.icon + ' ' + cd.name + ' <span style="color:var(--ok);font-weight:bold;margin-left:2px;">Ã—' + counts[key] + '</span>';
          html += '</div>';
        });
        html += '</div></div>';
      }

      box.innerHTML = html;
    }

    function renderCreaturesList() {
      var box = document.getElementById('creaturesListBox');
      if (!box || !activeVillage) return;

      var vs = activeVillage.state;
      var creatures = vs.creatures || defaultCreatures();

      var hasAny = false;
      var html = '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(140px,1fr));gap:8px;">';

      Object.keys(CREATURE_TYPES).forEach(function (key) {
        var count = creatures[key] || 0;
        if (count === 0) return;
        hasAny = true;

        var cData = CREATURE_TYPES[key];
        html += '<div style="background:var(--panel2);padding:10px;border-radius:6px;text-align:center;">';
        html += '<div style="font-size:2rem;">' + cData.icon + '</div>';
        html += '<div style="font-size:.75rem;margin-top:4px;">' + cData.name + '</div>';
        html += '<div style="font-size:1.2rem;color:var(--ok);font-weight:bold;margin-top:4px;">' + count + '</div>';
        html += '</div>';
      });

      html += '</div>';

      if (!hasAny) {
        box.innerHTML = '<div style="color:var(--dim);font-size:.8rem;">No tienes criaturas invocadas</div>';
      } else {
        box.innerHTML = html;
      }
    }

    function showCreatureStats(key) {
      var c = CREATURE_TYPES[key];
      if (!c) return;
      var existing = document.getElementById('creatureStatsModal');
      if (existing) existing.remove();
      var overlay = document.createElement('div');
      overlay.id = 'creatureStatsModal';
      overlay.style.cssText = 'position:fixed;inset:0;z-index:9999;background:rgba(0,0,0,.75);display:flex;align-items:center;justify-content:center;';
      overlay.onclick = function (e) { if (e.target === overlay) overlay.remove(); };
      window._closeCreatureStats = function () { var m = document.getElementById('creatureStatsModal'); if (m) m.remove(); };
      overlay.innerHTML = '<div style="background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:20px;max-width:340px;width:90%;font-family:VT323,monospace;">'
        + '<div style="display:flex;align-items:center;gap:10px;margin-bottom:14px;border-bottom:1px solid var(--border);padding-bottom:10px;">'
        + '<span style="font-size:2.5rem;">' + c.icon + '</span>'
        + '<div><div style="font-size:1.2rem;color:var(--accent);">' + c.name + '</div>'
        + '<div style="font-size:.7rem;color:var(--esencia);">TIER ' + c.tier + ' â€” ' + (c.type || 'criatura') + '</div></div>'
        + '<button onclick="_closeCreatureStats()" style="margin-left:auto;background:none;border:none;color:var(--dim);font-size:1.2rem;cursor:pointer;">âœ•</button>'
        + '</div>'
        + '<div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;font-size:.82rem;margin-bottom:14px;">'
        + '<div style="color:var(--dim);">â¤ï¸ HP</div><div style="color:var(--text);">' + c.hp + '</div>'
        + '<div style="color:var(--dim);">âš”ï¸ DaÃ±o</div><div style="color:var(--text);">' + c.damage + '</div>'
        + '<div style="color:var(--dim);">ğŸ›¡ï¸ Defensa</div><div style="color:var(--text);">' + c.defense + '</div>'
        + '<div style="color:var(--dim);">âš¡ Ataques/turno</div><div style="color:var(--text);">' + c.attacksPerTurn + '</div>'
        + '<div style="color:var(--dim);">ğŸ¯ PrecisiÃ³n</div><div style="color:var(--text);">' + c.attackChance + '</div>'
        + '<div style="color:var(--dim);">ğŸƒ Velocidad</div><div style="color:var(--text);">' + c.speed + '</div>'
        + '</div>'
        + '<div style="font-size:.72rem;color:var(--dim);border-top:1px solid var(--border);padding-top:10px;margin-bottom:14px;">' + escapeHtml(c.desc) + '</div>'
        + '<div style="font-size:.75rem;background:var(--panel2);border-radius:6px;padding:8px;display:grid;grid-template-columns:1fr 1fr 1fr;gap:4px;text-align:center;">'
        + '<div><div style="color:var(--dim);">Invocadores</div><div style="color:var(--esencia);">' + c.summonersNeeded + '</div></div>'
        + '<div><div style="color:var(--dim);">Esencia</div><div style="color:var(--esencia);">âœ¨ ' + c.cost.esencia + '</div></div>'
        + '<div><div style="color:var(--dim);">Tiempo</div><div style="color:var(--gold);">â± ' + Math.floor(c.time / 60) + 'min</div></div>'
        + '</div>'
        + '</div>';
      document.body.appendChild(overlay);
    }

    function renderSummonOptions() {
      var box = document.getElementById('summonBox');
      if (!box || !activeVillage) return;

      var vs = activeVillage.state;
      var torreLevel = (vs.buildings.torreinvocacion && vs.buildings.torreinvocacion.level) || 0;

      if (torreLevel === 0) {
        box.innerHTML = '<div style="color:var(--danger);font-size:.85rem;">âš ï¸ Construye la Torre de InvocaciÃ³n primero</div>';
        return;
      }

      var invocadorLevel = getTroopLevel('invocador');
      var invocadoresActuales = vs.troops.invocador || 0;

      var html = '<div style="display:grid;gap:10px;">';

      // Group by tier
      var tiers = {};
      Object.keys(CREATURE_TYPES).forEach(function (key) {
        var cData = CREATURE_TYPES[key];
        if (!tiers[cData.tier]) tiers[cData.tier] = [];
        tiers[cData.tier].push({ key: key, data: cData });
      });

      Object.keys(tiers).sort().forEach(function (tier) {
        var tierInt = parseInt(tier);
        // VISIBLE si el nivel de la Torre de InvocaciÃ³n >= tier
        // INVOCABLE solo si ademÃ¡s tienes los invocadores necesarios
        var visible = torreLevel >= tierInt;
        var unlocked = invocadorLevel >= tierInt;

        // Ocultar solo si la torre no tiene nivel suficiente
        if (!visible) return;

        html += '<div style="background:var(--panel2);padding:10px;border-radius:6px;">';
        html += '<div style="font-size:.75rem;color:var(--dim);letter-spacing:.1em;margin-bottom:8px;">TIER ' + tier + '</div>';

        tiers[tier].forEach(function (c) {
          var canSummonResult = canSummon(c.key, vs);
          var isOk = canSummonResult.ok;

          html += '<div style="display:flex;align-items:center;gap:8px;padding:8px;background:var(--bg);border-radius:4px;margin-bottom:6px;' + (!unlocked ? 'opacity:.5;filter:grayscale(.4);' : (!isOk ? 'opacity:.7;' : '')) + '">';
          // Icon clickable for stats
          html += '<button onclick="showCreatureStats(\'' + c.key + '\')" title="Ver estadÃ­sticas" style="background:none;border:none;cursor:pointer;font-size:1.8rem;padding:0;line-height:1;flex-shrink:0;">' + c.data.icon + '</button>';
          html += '<div style="flex:1;min-width:0;">';
          html += '<div style="font-size:.85rem;color:var(--text);">' + c.data.name + '</div>';
          html += '<div style="font-size:.68rem;color:var(--dim);margin-top:2px;">';
          html += 'ğŸ§™â€â™‚ï¸ ' + c.data.summonersNeeded + ' Â· âœ¨ ' + c.data.cost.esencia + ' Â· â± ' + Math.floor(c.data.time / 60) + 'min';
          html += '</div>';
          if (!unlocked) {
            html += '<div style="font-size:.63rem;color:var(--dim);margin-top:2px;">ğŸ”’ Requiere invocadores de nivel ' + tierInt + ' para invocar</div>';
          } else if (!isOk) {
            html += '<div style="font-size:.63rem;color:var(--danger);margin-top:2px;">' + escapeHtml(canSummonResult.reason) + '</div>';
          }
          html += '</div>';
          // Quantity input + button
          html += '<div style="display:flex;align-items:center;gap:4px;flex-shrink:0;">';
          html += '<input id="summonQty_' + c.key + '" type="number" value="1" min="1" max="99" style="width:46px;background:rgba(255,255,255,.06);border:1px solid var(--border);border-radius:4px;padding:4px 6px;color:var(--text);font-family:VT323,monospace;font-size:.85rem;text-align:center;">';
          html += '<button onclick="startSummoningFromInput(\'' + c.key + '\')" ' + (!isOk ? 'disabled' : '') + ' style="background:' + (isOk ? 'var(--ok)' : 'var(--border)') + ';border:none;color:white;padding:5px 10px;border-radius:4px;cursor:' + (isOk ? 'pointer' : 'default') + ';font-size:.75rem;white-space:nowrap;">+ Cola</button>';
          html += '</div>';
          html += '</div>';
        });

        html += '</div>';
      });

      html += '</div>';
      box.innerHTML = html;
    }


    function showBarracasModal() {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      var res = calcRes(vs);
      var barrCap = getBarracksCapacity(vs.buildings);
      var usedSlots = getBarracksUsed(vs);

      var html = '<div class="bld-modal-overlay" id="barrOverlay" onclick="if(event.target.id===\'barrOverlay\') this.remove()">'
        + '<div class="bld-modal" style="max-width:800px;">'
        + '<div class="bld-modal-head">'
        + '<div class="bld-modal-icon">ğŸ°</div>'
        + '<div><div class="bld-modal-title">BARRACAS</div>'
        + '<div class="bld-modal-sub">Recluta tropas para tu ejÃ©rcito. Plazas: ' + usedSlots + ' / ' + barrCap + '</div></div>'
        + '<button class="bld-modal-close" onclick="this.closest(\'.bld-modal-overlay\').remove()">&#x2715;</button>'
        + '</div>'
        + '<div class="bld-modal-body" style="display:grid;grid-template-columns:repeat(auto-fill, minmax(240px, 1fr));gap:15px;padding:20px;">';

      Object.keys(TROOP_TYPES).forEach(function (key) {
        var stats = getTroopStatsWithLevel(key, 1);
        var cost = stats.cost || {};
        html += '<div style="background:var(--panel2);border:1px solid var(--border);border-radius:8px;padding:12px;display:flex;flex-direction:column;gap:8px;">'
          + '<div style="display:flex;align-items:center;gap:10px;">'
          + '<span style="font-size:1.8rem;">' + stats.icon + '</span>'
          + '<div style="flex:1;">'
          + '<div style="font-size:.9rem;font-weight:700;">' + stats.name + '</div>'
          + '<div style="font-size:.65rem;color:var(--dim);">' + stats.desc + '</div>'
          + '</div>'
          + '</div>'
          + '<div style="display:flex;gap:10px;font-size:.75rem;flex-wrap:wrap;color:var(--accent);">';
        if (cost.madera) html += '<span>ğŸŒ² ' + cost.madera + '</span>';
        if (cost.hierro) html += '<span>âš™ï¸ ' + cost.hierro + '</span>';
        if (cost.prov) html += '<span>ğŸŒ¾ ' + cost.prov + '</span>';
        if (cost.esencia) html += '<span>âœ¨ ' + cost.esencia + '</span>';
        html += '</div>'
          + '<div style="display:flex;gap:6px;margin-top:4px;">'
          + '<input type="number" id="recAmount-' + key + '" value="1" min="1" class="input" style="flex:1;padding:4px 8px;font-size:.8rem;">'
          + '<button class="btn" style="padding:6px 12px;font-size:.75rem;" onclick="startRecruitment(\'' + key + '\')">Reclutar</button>'
          + '</div>'
          + '</div>';
      });

      html += '</div></div></div>';
      var mod = document.createElement('div');
      mod.innerHTML = html;
      document.body.appendChild(mod.firstChild);
    }

    function startRecruitmentFromInput(type) {
      var input = document.getElementById('trainQty_' + type);
      var amount = input ? (parseInt(input.value) || 1) : 1;
      startRecruitment(type, amount);
    }

    function startRecruitment(type, amount) {
      if (!activeVillage) return;
      if (!amount || amount <= 0) return;

      var vs = activeVillage.state;
      var res = calcRes(vs);
      var stats = getTroopStatsWithLevel(type, 1);
      var costTotal = {};
      Object.keys(stats.cost).forEach(k => costTotal[k] = stats.cost[k] * amount);

      if (!canAfford(costTotal, res)) { showNotif('No tienes recursos suficientes.', 'err'); return; }

      var barrCap = getBarracksCapacity(vs.buildings);
      var usedSlots = getBarracksUsed(vs);
      var slotsFreed = amount * 1;
      var slotsNeeded = amount * (stats.barracasSlots || 1);
      if (usedSlots - slotsFreed + slotsNeeded > barrCap) {
        showNotif('No hay espacio suficiente en las barracas.', 'err'); return;
      }

      var resNow = calcRes(vs);
      var aldLibres = resNow.aldeanos_libres || 0;
      if (aldLibres < amount) {
        showNotif('Necesitas ' + amount + ' aldeanos LIBRES. Tienes ' + aldLibres + '.', 'err'); return;
      }

      snapshotResources(vs);

      // Descontar recursos y aldeanos INMEDIATAMENTE
      Object.keys(costTotal).forEach(k => {
        if (k === 'prov') vs.resources.provisiones = Math.max(0, vs.resources.provisiones - costTotal[k]);
        else if (vs.resources[k] !== undefined) vs.resources[k] = Math.max(0, vs.resources[k] - costTotal[k]);
      });
      if (!vs.troops) vs.troops = {};
      consumeAldeanos(vs, amount); // resta proporcional de recolectores si hace falta

      // Encolar entrenamiento (secuencial, como criaturas)
      if (!vs.training_queue) vs.training_queue = [];
      var cuartRed = getCuartelesReduction(vs.buildings);
      var baseTime = stats.time || 180;
      var finalTime = Math.max(30, Math.floor(baseTime * (1 - cuartRed)));

      for (var i = 0; i < amount; i++) {
        var lastFinish = Date.now();
        if (vs.training_queue.length > 0) {
          lastFinish = Math.max(lastFinish, new Date(vs.training_queue[vs.training_queue.length - 1].finish_at).getTime());
        }
        vs.training_queue.push({
          type: type,
          finish_at: new Date(lastFinish + finalTime * 1000).toISOString(),
          start_at: new Date(lastFinish).toISOString()
        });
      }

      showNotif(amount + ' ' + stats.name + ' en cola de entrenamiento', 'ok');
      flushVillage();
      tick();
      renderTroops();
    }

    function showTroopStats(key) {
      var t = TROOP_TYPES[key];
      if (!t) return;
      var existing = document.getElementById('troopStatsModal');
      if (existing) existing.remove();
      window._closeTroopStats = function () { var m = document.getElementById('troopStatsModal'); if (m) m.remove(); };
      var overlay = document.createElement('div');
      overlay.id = 'troopStatsModal';
      overlay.style.cssText = 'position:fixed;inset:0;z-index:9999;background:rgba(0,0,0,.75);display:flex;align-items:center;justify-content:center;';
      overlay.onclick = function (e) { if (e.target === overlay) overlay.remove(); };
      overlay.innerHTML = '<div style="background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:20px;max-width:340px;width:90%;font-family:VT323,monospace;">'
        + '<div style="display:flex;align-items:center;gap:10px;margin-bottom:14px;border-bottom:1px solid var(--border);padding-bottom:10px;">'
        + '<span style="font-size:2.5rem;">' + t.icon + '</span>'
        + '<div><div style="font-size:1.2rem;color:var(--accent);">' + t.name + '</div>'
        + '<div style="font-size:.7rem;color:var(--dim);">Tropa normal Â· 1 plaza barracas</div></div>'
        + '<button onclick="_closeTroopStats()" style="margin-left:auto;background:none;border:none;color:var(--dim);font-size:1.2rem;cursor:pointer;">âœ•</button>'
        + '</div>'
        + '<div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;font-size:.82rem;margin-bottom:14px;">'
        + '<div style="color:var(--dim);">â¤ï¸ HP</div><div style="color:var(--text);">' + t.hp + '</div>'
        + '<div style="color:var(--dim);">âš”ï¸ DaÃ±o</div><div style="color:var(--text);">' + t.damage + '</div>'
        + '<div style="color:var(--dim);">ğŸ›¡ï¸ Defensa</div><div style="color:var(--text);">' + t.defense + '</div>'
        + '<div style="color:var(--dim);">âš¡ Ataques/turno</div><div style="color:var(--text);">' + t.attacksPerTurn + '</div>'
        + '<div style="color:var(--dim);">ğŸ¯ % Acierto</div><div style="color:var(--text);">' + t.attackChance + '/20</div>'
        + '<div style="color:var(--dim);">ğŸƒ Velocidad</div><div style="color:var(--text);">' + t.speed + '</div>'
        + '<div style="color:var(--dim);">ğŸ—¡ï¸ Arma base</div><div style="color:var(--text);">' + t.weapon + '</div>'
        + '<div style="color:var(--dim);">ğŸ›¡ Armadura base</div><div style="color:var(--text);">' + t.armor + '</div>'
        + '<div style="color:var(--dim);">ğŸ“¦ Capacidad carga</div><div style="color:var(--text);">' + t.capacity + '</div>'
        + '</div>'
        + '<div style="font-size:.72rem;color:var(--dim);border-top:1px solid var(--border);padding-top:10px;margin-bottom:14px;">' + escapeHtml(t.desc) + '</div>'
        + '<div style="font-size:.75rem;background:var(--panel2);border-radius:6px;padding:8px;display:grid;grid-template-columns:1fr 1fr 1fr;gap:4px;text-align:center;">'
        + '<div><div style="color:var(--dim);">1 Aldeano</div><div style="color:var(--aldeanos);">ğŸ‘¤ Ã—1</div></div>'
        + '<div><div style="color:var(--dim);">Tiempo</div><div style="color:var(--gold);">â± ' + Math.floor((t.time || 180) / 60) + 'min</div></div>'
        + '<div><div style="color:var(--dim);">Plazas</div><div style="color:var(--accent);">ğŸ  ' + (t.barracasSlots || 1) + '</div></div>'
        + '</div>'
        + '</div>';
      document.body.appendChild(overlay);
    }

    function renderTrainOptions() {
      var box = document.getElementById('trainOptionsBox');
      if (!box || !activeVillage) return;
      var vs = activeVillage.state;
      var troops = vs.troops || {};
      var res = calcRes(vs);
      var cuartLvl = (vs.buildings.cuarteles && vs.buildings.cuarteles.level) || 0;
      var cuartRed = getCuartelesReduction(vs.buildings);
      var aldLibres = res.aldeanos_libres || 0;
      var aldTotal = res.aldeanos_total || 0;
      var barrCap = getBarracksCapacity(vs.buildings);
      var usedSlots = getBarracksUsed(vs);
      var barrLvl = (vs.buildings.barracas && vs.buildings.barracas.level) || 0;

      var html = '';

      // Cabecera plazas + cuarteles
      html += '<div style="display:flex;justify-content:space-between;align-items:center;padding:4px 0 10px;border-bottom:1px solid var(--border);margin-bottom:10px;">';
      html += '<span style="font-size:.78rem;color:var(--dim);letter-spacing:.08em;">PLAZAS OCUPADAS</span>';
      html += '<span style="font-size:1rem;color:var(--accent);font-family:VT323,monospace;"><b>' + usedSlots + '</b> / ' + barrCap + '</span>';
      html += '</div>';
      if (cuartLvl > 0) {
        html += '<div style="font-size:.72rem;color:var(--ok);margin-bottom:10px;">ğŸ–ï¸ Cuarteles Niv.' + cuartLvl + ' â†’ -' + Math.round(cuartRed * 100) + '% entrenamiento</div>';
      }

      html += '<div style="display:grid;gap:7px;">';

      // â”€â”€ Aldeano: tropa base, sin botÃ³n entrenar â”€â”€
      var ald = TROOP_TYPES['aldeano'];
      html += '<div style="display:flex;align-items:center;gap:12px;padding:11px 14px;background:var(--panel2);border-radius:7px;border:1px solid rgba(255,221,96,.18);">';
      html += '<button onclick="showTroopStats(\'aldeano\')" title="Ver estadÃ­sticas" style="background:none;border:none;cursor:pointer;font-size:2.2rem;padding:0;line-height:1;flex-shrink:0;">' + ald.icon + '</button>';
      html += '<div style="flex:1;min-width:0;">';
      html += '<div style="font-size:1.1rem;color:var(--aldeanos);font-family:VT323,monospace;">' + ald.name + '</div>';
      html += '<div style="font-size:.72rem;color:var(--dim);margin-top:2px;">Tropa base Â· Se generan automÃ¡ticamente Â· <span style="color:var(--aldeanos);">' + aldLibres + ' libres</span></div>';
      html += '</div>';
      html += '<div style="font-size:1.8rem;color:var(--aldeanos);font-family:VT323,monospace;font-weight:bold;flex-shrink:0;">' + aldTotal + '</div>';
      html += '</div>';

      if (barrLvl === 0) {
        html += '<div style="color:var(--danger);font-size:.85rem;padding:8px 0;">âš ï¸ Construye las Barracas para entrenar tropas militares</div>';
        html += '</div>';
        box.innerHTML = html;
        return;
      }

      // â”€â”€ Tropas militares â”€â”€
      Object.keys(TROOP_TYPES).forEach(function (key) {
        if (key === 'aldeano') return;
        var t = TROOP_TYPES[key];
        var count = troops[key] || 0;
        var baseTime = t.time || 180;
        var finalTime = Math.max(30, Math.floor(baseTime * (1 - cuartRed)));
        var mins = Math.floor(finalTime / 60);
        var secs = finalTime % 60;
        var timeStr = mins + 'min' + (secs ? ' ' + secs + 's' : '');
        var costPerUnit = t.cost || {};
        var canAffordOne = canAfford(costPerUnit, res);
        var hasAldeano = aldLibres >= 1;
        var canTrain = canAffordOne && hasAldeano;
        var costStr = '';
        if (costPerUnit.hierro) costStr += 'âš™ï¸' + costPerUnit.hierro + ' ';
        if (costPerUnit.madera) costStr += 'ğŸŒ²' + costPerUnit.madera + ' ';
        if (costPerUnit.piedra) costStr += 'â›°ï¸' + costPerUnit.piedra + ' ';
        if (costPerUnit.esencia) costStr += 'âœ¨' + costPerUnit.esencia + ' ';
        if (costPerUnit.prov) costStr += 'ğŸŒ¾' + costPerUnit.prov + ' ';

        html += '<div style="display:flex;align-items:center;gap:12px;padding:11px 14px;background:var(--panel2);border-radius:7px;border:1px solid ' + (canTrain ? 'rgba(255,255,255,.07)' : 'rgba(255,255,255,.02)') + ';' + (!canTrain ? 'opacity:.6;' : '') + '">';
        // Icono clickable para stats
        html += '<button onclick="showTroopStats(\'' + key + '\')" title="Ver estadÃ­sticas" style="background:none;border:none;cursor:pointer;font-size:2.2rem;padding:0;line-height:1;flex-shrink:0;">' + t.icon + '</button>';
        // Info centro
        html += '<div style="flex:1;min-width:0;">';
        html += '<div style="font-size:1.1rem;color:var(--text);font-family:VT323,monospace;">' + t.name + '</div>';
        html += '<div style="font-size:.72rem;color:var(--dim);margin-top:2px;">ğŸ‘¤Ã—1 Â· ' + (costStr.trim() || 'â€”') + ' Â· â± ' + timeStr + '</div>';
        if (!hasAldeano) html += '<div style="font-size:.68rem;color:var(--danger);margin-top:2px;">Sin aldeanos libres</div>';
        else if (!canAffordOne) html += '<div style="font-size:.68rem;color:var(--danger);margin-top:2px;">Sin recursos suficientes</div>';
        html += '</div>';
        // Cantidad en base
        html += '<div style="text-align:right;flex-shrink:0;margin-right:10px;min-width:36px;">';
        html += '<div style="font-size:1.8rem;color:' + (count > 0 ? 'var(--accent)' : 'var(--dim)') + ';font-family:VT323,monospace;line-height:1;">' + count + '</div>';
        html += '<div style="font-size:.6rem;color:var(--dim);">en base</div>';
        html += '</div>';
        // Input + botÃ³n
        html += '<div style="display:flex;align-items:center;gap:5px;flex-shrink:0;">';
        html += '<input id="trainQty_' + key + '" type="number" value="1" min="1" max="99" style="width:48px;background:rgba(255,255,255,.06);border:1px solid var(--border);border-radius:5px;padding:5px 6px;color:var(--text);font-family:VT323,monospace;font-size:1rem;text-align:center;">';
        html += '<button onclick="startRecruitmentFromInput(\'' + key + '\')" ' + (!canTrain ? 'disabled' : '') + ' style="background:' + (canTrain ? 'var(--accent)' : 'var(--border)') + ';border:none;color:' + (canTrain ? 'var(--bg)' : 'var(--dim)') + ';padding:6px 13px;border-radius:5px;cursor:' + (canTrain ? 'pointer' : 'default') + ';font-family:VT323,monospace;font-size:1rem;white-space:nowrap;font-weight:bold;">+ Cola</button>';
        html += '</div>';
        html += '</div>';
      });

      html += '</div>';
      box.innerHTML = html;
    }

    function resolveTrainingQueue(vs) {
      if (!vs.training_queue || vs.training_queue.length === 0) return vs;
      var now = Date.now();
      var remaining = [];
      var changed = false;
      for (var t of vs.training_queue) {
        var finishTime = new Date(t.finish_at).getTime();
        if (finishTime <= now) {
          // Tropa lista â€” aÃ±adir (el slot ya estaba reservado en getBarracksUsed,
          // asÃ­ que simplemente convertimos el slot de "entrenando" a "en base")
          if (!vs.troops) vs.troops = {};
          vs.troops[t.type] = (vs.troops[t.type] || 0) + 1;
          changed = true;
        } else {
          remaining.push(t);
        }
      }
      vs.training_queue = remaining;
      return vs;
    }

    function renderTrainingQueue() {
      var box = document.getElementById('trainingQueueBox');
      if (!box || !activeVillage) return;
      var vs = activeVillage.state;
      var queue = vs.training_queue || [];
      if (queue.length === 0) {
        box.innerHTML = '<div style="color:var(--dim);font-size:.8rem;">No hay tropas en entrenamiento</div>';
        return;
      }
      var now = Date.now();
      var html = '';

      // Tiempo total de TODA la cola â€” siempre del Ãºltimo elemento
      var lastFinish = new Date(queue[queue.length - 1].finish_at);
      var lastStr = lastFinish.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
      var totalSecsLeft = Math.max(0, Math.ceil((lastFinish.getTime() - now) / 1000));

      // First active
      var active = queue[0];
      var tStats = TROOP_TYPES[active.type];
      if (tStats) {
        var finish = new Date(active.finish_at).getTime();
        var timeLeft = Math.max(0, Math.ceil((finish - now) / 1000));
        var start = new Date(active.start_at).getTime();
        var total = Math.max(1, (finish - start) / 1000);
        var pct = Math.min(100, Math.round(((total - timeLeft) / total) * 100));
        html += '<div style="background:var(--panel2);padding:8px 10px;border-radius:6px;margin-bottom:8px;">';
        html += '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:5px;">';
        html += '<span style="font-size:.9rem;">' + tStats.icon + ' ' + tStats.name + '</span>';
        html += '<span style="font-size:.75rem;color:var(--ok);">' + fmtTime(timeLeft) + '</span>';
        html += '</div>';
        html += '<div style="background:var(--bg);height:7px;border-radius:4px;overflow:hidden;">';
        html += '<div style="width:' + pct + '%;height:100%;background:var(--accent);transition:width 1s linear;"></div>';
        html += '</div>';
        // Total queue time â€” siempre visible, no solo si hay >1
        html += '<div style="font-size:.63rem;color:var(--dim);margin-top:4px;">Cola completa (' + queue.length + ' tropas): <span style="color:var(--accent);">' + fmtTime(totalSecsLeft) + '</span> Â· termina <b>' + lastStr + '</b></div>';
        html += '</div>';
      }
      // Waiting
      if (queue.length > 1) {
        var waiting = queue.slice(1);
        var counts = {};
        waiting.forEach(function (t) { counts[t.type] = (counts[t.type] || 0) + 1; });
        html += '<div style="background:var(--panel2);padding:7px 10px;border-radius:6px;">';
        html += '<div style="font-size:.68rem;color:var(--dim);margin-bottom:5px;letter-spacing:.08em;">EN ESPERA</div>';
        html += '<div style="display:flex;flex-wrap:wrap;gap:6px;">';
        Object.keys(counts).forEach(function (key) {
          var ts = TROOP_TYPES[key];
          if (!ts) return;
          html += '<div style="display:flex;align-items:center;gap:4px;background:var(--bg);padding:3px 8px;border-radius:4px;font-size:.78rem;">';
          html += ts.icon + ' ' + ts.name + ' <span style="color:var(--accent);font-weight:bold;margin-left:2px;">Ã—' + counts[key] + '</span>';
          html += '</div>';
        });
        html += '</div></div>';
      }
      box.innerHTML = html;
    }

    // ============================================================
    // COMBAT SIMULATOR LOGIC (Ported from v0.11)
    // ============================================================
    function divideIntoGroups(total) {
      if (total <= 0) return [];
      let groups = [];
      let remaining = total;
      let power = Math.floor(Math.log10(total));
      while (remaining > 0) {
        let size = Math.pow(10, power);
        if (remaining >= size) {
          groups.push(size);
          remaining -= size;
        } else {
          power--;
          if (power < 0) {
            if (remaining > 0) groups.push(remaining);
            break;
          }
        }
      }
      return groups;
    }

    function createArmy(armyId, troops) {
      let army = [];
      Object.keys(troops).forEach(type => {
        let entry = troops[type];
        // Soporte para caballeros NPC: { count, stats } en vez de nÃºmero simple
        let count, stats;
        if (entry && typeof entry === 'object' && entry.stats) {
          count = entry.count || 1;
          stats = entry.stats;
        } else {
          count = entry;
          stats = TROOP_TYPES[type];
        }
        if (!count || count <= 0) return;
        if (!stats) return;
        let groupSizes = divideIntoGroups(count);
        groupSizes.forEach((size, idx) => {
          army.push({
            armyId,
            groupId: army.length + 1,
            type,
            stats: JSON.parse(JSON.stringify(stats)),
            count: size,
            totalHP: size * stats.hp
          });
        });
      });
      return army;
    }

    // ============================================================
    // TROOP RECOVERY & LOOT SYSTEM
    // ============================================================

    function calculateRecovery(casualties) {
      // RecuperaciÃ³n aleatoria 10-30% de las bajas
      var recovered = {};
      Object.keys(casualties).forEach(function (type) {
        var dead = casualties[type] || 0;
        if (dead > 0) {
          var recoveryRate = 0.1 + Math.random() * 0.2; // 10-30%
          recovered[type] = Math.floor(dead * recoveryRate);
        }
      });
      return recovered;
    }

    function calculateLootCapacity(troops) {
      // Capacidad total = suma de capacidades individuales
      // Criaturas tienen capacity=0, asÃ­ que no pueden saquear
      var total = 0;
      Object.keys(troops).forEach(function (type) {
        var count = troops[type] || 0;
        var troopData = TROOP_TYPES[type] || CREATURE_TYPES[type];
        if (troopData && count > 0) {
          total += count * (troopData.capacity || 0);
        }
      });
      return total;
    }

    function calculateLoot(defenderResources, capacity) {
      var available = {
        madera: defenderResources.madera || 0,
        piedra: defenderResources.piedra || 0,
        hierro: defenderResources.hierro || 0,
        provisiones: defenderResources.provisiones || 0,
        esencia: defenderResources.esencia || 0
      };

      var totalAvailable = available.madera + available.piedra + available.hierro +
        available.provisiones + available.esencia;

      if (totalAvailable === 0 || capacity === 0) {
        return { madera: 0, piedra: 0, hierro: 0, provisiones: 0, esencia: 0 };
      }

      // Saquear proporcionalmente hasta llenar capacidad
      var ratio = Math.min(1, capacity / totalAvailable);

      return {
        madera: Math.floor(available.madera * ratio),
        piedra: Math.floor(available.piedra * ratio),
        hierro: Math.floor(available.hierro * ratio),
        provisiones: Math.floor(available.provisiones * ratio),
        esencia: Math.floor(available.esencia * ratio)
      };
    }

    function generateBattleReport(attackerName, defenderName, attackerTroops, defenderTroops,
      result, loot, attackerXP, defenderXP, isNPC) {
      var winner = result.winner === 1 ? 'atacante' : result.winner === 2 ? 'defensor' : 'empate';

      var attackerInitial = {};
      var attackerFinal = result.survivors1 || {};
      var attackerCasualties = {};
      var attackerRecovered = {};

      Object.keys(attackerTroops).forEach(function (type) {
        var initial = attackerTroops[type] || 0;
        var final = attackerFinal[type] || 0;
        if (initial > 0) {
          attackerInitial[type] = initial;
          attackerCasualties[type] = initial - final;
        }
      });
      attackerRecovered = calculateRecovery(attackerCasualties);

      var defenderInitial = {};
      var defenderFinal = result.survivors2 || {};
      var defenderCasualties = {};
      var defenderRecovered = {};

      Object.keys(defenderTroops).forEach(function (type) {
        var initial = defenderTroops[type] || 0;
        var final = defenderFinal[type] || 0;
        if (initial > 0) {
          defenderInitial[type] = initial;
          defenderCasualties[type] = initial - final;
        }
      });
      defenderRecovered = calculateRecovery(defenderCasualties);

      // Generar HTML del informe
      var html = '<div style="background:var(--panel);border:1px solid var(--border);border-radius:8px;padding:16px;max-width:700px;margin:0 auto;">';

      // ATACANTES
      html += '<div style="margin-bottom:20px;"><div style="font-size:1.1rem;font-weight:bold;color:var(--danger);margin-bottom:12px;border-bottom:2px solid var(--danger);padding-bottom:6px;">âš”ï¸ ATACANTES</div>';
      html += '<div style="color:var(--text);font-size:.85rem;margin-bottom:8px;"><b>' + attackerName + '</b></div>';
      html += generateTroopTable(attackerInitial, attackerFinal, attackerRecovered, false);
      html += '<div style="margin-top:8px;color:var(--accent);font-size:.8rem;">ğŸ“Š Experiencia ganada: ' + fmt(attackerXP) + '</div>';
      html += '</div>';

      // DEFENSORES
      html += '<div style="margin-bottom:20px;"><div style="font-size:1.1rem;font-weight:bold;color:var(--ok);margin-bottom:12px;border-bottom:2px solid var(--ok);padding-bottom:6px;">ğŸ›¡ï¸ DEFENSORES</div>';
      html += '<div style="color:var(--text);font-size:.85rem;margin-bottom:8px;"><b>' + defenderName + '</b></div>';
      html += generateTroopTable(defenderInitial, defenderFinal, defenderRecovered, isNPC);
      html += '<div style="margin-top:8px;color:var(--accent);font-size:.8rem;">ğŸ“Š Experiencia ganada: ' + fmt(defenderXP) + '</div>';
      html += '</div>';

      // RESULTADO
      html += '<div style="background:var(--panel2);border-radius:6px;padding:12px;margin-bottom:16px;text-align:center;">';
      html += '<div style="font-size:1.2rem;font-weight:bold;color:' + (winner === 'atacante' ? 'var(--ok)' : winner === 'defensor' ? 'var(--danger)' : 'var(--dim)') + ';margin-bottom:8px;">';
      html += winner === 'atacante' ? 'ğŸ† Ha ganado el bando atacante' : winner === 'defensor' ? 'ğŸ’€ Ha ganado el bando defensor' : 'âš–ï¸ Empate';
      html += '</div>';
      html += '<div style="font-size:.75rem;color:var(--dim);">Rondas de combate: ' + result.rounds + '</div>';
      html += '</div>';

      // BOTÃN (solo si ganÃ³ atacante)
      if (winner === 'atacante' && loot) {
        var totalLoot = (loot.madera || 0) + (loot.piedra || 0) + (loot.hierro || 0) +
          (loot.provisiones || 0) + (loot.esencia || 0);
        if (totalLoot > 0) {
          html += '<div style="background:var(--panel2);border-radius:6px;padding:12px;margin-bottom:16px;">';
          html += '<div style="font-size:.9rem;font-weight:bold;color:var(--accent);margin-bottom:8px;">ğŸ’° Materias robadas:</div>';
          html += '<div style="display:flex;gap:16px;justify-content:center;flex-wrap:wrap;font-size:.85rem;">';
          if (loot.madera > 0) html += '<div>ğŸŒ² <b style="color:var(--madera);">' + fmt(loot.madera) + '</b></div>';
          if (loot.piedra > 0) html += '<div>â›°ï¸ <b style="color:var(--piedra);">' + fmt(loot.piedra) + '</b></div>';
          if (loot.hierro > 0) html += '<div>âš™ï¸ <b style="color:var(--hierro);">' + fmt(loot.hierro) + '</b></div>';
          if (loot.provisiones > 0) html += '<div>ğŸŒ¾ <b style="color:var(--prov);">' + fmt(loot.provisiones) + '</b></div>';
          if (loot.esencia > 0) html += '<div>âœ¨ <b style="color:var(--esencia);">' + fmt(loot.esencia) + '</b></div>';
          html += '</div></div>';
        }
      }

      // LOG DESPLEGABLE
      if (result.log && result.log.length > 0) {
        html += '<div style="margin-top:16px;"><button onclick="toggleBattleLog(this)" style="width:100%;background:var(--panel2);border:1px solid var(--border);color:var(--text);padding:8px;border-radius:4px;cursor:pointer;font-size:.8rem;">Ver detalles de combate â–¼</button>';
        html += '<div style="display:none;margin-top:8px;background:var(--bg);border:1px solid var(--border);border-radius:4px;padding:12px;max-height:300px;overflow-y:auto;font-size:.7rem;font-family:monospace;color:var(--dim);">';
        result.log.forEach(function (line) {
          html += line + '<br>';
        });
        html += '</div></div>';
      }

      html += '</div>';

      return html;
    }

    function generateTroopTable(initial, final, recovered, isNPC) {
      var types = Object.keys(initial).filter(function (t) { return initial[t] > 0; });
      if (types.length === 0) return '<div style="color:var(--dim);font-size:.8rem;">Sin tropas</div>';

      var html = '<table style="width:100%;border-collapse:collapse;font-size:.8rem;color:var(--text);">';
      html += '<thead><tr style="border-bottom:1px solid var(--border);">';
      html += '<th style="text-align:left;padding:6px;color:var(--dim);font-size:.75rem;"></th>';

      types.forEach(function (type) {
        var troopData = TROOP_TYPES[type] || CREATURE_TYPES[type];
        var name = troopData ? troopData.name : type;
        var icon = troopData ? troopData.icon : 'â“';
        if (type === '_knight') {
          name = 'Caballero';
          icon = 'ğŸ‘‘';
        }
        html += '<th style="text-align:center;padding:6px;color:var(--text);">' + icon + ' ' + name + '</th>';
      });
      html += '</tr></thead><tbody>';

      // Fila: Iniciales
      html += '<tr><td style="padding:6px;color:var(--dim);">Iniciales</td>';
      types.forEach(function (type) {
        html += '<td style="text-align:center;padding:6px;">' + (initial[type] || 0) + '</td>';
      });
      html += '</tr>';

      // Fila: Finales
      html += '<tr><td style="padding:6px;color:var(--dim);">Finales</td>';
      types.forEach(function (type) {
        html += '<td style="text-align:center;padding:6px;">' + (final[type] || 0) + '</td>';
      });
      html += '</tr>';

      // Fila: Recuperadas (solo si no es NPC knight)
      if (!isNPC) {
        html += '<tr style="border-top:1px solid var(--border);"><td style="padding:6px;color:var(--ok);">Recuperadas</td>';
        types.forEach(function (type) {
          var rec = recovered[type] || 0;
          html += '<td style="text-align:center;padding:6px;color:var(--ok);">' + rec + '</td>';
        });
        html += '</tr>';
      }

      html += '</tbody></table>';
      return html;
    }

    function toggleBattleLog(btn) {
      var logDiv = btn.nextElementSibling;
      if (logDiv.style.display === 'none') {
        logDiv.style.display = 'block';
        btn.textContent = 'Ocultar detalles â–²';
      } else {
        logDiv.style.display = 'none';
        btn.textContent = 'Ver detalles de combate â–¼';
      }
    }

    // v1.37: executeTurn â€” referencias directas (sin spread), muralla tÃ¡ctica
    // army1=atacantes, army2=defensores, wallObj={hp} (opcional)
    // Atacantes: si muralla aguanta â†’ golpean muralla (ese ataque se consume).
    //            Si muralla cae a mitad de turno â†’ ataques siguientes van a tropas.
    // Defensores: siempre atacan tropas enemigas (no esperan a que caiga la muralla).
    function executeTurn(army1, army2, log, wallObj) {
      // Referencias DIRECTAS â€” sin { ...g } para que los cambios de count sean visibles
      const all = [];
      army1.forEach(g => { if (g.count > 0) all.push({ group: g, isAtk: true  }); });
      army2.forEach(g => { if (g.count > 0) all.push({ group: g, isAtk: false }); });

      all.sort((a, b) => {
        if (b.group.stats.dexterity !== a.group.stats.dexterity) return b.group.stats.dexterity - a.group.stats.dexterity;
        if (a.group.count !== b.group.count) return a.group.count - b.group.count;
        return Math.random() - 0.5;
      });

      all.forEach(item => {
        const group = item.group;
        // Si count===0 el grupo fue eliminado este mismo turno: no actua
        if (group.count <= 0) return;

        const enemies = item.isAtk ? army2 : army1;

        for (let i = 0; i < (group.stats.attacksPerTurn || 1); i++) {
          if (group.count <= 0) break;

          // ATACANTE con muralla en pie: golpea la muralla (consume el ataque)
          if (item.isAtk && wallObj && wallObj.hp > 0) {
            const dmg = group.count * (group.stats.damage || 0);
            wallObj.hp = Math.max(0, wallObj.hp - dmg);
            if (log) log.push(group.stats.icon + ' G' + group.groupId + ' golpea la muralla: ' + dmg + ' danio -> ' + wallObj.hp + ' HP');
            if (wallObj.hp <= 0 && log) log.push('ğŸ’¥ Â¡Muralla destruida! Atacantes mas lentos avanzaran sobre las tropas.');
            continue; // si cayo, el siguiente ataque (i++) va a tropas
          }

          // DEFENSOR o ATACANTE con muralla ya caida: atacar tropas
          const aliveEnemies = enemies.filter(e => e.count > 0);
          if (aliveEnemies.length === 0) break;

          const target = aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)];
          const attackRoll = (group.stats.attackChance || 10) + Math.floor(Math.random() * 20) + 1;

          if (attackRoll > target.stats.defense) {
            const dmg = group.count * group.stats.damage;
            target.totalHP -= dmg;
            const newCount = Math.max(0, Math.floor(target.totalHP / target.stats.hp + 0.0001));
            const killed = target.count - newCount;
            target.count = newCount;

            if (log) log.push(group.stats.icon + ' G' + group.groupId + ' ataco a ' + target.stats.icon + ' G' + target.groupId + ': ' + dmg + ' danio, ' + killed + ' bajas.');

            if (target.count <= 0) {
              const idx = enemies.indexOf(target);
              if (idx !== -1) enemies.splice(idx, 1);
              if (log) log.push('ğŸ’€ ' + target.stats.icon + ' G' + target.groupId + ' eliminado.');
            }
          } else {
            if (log) log.push(group.stats.icon + ' G' + group.groupId + ' fallo vs ' + target.stats.icon + ' G' + target.groupId + ': ' + Math.floor(attackRoll) + ' vs DEF ' + Math.floor(target.stats.defense) + '.');
          }
        }
      });
    }
    function simulateBattle(army1Troops, army2Troops, defenderWallLevel) {
      let army1 = createArmy(1, army1Troops);
      let army2 = createArmy(2, army2Troops);
      let log = [];
      let turn = 1;

      // MURALLA: objeto compartido con executeTurn para logica tactica v1.37
      var wallObj = { hp: (defenderWallLevel && defenderWallLevel > 0) ? defenderWallLevel * 500 : 0 };
      if (wallObj.hp > 0) {
        log.push('ğŸ° Muralla nivel ' + defenderWallLevel + ': ' + wallObj.hp + ' HP. Los atacantes la golpean primero; los defensores contraatacan desde el turno 1.');
      }

      while (army1.length > 0 && army2.length > 0 && turn <= 100) {
        log.push('--- Ronda ' + turn + ' ---');
        executeTurn(army1, army2, log, wallObj);
        turn++;
      }

      var wallResisted = wallObj.hp > 0;
      let winner = wallResisted ? 2 : (army1.length > 0) ? 1 : (army2.length > 0) ? 2 : 0;

      let survivors1 = {};
      army1.forEach(g => survivors1[g.type] = (survivors1[g.type] || 0) + g.count);
      let survivors2 = {};
      army2.forEach(g => survivors2[g.type] = (survivors2[g.type] || 0) + g.count);

      return { winner, wallResisted, log, survivors1, survivors2, rounds: turn - 1 };
    }

    // SIMULADOR PvP â€” mÃºltiples contingentes por bando
    // ============================================================
    function simulateBattlePvP(attackerContingents, defenderContingents, wallLevel) {
      var wallObj = { hp: (wallLevel && wallLevel > 0) ? wallLevel * 500 : 0 };
      var log = [];
      if (wallObj.hp > 0) log.push('ğŸ° Muralla nivel ' + wallLevel + ': ' + wallObj.hp + ' HP. Los atacantes la golpean primero; defensores contraatacan desde el turno 1.');

      function buildArmyPvP(contingents, armyId) {
        var army = [];
        contingents.forEach(function (c) {
          Object.keys(c.troops || {}).forEach(function (troopKey) {
            var count = c.troops[troopKey] || 0;
            if (count <= 0) return;
            var stats = TROOP_TYPES[troopKey] || CREATURE_TYPES[troopKey];
            if (!stats) return;
            divideIntoGroups(count).forEach(function (size) {
              army.push({
                armyId: armyId, groupId: army.length + 1,
                owner_id: c.owner_id, troopType: troopKey,
                stats: JSON.parse(JSON.stringify(stats)),
                count: size, totalHP: size * stats.hp
              });
            });
          });
        });
        return army;
      }

      var army1 = buildArmyPvP(attackerContingents, 1);
      var army2 = buildArmyPvP(defenderContingents, 2);
      var turn = 1;

      while (army1.length > 0 && army2.length > 0 && turn <= 100) {
        log.push('--- Ronda ' + turn + ' ---');
        executeTurn(army1, army2, log, wallObj);
        turn++;
      }

      var wallResisted = wallObj.hp > 0;
      var winner = wallResisted ? 2 : (army1.length > 0 ? 1 : (army2.length > 0 ? 2 : 0));

      function collectResults(contingents, army) {
        return contingents.map(function (c) {
          var surv = {};
          army.forEach(function (g) {
            if (g.owner_id === c.owner_id && g.count > 0)
              surv[g.troopType] = (surv[g.troopType] || 0) + g.count;
          });
          var cas = {};
          Object.keys(c.troops || {}).forEach(function (k) {
            var lost = (c.troops[k] || 0) - (surv[k] || 0);
            if (lost > 0) cas[k] = lost;
          });
          var rec = wallResisted ? {} : calculateRecovery(cas);
          // XP: kills Ã— hp del tipo matado
          var xp = 0;
          // (se calcula externamente y se asigna despuÃ©s)
          return { owner_id: c.owner_id, name: c.name || c.owner_id.slice(0,8),
                   village_name: c.village_name || '', village_id: c.village_id || null,
                   initial: Object.assign({}, c.troops), survivors: surv,
                   casualties: cas, recovered: rec, xp: 0 };
        });
      }

      return {
        winner, wallResisted, wallDestroyed: !wallResisted && wallLevel > 0,
        log, rounds: turn - 1,
        attackerResults: collectResults(attackerContingents, army1),
        defenderResults: collectResults(defenderContingents, army2)
      };
    }

    // ============================================================
    // INFORME DE BATALLA PvP â€” formato Ikariam
    // ============================================================
    function generateBattlePvPReport(battleResult, wallLevel, loot, targetCoords) {
      var winner       = battleResult.winner;
      var wallResisted = battleResult.wallResisted;
      var atkR = battleResult.attackerResults || [];
      var defR = battleResult.defenderResults || [];
      var totalAtkXP = 0, totalDefXP = 0;
      atkR.forEach(function (r) { totalAtkXP += (r.xp || 0); });
      defR.forEach(function (r) { totalDefXP += (r.xp || 0); });

      function troopTable(result) {
        var types = Object.keys(result.initial).filter(function (k) { return (result.initial[k] || 0) > 0; });
        if (!types.length) return '<div style="color:var(--dim);font-size:.75rem;">Sin tropas</div>';
        var hdr = types.map(function (k) {
          var t = TROOP_TYPES[k] || CREATURE_TYPES[k];
          return '<th style="text-align:center;padding:4px 8px;border:1px solid var(--border);font-size:.68rem;color:var(--text);">'
            + (t ? t.icon + '<br>' + t.name : k) + '</th>';
        }).join('');
        function row(lbl, clr, vals) {
          return '<tr><td style="padding:4px 8px;border:1px solid var(--border);color:' + clr + ';font-size:.68rem;white-space:nowrap;">' + lbl + '</td>'
            + types.map(function (k) {
                var v = vals[k] || 0;
                var c = v === 0 ? 'var(--dim)' : clr;
                return '<td style="text-align:center;padding:4px 8px;border:1px solid var(--border);color:' + c + ';">' + v + '</td>';
              }).join('') + '</tr>';
        }
        return '<div style="overflow-x:auto;"><table style="border-collapse:collapse;font-size:.78rem;margin-bottom:4px;">'
          + '<thead><tr><th style="padding:4px 8px;border:1px solid var(--border);"></th>' + hdr + '</tr></thead><tbody>'
          + row('INICIALES',    'var(--text)',   result.initial)
          + row('FINALES',      'var(--accent2)',result.survivors)
          + row('SE RECUPERAN','var(--accent)',  result.recovered)
          + '</tbody></table></div>';
      }

      function pBlock(result, sideColor, chip) {
        return '<div style="background:var(--panel);border:1px solid var(--border);padding:12px 16px;margin-bottom:2px;">'
          + '<div style="font-family:VT323,monospace;font-size:1.05rem;color:#f0c040;margin-bottom:8px;">'
          + escapeHtml(result.name)
          + (result.village_name ? ' <span style="font-size:.62rem;color:var(--dim);background:var(--panel2);border:1px solid var(--border);padding:1px 5px;">' + escapeHtml(result.village_name) + '</span>' : '')
          + ' <span style="font-size:.6rem;padding:1px 6px;background:' + sideColor + '22;border:1px solid ' + sideColor + '55;color:' + sideColor + ';">' + chip + '</span>'
          + '</div>'
          + troopTable(result)
          + '<div style="font-size:.68rem;color:#f0c040;text-align:right;margin-top:4px;">â­ Experiencia: ' + fmt(result.xp || 0) + '</div>'
          + '</div>';
      }

      var html = '<div style="font-family:Share Tech Mono,monospace;max-width:700px;">';
      html += '<div style="background:var(--panel);border:1px solid var(--border);border-top:3px solid var(--accent);padding:14px 18px;margin-bottom:2px;">'
        + '<div style="font-family:VT323,monospace;font-size:1.5rem;color:var(--accent);letter-spacing:2px;">âš” INFORME DE BATALLA</div>'
        + '<div style="font-size:.68rem;color:var(--dim);margin-top:4px;">'
        + (targetCoords ? 'Objetivo: <span style="color:var(--text);">[' + targetCoords.x + ',' + targetCoords.y + ']</span> &nbsp;Â·&nbsp; ' : '')
        + (wallLevel > 0 ? 'Muralla nv.' + wallLevel + ' Â· <span style="color:' + (wallResisted ? 'var(--accent2)' : 'var(--danger)') + ';">' + (wallResisted ? 'resistiÃ³' : 'destruida') + '</span>' : 'Sin muralla')
        + '</div></div>';

      var bc = winner === 1 ? '#40c060' : '#e04040';
      var bt = winner === 1 ? 'ğŸ† HA GANADO EL BANDO ATACANTE' : 'ğŸ›¡ï¸ HA GANADO EL BANDO DEFENSOR';
      html += '<div style="text-align:center;padding:12px;font-family:VT323,monospace;font-size:1.6rem;letter-spacing:3px;border:1px solid ' + bc + ';color:' + bc + ';background:' + bc + '11;margin-bottom:2px;">' + bt + '</div>';

      html += '<div style="font-family:VT323,monospace;font-size:1.2rem;letter-spacing:2px;padding:8px 16px;border-left:3px solid #e87030;background:linear-gradient(90deg,rgba(232,112,48,.14),transparent);color:#e87030;margin-bottom:2px;">âš” ATACANTES</div>';
      atkR.forEach(function (r) { html += pBlock(r, '#e87030', 'ATACANTE'); });

      html += '<div style="font-family:VT323,monospace;font-size:1.2rem;letter-spacing:2px;padding:8px 16px;border-left:3px solid #4090e0;background:linear-gradient(90deg,rgba(64,144,224,.14),transparent);color:#4090e0;margin-bottom:2px;">ğŸ›¡ DEFENSORES</div>';
      defR.forEach(function (r) { html += pBlock(r, '#4090e0', 'DEFENSOR'); });

      html += '<div style="background:var(--panel);border:1px solid var(--border);border-top:2px solid #f0c040;padding:14px 18px;margin-top:2px;">';
      html += '<div style="font-family:VT323,monospace;color:#f0c040;font-size:1rem;letter-spacing:1px;margin-bottom:10px;">ğŸ“Š RESUMEN GLOBAL</div>';
      html += '<div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;margin-bottom:10px;">'
        + '<div style="background:var(--panel2);border:1px solid var(--border);padding:8px 12px;">'
        + '<div style="font-size:.62rem;color:var(--dim);">XP ATACANTES</div>'
        + '<div style="font-family:VT323,monospace;font-size:1.1rem;color:#40c060;">' + fmt(totalAtkXP) + '</div></div>'
        + '<div style="background:var(--panel2);border:1px solid var(--border);padding:8px 12px;">'
        + '<div style="font-size:.62rem;color:var(--dim);">XP DEFENSORES</div>'
        + '<div style="font-family:VT323,monospace;font-size:1.1rem;color:#e04040;">' + fmt(totalDefXP) + '</div></div></div>';

      if (loot && Object.keys(loot).some(function (k) { return (loot[k] || 0) > 0; })) {
        var icons = { madera:'ğŸªµ', piedra:'ğŸª¨', hierro:'âš™ï¸', oro:'ğŸ¥‡' };
        html += '<div style="font-family:VT323,monospace;color:#f0c040;font-size:.85rem;margin-bottom:6px;">ğŸ“¦ MATERIAS ROBADAS</div><div style="display:flex;gap:6px;flex-wrap:wrap;">';
        Object.keys(loot).forEach(function (k) {
          if (!(loot[k] > 0)) return;
          html += '<div style="background:var(--panel2);border:1px solid var(--border);padding:6px 12px;display:flex;align-items:center;gap:6px;">'
            + '<span>' + (icons[k] || 'ğŸ“¦') + '</span>'
            + '<div><div style="font-family:VT323,monospace;color:#f0c040;">' + fmt(loot[k]) + '</div>'
            + '<div style="font-size:.62rem;color:var(--dim);">' + k.toUpperCase() + '</div></div></div>';
        });
        html += '</div>';
      }

      if (battleResult.log && battleResult.log.length) {
        html += '<div style="margin-top:10px;"><button onclick="toggleBattleLog(this)" style="width:100%;background:var(--panel2);border:1px solid var(--border);color:var(--text);padding:6px;cursor:pointer;font-size:.72rem;">Ver traza â–¼</button>'
          + '<div style="display:none;margin-top:4px;background:var(--bg);border:1px solid var(--border);padding:8px;max-height:200px;overflow-y:auto;font-size:.62rem;font-family:monospace;color:var(--dim);">'
          + battleResult.log.map(function (l) { return escapeHtml(l); }).join('<br>') + '</div></div>';
      }
      html += '</div></div>';
      return html;
    }

    // Distancia Chebyshev entre aldea propia y casilla objetivo
    function isInTorreRange(tx, ty) {
      if (!activeVillage) return false;
      // Comprueba TODAS las aldeas del jugador, no solo la activa
      var villages = myVillages && myVillages.length > 0 ? myVillages : [activeVillage];
      for (var i = 0; i < villages.length; i++) {
        var v = villages[i];
        if (!v || !v.state) continue;
        var range = getTorreRange(v.state.buildings);
        if (range === 0) continue;
        var mx = v.x || 0, my = v.y || 0;
        if (Math.sqrt(Math.pow(tx - mx, 2) + Math.pow(ty - my, 2)) <= range) return true; // v1.21: distancia euclÃ­dea (cÃ­rculo real)
      }
      return false;
    }

    // ============================================================
    // WORKER ASSIGNMENT â€” aldeanos asignados por recurso
    // aldeanos_assigned = { madera:0, piedra:0, hierro:0, provisiones:0 }
    // Un aldeano solo puede estar asignado a UN recurso a la vez.
    // ============================================================

    function defaultTroops() {
      var tr = {};
      Object.keys(TROOP_TYPES).forEach(function (k) { tr[k] = (k === 'aldeano' ? 50 : 0); });
      return tr;
    }

    function defaultCreatures() {
      var cr = {};
      Object.keys(CREATURE_TYPES).forEach(function (k) { cr[k] = 0; });
      return cr;
    }

    // Consume N aldeanos de vs, restando primero de los libres y luego
    // proporcionalmente de los asignados si no hay suficientes libres.
    function consumeAldeanos(vs, amount) {
      if (!vs.troops) vs.troops = {};
      var total = vs.troops.aldeano || 0;
      if (amount > total) amount = total; // no puede sacar mÃ¡s de los que hay

      var assigned = vs.aldeanos_assigned || defaultAssignments();
      var totalAssigned = (assigned.madera || 0) + (assigned.piedra || 0) + (assigned.hierro || 0)
        + (assigned.provisiones || 0) + (assigned.esencia || 0);
      var libres = Math.max(0, total - totalAssigned);

      // Restar del total
      vs.troops.aldeano = Math.max(0, total - amount);

      // Si habÃ­a suficientes libres, los asignados no cambian
      if (amount <= libres) return;

      // Faltan (amount - libres) aldeanos: sacarlos de los asignados proporcionalmente
      var deficit = amount - libres;
      var keys = ['madera', 'piedra', 'hierro', 'provisiones', 'esencia'];
      if (totalAssigned > 0) {
        keys.forEach(function (k) {
          var prop = (assigned[k] || 0) / totalAssigned;
          var quitar = Math.round(deficit * prop);
          assigned[k] = Math.max(0, (assigned[k] || 0) - quitar);
        });
        // Ajuste por redondeo: aseguramos que la suma de quitas == deficit
        var newTotal = keys.reduce(function (s, k) { return s + (assigned[k] || 0); }, 0);
        var diff = (totalAssigned - deficit) - newTotal;
        for (var i = 0; i < keys.length && diff !== 0; i++) {
          if (assigned[keys[i]] > 0 && diff < 0) { assigned[keys[i]]--; diff++; }
          else if (diff > 0) { assigned[keys[i]]++; diff--; }
        }
      } else {
        // No hay asignados, nada que restar
      }
      vs.aldeanos_assigned = assigned;
    }

    function defaultAssignments() {
      // Ahora solo guardamos CUÃNTOS aldeanos estÃ¡n asignados a cada recurso
      // No son aldeanos separados, solo nÃºmeros de asignaciÃ³n
      return { madera: 0, piedra: 0, hierro: 0, provisiones: 0, esencia: 0 };
    }

    const MISSION_FACTOR = 60; // segundos por casilla de distancia (si vel=1)

    // ============================================================
    // TROOP & CREATURE LEVEL SYSTEM (placeholder)
    // TODO: Implementar sistema completo de XP y niveles
    // ============================================================
    function getTroopLevel(troopType) {
      // Para invocadores: nivel basado en cantidad entrenada (30 niveles)
      // El nivel del invocador desbloquea criaturas del tier correspondiente
      if (troopType === 'invocador') {
        var count = (activeVillage && activeVillage.state && activeVillage.state.troops && activeVillage.state.troops.invocador) || 0;
        var thresholds = [
               1,  // nivel 1  â† Orco / Hada
               8,  // nivel 2  â† GÃ³lem / Espectro
              20,  // nivel 3  â† Kobold / SÃ­lfide
              45,  // nivel 4  â† Troll / Banshee
              90,  // nivel 5  â† Grifo / Quimera
             150,  // nivel 6  â† Hidra / CÃ­clope
             230,  // nivel 7  â† Basilisco / Valquiria
             320,  // nivel 8  â† Minotauro / Salamandra
             410,  // nivel 9  â† Manticora / Ondina
             500,  // nivel 10 â† Centauro / Medusa
             850,  // nivel 11 â† Wyvern / Nereida
            1200,  // nivel 12 â† Gigante / HarpÃ­a
            1550,  // nivel 13 â† FÃ©nix / Cerbero
            1850,  // nivel 14 â† Behemot / Quetzal
            2150,  // nivel 15 â† LeviatÃ¡n / SerafÃ­n
            2450,  // nivel 16 â† TitÃ¡n / Lich
            2750,  // nivel 17 â† Pegaso / Naga
            3000,  // nivel 18 â† Yeti / SÃ¡tiro
            3250,  // nivel 19 â† Simurgh / Gorgona
            3500,  // nivel 20 â† Kraken / Ãngel CaÃ­do
            3750,  // nivel 21 â† Ammit / Roc
            3950,  // nivel 22 â† DragÃ³n / Arconte
            4150,  // nivel 23 â† Coloso / Sleipnir
            4350,  // nivel 24 â† Abismo / Nemea
            4500,  // nivel 25 â† TifÃ³n / Equidna
            4650,  // nivel 26 â† Tarasca / Garuda
            4800,  // nivel 27 â† JÃ¶rmungandr / Valquiria Oscura
            4900,  // nivel 28 â† Primordio / Azrael
            4950,  // nivel 29 â† Ignis Rex / Fenrir
            5000   // nivel 30 â† Moloch / MetatrÃ³n
        ];
        for (var i = thresholds.length - 1; i >= 0; i--) {
          if (count >= thresholds[i]) return i + 1;
        }
        return 0; // sin invocadores = no puede invocar nada
      }
      return 1;
    }

    function getCreatureLevel(creatureType) {
      // Nivel de criatura = nivel de Torre de InvocaciÃ³n
      var torreLevel = (activeVillage && activeVillage.state && activeVillage.state.buildings &&
        activeVillage.state.buildings.torreinvocacion &&
        activeVillage.state.buildings.torreinvocacion.level) || 0;
      return Math.max(1, torreLevel);
    }

    // ============================================================
    // SUMMONING QUEUE - Sistema de invocaciÃ³n de criaturas
    // ============================================================

    function canSummon(creatureType, vs) {
      var cData = CREATURE_TYPES[creatureType];
      if (!cData) return { ok: false, reason: 'Criatura no vÃ¡lida' };

      // Verificar Torre de InvocaciÃ³n
      var torreLevel = (vs.buildings.torreinvocacion && vs.buildings.torreinvocacion.level) || 0;
      if (torreLevel === 0) {
        return { ok: false, reason: 'Necesitas construir la Torre de InvocaciÃ³n' };
      }

      // Verificar nivel de invocadores necesario (tier)
      var invocadorLevel = getTroopLevel('invocador');
      if (invocadorLevel < cData.tier) {
        return { ok: false, reason: 'Invocadores nivel ' + cData.tier + ' requeridos (tienes nivel ' + invocadorLevel + ')' };
      }

      // Verificar invocadores presentes
      var invocadoresActuales = vs.troops.invocador || 0;
      if (invocadoresActuales < cData.summonersNeeded) {
        return { ok: false, reason: 'Necesitas ' + cData.summonersNeeded + ' invocadores (tienes ' + invocadoresActuales + ')' };
      }

      // Verificar esencia
      if ((vs.resources.esencia || 0) < cData.cost.esencia) {
        return { ok: false, reason: 'Esencia insuficiente' };
      }

      return { ok: true };
    }

    function startSummoningFromInput(creatureType) {
      var input = document.getElementById('summonQty_' + creatureType);
      var amount = input ? (parseInt(input.value) || 1) : 1;
      if (amount < 1) amount = 1;
      startSummoning(creatureType, amount);
    }

    function startSummoning(creatureType, amount) {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      var cData = CREATURE_TYPES[creatureType];
      if (!cData) return;

      // Verificar cada unidad
      for (var i = 0; i < amount; i++) {
        var check = canSummon(creatureType, vs);
        if (!check.ok) {
          showNotif(check.reason, 'err');
          break;
        }

        // Consumir esencia
        vs.resources.esencia -= cData.cost.esencia;

        // Calcular tiempo con reducciÃ³n por nivel de torre y nivel de criatura
        var torreLevel = (vs.buildings.torreinvocacion && vs.buildings.torreinvocacion.level) || 0;
        var creatureLevel = getCreatureLevel(creatureType);
        var baseTime = cData.time;
        var torreReduction = torreLevel * 0.05; // -5% por nivel de torre
        var creatureReduction = creatureLevel * 0.01; // -1% por nivel de criatura
        var totalReduction = Math.min(0.9, torreReduction + creatureReduction); // Max 90% reducciÃ³n
        var finalTime = Math.floor(baseTime * (1 - totalReduction));

        // AÃ±adir a cola â€” cada una empieza cuando termina la anterior (secuencial)
        if (!vs.summoning_queue) vs.summoning_queue = [];
        // Calcular cuÃ¡ndo termina la Ãºltima en cola para encadenar
        var lastFinish = Date.now();
        if (vs.summoning_queue.length > 0) {
          var lastEntry = vs.summoning_queue[vs.summoning_queue.length - 1];
          lastFinish = Math.max(lastFinish, new Date(lastEntry.finish_at).getTime());
        }
        vs.summoning_queue.push({
          creature: creatureType,
          finish_at: new Date(lastFinish + finalTime * 1000).toISOString(),
          start_at: new Date(lastFinish).toISOString(),
          summonersNeeded: cData.summonersNeeded,
          paused: false
        });
      }

      flushVillage();
      showNotif(amount + ' ' + cData.name + '(s) en cola de invocaciÃ³n', 'ok');
    }

    function resolveSummoningQueue(vs) {
      if (!vs.summoning_queue || vs.summoning_queue.length === 0) return vs;

      var now = Date.now();
      var remaining = [];
      var changed = false;
      var invocadoresActuales = vs.troops.invocador || 0;

      for (var s of vs.summoning_queue) {
        var cData = CREATURE_TYPES[s.creature];
        if (!cData) continue;

        // Verificar si hay suficientes invocadores
        if (invocadoresActuales < s.summonersNeeded) {
          // Pausar invocaciÃ³n
          if (!s.paused) {
            s.paused = true;
            s.pausedAt = new Date().toISOString();
            changed = true;
          }
          remaining.push(s);
          continue;
        }

        // Si estaba pausada, reanudar
        if (s.paused) {
          s.paused = false;
          var pausedTime = new Date(s.pausedAt).getTime();
          var timeLeft = new Date(s.finish_at).getTime() - pausedTime;
          s.finish_at = new Date(now + timeLeft).toISOString();
          delete s.pausedAt;
          changed = true;
        }

        var finishTime = new Date(s.finish_at).getTime();

        if (now >= finishTime && !s.paused) {
          // InvocaciÃ³n completada
          if (!vs.creatures) vs.creatures = defaultCreatures();
          vs.creatures[s.creature] = (vs.creatures[s.creature] || 0) + 1;
          showNotif('Â¡' + cData.name + ' invocado!', 'ok');
          changed = true;
        } else {
          remaining.push(s);
        }
      }

      if (changed) {
        vs.summoning_queue = remaining;
      }

      return vs;
    }

    function defaultState() {
      var b = {};
      BUILDINGS.forEach(function (d) { b[d.id] = { level: 1 }; });
      return {
        resources: { madera: 800, piedra: 600, hierro: 400, provisiones: 200, esencia: 50, aldeanos: 50 },
        aldeanos_granja: 0,
        aldeanos_assigned: defaultAssignments(),
        troops: defaultTroops(),
        creatures: defaultCreatures(),
        buildings: b,
        build_queue: null,
        mission_queue: [],
        summoning_queue: [],
        last_updated: new Date().toISOString()
      };
    }


    // ============================================================
    // PRODUCTION RATES
    // Base: edificio produce una cantidad pequeÃ±a automÃ¡ticamente
    // Bonus: cada aldeano asignado aÃ±ade producciÃ³n segÃºn nivel
    //
    // Bonus (Ã·10 respecto a valores anteriores para equilibrio):
    //   madera:      3 Ã— nivel_aserradero  por aldeano/h
    //   piedra:      2.5 Ã— nivel_cantera   por aldeano/h  (â†’ 2 redondeado)
    //   hierro:      2 Ã— nivel_mineHierro  por aldeano/h
    //   provisiones: (5+nivel_granja)Ã·10   por aldeano/h  â†’ ~0.6 base
    //   esencia:     1 Ã— nivel_circulo     por aldeano/h
    // ============================================================

    function getBaseProd(blds) {
      // Mismas fÃ³rmulas que BUILDINGS.prod(lvl) para consistencia con el modal
      var mLvl = (blds.aserradero && blds.aserradero.level) || 1;
      var pLvl = (blds.cantera && blds.cantera.level) || 1;
      var hLvl = (blds.minehierro && blds.minehierro.level) || 1;
      var cLvl = (blds.circulo && blds.circulo.level) || 1;
      return {
        madera: Math.floor(30 + 40 * mLvl * Math.pow(1.1, mLvl)),
        piedra: Math.floor(20 + 30 * pLvl * Math.pow(1.1, pLvl)),
        hierro: Math.floor(10 + 20 * hLvl * Math.pow(1.1, hLvl)),
        provisiones: 0,
        esencia: Math.floor(5 + 15 * cLvl * Math.pow(1.1, cLvl))
      };
    }

    function getBonusPerWorker(blds) {
      // Bonus ~10% de la producciÃ³n base por aldeano asignado
      var base = getBaseProd(blds);
      var gLvl = (blds.granja && blds.granja.level) || 1;
      return {
        madera: Math.max(1, Math.floor(base.madera * 0.1)),
        piedra: Math.max(1, Math.floor(base.piedra * 0.1)),
        hierro: Math.max(1, Math.floor(base.hierro * 0.1)),
        provisiones: Math.max(1, 5 + gLvl),   // provisiones: 6+ por aldeano/h
        esencia: Math.max(1, Math.floor(base.esencia * 0.1))
      };
    }

    function getProd(blds, aldGranja, workers) {
      var w = workers || defaultAssignments();
      if (!workers && aldGranja) w.provisiones = aldGranja;
      // Asegurar clave esencia
      if (w.esencia === undefined) w.esencia = 0;

      var base = getBaseProd(blds);
      var bonus = getBonusPerWorker(blds);

      return {
        madera: Math.floor(base.madera + (w.madera || 0) * bonus.madera),
        piedra: Math.floor(base.piedra + (w.piedra || 0) * bonus.piedra),
        hierro: Math.floor(base.hierro + (w.hierro || 0) * bonus.hierro),
        provisiones: Math.floor(base.provisiones + (w.provisiones || 0) * bonus.provisiones),
        esencia: Math.floor(base.esencia + (w.esencia || 0) * bonus.esencia),
        aldeanos: getAldeanosProd(blds)
      };
    }

    function calcRes(vs) {
      // Aplicar aldeanos discretos antes de calcular (actualiza vs.resources.aldeanos)
      calcAndApplyAldeanos(vs);

      var now = Date.now();
      var last = new Date(vs.last_updated).getTime();
      // Cap producciÃ³n offline a 24h para evitar abuso de tiempo
      var hrs = Math.max(0, Math.min((now - last) / 3600000, 24));
      var w = vs.aldeanos_assigned || defaultAssignments();
      if (w.esencia === undefined) w.esencia = 0;
      var p = getProd(vs.buildings, 0, w);
      var cap = getCapacity(vs.buildings);

      var madera = (vs.resources.madera || 0) + p.madera * hrs;
      var piedra = (vs.resources.piedra || 0) + p.piedra * hrs;
      var hierro = (vs.resources.hierro || 0) + p.hierro * hrs;
      var provisiones = (vs.resources.provisiones || 0) + p.provisiones * hrs;
      var esencia = (vs.resources.esencia || 0) + p.esencia * hrs;

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // NUEVO SISTEMA: 1 SOLO TIPO DE ALDEANO
      // troops.aldeano = TOTAL de aldeanos en la aldea
      // aldeanos_assigned = { madera: X, piedra: Y } = asignaciones (solo nÃºmeros)
      // aldeanos_libres = troops.aldeano - sum(assigned) - tropas_en_mision
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      var assigned = vs.aldeanos_assigned || defaultAssignments();
      if (assigned.esencia === undefined) assigned.esencia = 0;

      var totalAssigned = (assigned.madera || 0) + (assigned.piedra || 0) + (assigned.hierro || 0)
        + (assigned.provisiones || 0) + (assigned.esencia || 0);

      var barrCap = getBarracksCapacity(vs.buildings);

      // Aldeanos totales en la aldea (fuente de verdad)
      var aldTotal = (vs.troops && vs.troops.aldeano !== undefined) ? vs.troops.aldeano : 0;

      // Aldeanos libres = totales - asignados
      var aldLibres = Math.max(0, aldTotal - totalAssigned);

      // Cap almacÃ©n: cada recurso tiene su propio lÃ­mite independiente (no suma total)
      // Si el almacÃ©n es nivel 3 â†’ cap=8000, cada recurso puede llegar a 8000 por separado
      madera = Math.min(madera, cap);
      piedra = Math.min(piedra, cap);
      hierro = Math.min(hierro, cap);
      provisiones = Math.min(provisiones, cap);

      return {
        madera: Math.floor(madera),
        piedra: Math.floor(piedra),
        hierro: Math.floor(hierro),
        provisiones: Math.floor(provisiones),
        esencia: Math.floor(esencia),

        // compatibilidad: res.aldeanos = libres (UI vieja)
        aldeanos: aldLibres,

        // nuevo: para no romper total/libres nunca mÃ¡s
        aldeanos_libres: aldLibres,
        aldeanos_total: Math.floor(aldTotal),
        aldeanos_working: totalAssigned
      };
    }

    // Check if queued build is done (works offline: compares finish_at timestamp to now)
    // ============================================================
    // MISSIONS & TRAVEL
    // ============================================================
    async function cancelMission(missionRef) {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      // Buscar por mid (nuevo) con fallback a finish_at (misiones guardadas antes de v0.92)
      var idx = vs.mission_queue.findIndex(m => m.mid === missionRef || m.finish_at === missionRef);
      if (idx === -1) { showNotif('MisiÃ³n no encontrada', 'err'); return; }

      var m = vs.mission_queue[idx];
      if (m.type === 'return') { showNotif('No puedes cancelar el retorno', 'err'); return; }

      var now = Date.now();
      var start = new Date(m.start_at).getTime();
      var finish = new Date(m.finish_at).getTime();
      var progress = Math.max(0, Math.min(1, (now - start) / (finish - start)));

      var dx = Math.abs(m.tx - activeVillage.x);
      var dy = Math.abs(m.ty - activeVillage.y);
      var totalDist = Math.max(dx, dy);
      var distTraveled = totalDist * progress;

      var minSpeed = 999;
      Object.keys(m.troops).forEach(k => {
        if ((m.troops[k] || 0) > 0 && TROOP_TYPES[k] && TROOP_TYPES[k].speed < minSpeed) {
          minSpeed = TROOP_TYPES[k].speed;
        }
      });
      if (minSpeed === 999) minSpeed = 1;

      var returnSecs = (distTraveled / minSpeed) * MISSION_FACTOR;
      var returnAt = new Date(now + returnSecs * 1000).toISOString();

      vs.mission_queue.splice(idx, 1);
      vs.mission_queue.push({
        type: 'return',
        tx: activeVillage.x,
        ty: activeVillage.y,
        troops: m.troops,
        finish_at: returnAt,
        start_at: new Date(now).toISOString()
      });

      showNotif('MisiÃ³n cancelada. Tropas regresan en ' + fmtTime(Math.ceil(returnSecs)), 'ok');
      await flushVillage();
      tick();
    }

    async function startMission(type, tx, ty, targetId, troops, guestContingents) {
      if (!activeVillage) return;
      var vs = activeVillage.state;

      var dx = Math.abs(tx - activeVillage.x);
      var dy = Math.abs(ty - activeVillage.y);
      var dist = Math.max(dx, dy);

      var minSpeed = 999;
      Object.keys(troops).forEach(k => {
        var troopData = TROOP_TYPES[k] || CREATURE_TYPES[k];
        if (troops[k] > 0 && troopData && troopData.speed < minSpeed) minSpeed = troopData.speed;
      });
      if (guestContingents) {
        guestContingents.forEach(function (c) {
          Object.keys(c.troops || {}).forEach(function (k) {
            var troopData = TROOP_TYPES[k] || CREATURE_TYPES[k];
            if ((c.troops[k] || 0) > 0 && troopData && troopData.speed < minSpeed) minSpeed = troopData.speed;
          });
        });
      }
      if (minSpeed === 999) minSpeed = 1;

      var seconds = (dist / minSpeed) * MISSION_FACTOR;
      var finishAt = new Date(Date.now() + seconds * 1000).toISOString();

      snapshotResources(vs);
      Object.keys(troops).forEach(k => {
        if (TROOP_TYPES[k]) vs.troops[k] = Math.max(0, (vs.troops[k] || 0) - troops[k]);
        else if (CREATURE_TYPES[k]) vs.creatures[k] = Math.max(0, (vs.creatures[k] || 0) - troops[k]);
      });

      var totalUnits = 0;
      Object.keys(troops).forEach(k => { if (TROOP_TYPES[k]) totalUnits += troops[k]; });
      vs.resources.provisiones = Math.max(0, vs.resources.provisiones - totalUnits);

      var missionEntry = {
        mid: Math.random().toString(36).slice(2, 10) + Date.now().toString(36),
        type, tx, ty, targetId, troops,
        finish_at: finishAt,
        start_at: new Date().toISOString()
      };
      if (guestContingents && guestContingents.length > 0) {
        missionEntry.guest_contingents = guestContingents;
      }
      vs.mission_queue.push(missionEntry);

      // Registrar en active_missions para visibilidad de aliados (solo ataque PvP con contingentes)
      if (type === 'attack' && guestContingents && guestContingents.length > 0) {
        _insertActiveMission(missionEntry.mid, missionEntry, guestContingents);
      }

      showNotif('MisiÃ³n enviada! Llegada en ' + fmtTime(Math.ceil(seconds)), 'ok');
      await flushVillage();
      tick();
    }

    async function sendSystemReport(userId, title, body) {
      try {
        // Store as JSON with title + body so inbox can show title collapsed
        var payload = JSON.stringify({ title: title, body: body });
        var r = await sbClient.rpc('send_system_message', {
          p_user_id: userId,
          p_body: payload
        });
        if (r.error) console.warn('sendSystemReport RPC error:', r.error);
        // Refrescar mensajes automÃ¡ticamente si el usuario estÃ¡ en la pÃ¡gina de mensajes
        if (userId === (currentUser && currentUser.id)) {
          var msgPage = document.getElementById('page-messages');
          if (msgPage && msgPage.style.display !== 'none') {
            renderThreads();
            if (currentThreadId) loadSystemReports();
          }
        }
      } catch (e) {
        console.warn('sendSystemReport error:', e);
      }
    }

    async function resolveMissions(vs) {
      if (!vs.mission_queue || vs.mission_queue.length === 0) return vs;

      var now = Date.now();
      var remaining = [];
      var changed = false;

      for (var m of vs.mission_queue) {
        var finish = new Date(m.finish_at).getTime();
        if (now >= finish) {
          changed = true;
          // EXECUTE MISSION â€” wrapped in try/catch para que un error no atasque la misiÃ³n
          try {
            if (m.type === 'spy') {
              await executeSpyMission(m);
            } else if (m.type === 'attack') {
              await executeAttackMission(m);
            } else if (m.type === 'found') {
              await executeFounding(m);
              continue;
            } else if (m.type === 'move') {
              await executeMove(m);
              continue; // tropas quedan en destino permanentemente
            } else if (m.type === 'reinforce') {
              await executeReinforce(m);
              continue; // tropas quedan en guest_troops
            } else if (m.type === 'transport') {
              await executeTransport(m);
              // NO hacer continue - permitir que las tropas vuelvan
            } else if (m.type === 'return_reinforce') {
              // Tropas volviendo de refuerzo a su aldea origen
              // Se aÃ±aden a las tropas del activeVillage (que es el origen)
              Object.keys(m.troops || {}).forEach(function (k) {
                if ((m.troops[k] || 0) <= 0) return;
                if (TROOP_TYPES[k]) vs.troops[k] = (vs.troops[k] || 0) + m.troops[k];
                else if (CREATURE_TYPES[k]) { if (!vs.creatures) vs.creatures = defaultCreatures(); vs.creatures[k] = (vs.creatures[k] || 0) + m.troops[k]; }
              });
              // No enviar mensaje - no es importante
              continue;
            } else if (m.type === 'return') {
              // â”€â”€ TROPAS REGRESAN â”€â”€
              var barrCap = getBarracksCapacity(vs.buildings);
              var usedNow = getBarracksUsed(vs);
              var freeSlots = Math.max(0, barrCap - usedNow);

              // Calcular cuÃ¡ntas plazas necesitan las tropas que regresan
              var slotsNeeded = 0;
              Object.keys(m.troops).forEach(function (k) {
                var count = m.troops[k] || 0;
                if (count <= 0) return;
                var slots = k === 'aldeano' ? count : count * ((TROOP_TYPES[k] && TROOP_TYPES[k].barracasSlots) || 1);
                slotsNeeded += slots;
              });

              var accepted = {}, anyRejected = false;

              if (slotsNeeded <= freeSlots) {
                // Caben todas
                Object.keys(m.troops).forEach(function (k) { accepted[k] = m.troops[k] || 0; });
              } else {
                // No caben todas â€” eliminar porcentaje proporcional de cada tipo
                var pctEliminar = freeSlots < slotsNeeded ? (slotsNeeded - freeSlots) / slotsNeeded : 0;

                Object.keys(m.troops).forEach(function (k) {
                  var total = m.troops[k] || 0;
                  if (total <= 0) { accepted[k] = 0; return; }
                  var toEliminate = Math.ceil(total * pctEliminar);
                  var toAccept = total - toEliminate;
                  // Verificar que las plazas de los aceptados no superen freeSlots
                  while (toAccept > 0) {
                    var testSlots = k === 'aldeano' ? toAccept : toAccept * ((TROOP_TYPES[k] && TROOP_TYPES[k].barracasSlots) || 1);
                    if (testSlots <= freeSlots) break;
                    toAccept--;
                  }
                  accepted[k] = toAccept;
                  if (toAccept < total) anyRejected = true;
                });

                // VerificaciÃ³n final: la suma de slots aceptados no supera freeSlots
                var totalAcceptedSlots = 0;
                Object.keys(accepted).forEach(function (k) {
                  var count = accepted[k] || 0;
                  totalAcceptedSlots += k === 'aldeano' ? count : count * ((TROOP_TYPES[k] && TROOP_TYPES[k].barracasSlots) || 1);
                });
                if (totalAcceptedSlots > freeSlots) {
                  // Recorte de emergencia proporcional adicional
                  Object.keys(accepted).forEach(function (k) {
                    accepted[k] = Math.floor(accepted[k] * freeSlots / totalAcceptedSlots);
                  });
                  anyRejected = true;
                }
              }

              // AÃ±adir tropas y criaturas aceptadas al estado
              Object.keys(accepted).forEach(function (k) {
                var toAdd = accepted[k] || 0;
                if (toAdd <= 0) return;

                if (TROOP_TYPES[k]) {
                  // Tropa normal
                  if (k === 'aldeano') {
                    vs.troops.aldeano = (vs.troops.aldeano || 0) + toAdd;
                  } else {
                    vs.troops[k] = (vs.troops[k] || 0) + toAdd;
                  }
                } else if (CREATURE_TYPES[k]) {
                  // Criatura - no ocupan barracas
                  if (!vs.creatures) vs.creatures = defaultCreatures();
                  vs.creatures[k] = (vs.creatures[k] || 0) + toAdd;
                }
              });

              // Aplicar botÃ­n con lÃ­mites de capacidad
              var lootReport = '';
              if (m.loot) {
                var cap = getCapacity(vs.buildings);
                var appliedLoot = {};

                ['madera', 'piedra', 'hierro', 'provisiones'].forEach(function (res) {
                  var incoming = m.loot[res] || 0;
                  if (incoming > 0) {
                    var current = vs.resources[res] || 0;
                    var space = Math.max(0, cap - current);
                    var added = Math.min(incoming, space);

                    vs.resources[res] = current + added;
                    if (added > 0) appliedLoot[res] = added;
                  }
                });

                // Esencia no tiene lÃ­mite
                if (m.loot.esencia > 0) {
                  vs.resources.esencia = (vs.resources.esencia || 0) + m.loot.esencia;
                  appliedLoot.esencia = m.loot.esencia;
                }

                // Generar reporte de botÃ­n
                if (Object.keys(appliedLoot).length > 0) {
                  lootReport = '\n\nğŸ’° BotÃ­n obtenido:\n';
                  if (appliedLoot.madera) lootReport += 'ğŸŒ² ' + fmt(appliedLoot.madera) + ' madera\n';
                  if (appliedLoot.piedra) lootReport += 'â›°ï¸ ' + fmt(appliedLoot.piedra) + ' piedra\n';
                  if (appliedLoot.hierro) lootReport += 'âš™ï¸ ' + fmt(appliedLoot.hierro) + ' hierro\n';
                  if (appliedLoot.provisiones) lootReport += 'ğŸŒ¾ ' + fmt(appliedLoot.provisiones) + ' provisiones\n';
                  if (appliedLoot.esencia) lootReport += 'âœ¨ ' + fmt(appliedLoot.esencia) + ' esencia';
                }
              }

              var acceptedStr = Object.keys(accepted).filter(function (k) { return (accepted[k] || 0) > 0; })
                .map(function (k) { return accepted[k] + ' ' + (TROOP_TYPES[k] ? TROOP_TYPES[k].name : k); }).join(', ') || 'ninguna';
              var rejectedStr = anyRejected ? '\nâš ï¸ Sin espacio en barracas: algunas tropas se perdieron.' : '';

              showNotif('Â¡Tropas han regresado!', 'ok');
              continue; // La misiÃ³n de retorno se descarta tras procesar
            }
          } catch (e) {
            console.warn('resolveMissions: error ejecutando misiÃ³n', m.type, e);
            // La misiÃ³n se descarta igualmente â€” no se queda atascada
          }

          // Tropas regresan a la velocidad del mÃ¡s lento, igual que la ida
          // Solo vuelven los supervivientes (m.troops ya tiene los supervivientes tras batalla)
          var survivors = m.troops || {};
          var hasSurvivors = Object.values(survivors).some(function (n) { return n > 0; });

          if (hasSurvivors) {
            // Calcular velocidad del mÃ¡s lento entre supervivientes
            var minSpeed = 999;
            Object.keys(survivors).forEach(function (k) {
              if ((survivors[k] || 0) > 0 && TROOP_TYPES[k] && TROOP_TYPES[k].speed < minSpeed) {
                minSpeed = TROOP_TYPES[k].speed;
              }
            });
            if (minSpeed === 999) minSpeed = 1;

            // Misma distancia que la ida
            var dx = Math.abs(m.tx - activeVillage.x);
            var dy = Math.abs(m.ty - activeVillage.y);
            var dist = Math.max(dx, dy);
            var returnSecs = (dist / minSpeed) * MISSION_FACTOR;
            var returnAt = new Date(Date.now() + returnSecs * 1000).toISOString();

            // AÃ±adir misiÃ³n de retorno
            remaining.push({
              type: 'return',
              tx: activeVillage.x,
              ty: activeVillage.y,
              troops: survivors,
              finish_at: returnAt,
              start_at: new Date().toISOString(),
              origin_name: m.targetId || 'misiÃ³n',
              loot: m.loot || null
            });
            // NotificaciÃ³n eliminada - causaba spam en cada tick
          }
        } else {
          // MisiÃ³n aÃºn no ha terminado - mantener en la cola
          remaining.push(m);
        }
      }

      if (changed) {
        // Descartar solo misiones con finish_at hace mÃ¡s de 7 dÃ­as (datos corruptos, no offline legÃ­timo)
        var sevenDaysAgo = Date.now() - 7 * 24 * 3600 * 1000;
        remaining = remaining.filter(function (m) {
          var ft = new Date(m.finish_at).getTime();
          if (ft < sevenDaysAgo) {
            console.warn('resolveMissions: descartando misiÃ³n corrupta (>7 dÃ­as)', m);
            return false;
          }
          return true;
        });
        vs.mission_queue = remaining;
      }
      return vs;
    }

    async function executeSpyMission(m) {
      var target = (typeof NPC_CASTLES !== 'undefined' ? NPC_CASTLES : []).find(c => c.id === m.targetId);
      if (target) {
        var obj = playerObjectives.find(o => o.objective_id === target.id);
        var alreadyCleared = obj && obj.status === 'cleared';
        var report =
          'âš”ï¸ INFORME DE ESPIONAJE\n' +
          'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n' +
          target.name + ' [' + m.tx + ', ' + m.ty + ']\n\n' +
          'ğŸ—¡ï¸ Ataques por turno: ' + target.attacksPerTurn + '\n' +
          'ğŸ¯ Bono de ataque:    +' + target.attackChance + '\n' +
          'ğŸ’¥ DaÃ±o:              ' + fmt(target.damage) + '\n' +
          'â¤ï¸ Vida (PG):         ' + fmt(target.hp) + '\n' +
          'ğŸ›¡ï¸ Clase de Armadura: ' + target.defense + '\n' +
          'âš¡ Destreza:          ' + target.dexterity + '\n\n' +
          'ğŸ† Recompensa:        ' + fmt(target.rewards.experience) + ' XP\n' +
          (alreadyCleared ? '\nâœ… Ya derrotado por ti.' : '\nâš ï¸ AÃºn no derrotado.');
        await updateObjective(target.id, 'spied');
        await sendSystemReport(currentUser.id, 'ğŸ” ESPIONAJE: ' + target.name, report);
        showNotif('Espionaje completado. Revisa tus mensajes.', 'ok');
      } else {
        // Puede ser aldea PvP o fantasma â€” buscar en villages
        var spyR = await sbClient.from('villages').select('id,name,owner_id,cx,cy').eq('id', m.targetId).maybeSingle();
        if (spyR.data) {
          var sv = spyR.data;
          var isGhost = sv.owner_id === GHOST_OWNER_ID;
          var ownerName = isGhost ? 'Aldea Fantasma' : ((profileCache[sv.owner_id] && profileCache[sv.owner_id].username) || 'Jugador desconocido');
          // Cargar tropas
          var spyTrpR = await sbClient.from('troops').select('*').eq('village_id', m.targetId).maybeSingle();
          var spyCrtR = await sbClient.from('creatures').select('*').eq('village_id', m.targetId).maybeSingle();
          var spyBldR = await sbClient.from('buildings').select('muralla').eq('village_id', m.targetId).maybeSingle();
          var troopLines = '';
          if (spyTrpR.data) {
            Object.keys(spyTrpR.data).forEach(function(k) {
              if (k === 'village_id') return;
              var n = spyTrpR.data[k] || 0;
              var td = TROOP_TYPES[k];
              if (n > 0 && td) troopLines += '\n  ' + td.icon + ' ' + td.name + ': ' + fmt(n);
            });
          }
          if (spyCrtR.data) {
            Object.keys(spyCrtR.data).forEach(function(k) {
              if (k === 'village_id' || k === 'created_at' || k === 'updated_at') return;
              var n = spyCrtR.data[k] || 0;
              var cd = CREATURE_TYPES[k];
              if (n > 0 && cd) troopLines += '\n  ' + cd.icon + ' ' + cd.name + ': ' + fmt(n);
            });
          }
          var wallLvlSpy = (spyBldR.data && spyBldR.data.muralla) || 0;
          var report = 'ğŸ” INFORME DE ESPIONAJE\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n' +
            sv.name + ' [' + sv.cx + ', ' + sv.cy + ']\n' +
            'Propietario: ' + ownerName + '\n' +
            (wallLvlSpy > 0 ? 'ğŸ° Muralla: Nivel ' + wallLvlSpy + '\n' : '') +
            '\nâš”ï¸ Tropas detectadas:' + (troopLines || '\n  Sin tropas visibles');
          await sendSystemReport(currentUser.id, 'ğŸ” ESPIONAJE: ' + sv.name, report);
          showNotif('Espionaje completado. Revisa tus mensajes.', 'ok');
        } else {
          await sendSystemReport(currentUser.id, 'ESPIONAJE', 'Coordenada [' + m.tx + ', ' + m.ty + '] sin objetivo.');
          showNotif('Sin objetivo en esa coordenada.', 'err');
        }
      }
    }

    async function executeAttackMission(m) {
      var target = (typeof NPC_CASTLES !== 'undefined' ? NPC_CASTLES : []).find(c => c.id === m.targetId);
      if (!target) {
        // No es NPC â€” puede ser ataque PvP
        await executeAttackPvP(m);
        return;
      }

      // Comprobar si ya fue derrotado por este jugador
      var obj = playerObjectives.find(o => o.objective_id === target.id);
      if (obj && obj.status === 'cleared') {
        await sendSystemReport(currentUser.id, 'âš”ï¸ BATALLA: ' + target.name,
          'âŒ Ya derrotaste a ' + target.name + ' anteriormente. No puedes atacarlo de nuevo.');
        showNotif(target.name + ' ya fue derrotado por ti.', 'err');
        return;
      }

      // EjÃ©rcito atacante: solo tropas propias (aliados NO pueden atacar NPCs)
      var _atkFullArmy = Object.assign({}, m.troops || {});

      // El caballero es UNA sola unidad con sus stats completos
      var knightArmy = {
        _knight: {
          count: 1,
          stats: {
            hp: target.hp,
            damage: target.damage,
            attacksPerTurn: target.attacksPerTurn,
            attackChance: target.attackChance,
            defense: target.defense,
            dexterity: target.dexterity,
            armor: 0,
            weapon: 0,
            icon: 'ğŸ‘‘',
            name: target.name
          }
        }
      };

      var result = simulateBattle(_atkFullArmy, knightArmy, 0);
      var victoria = result.winner === 1;

      var attackerCasualties = {};
      var defenderCasualties = {};

      Object.keys(_atkFullArmy).forEach(function (type) {
        var initial = _atkFullArmy[type] || 0;
        var final = (result.survivors1[type] || 0);
        if (initial > final) {
          attackerCasualties[type] = initial - final;
        }
      });

      Object.keys(knightArmy).forEach(function (type) {
        var initial = knightArmy[type].count || 0;
        var final = (result.survivors2[type] || 0);
        if (initial > final) {
          defenderCasualties[type] = initial - final;
        }
      });

      // Calcular XP por bajas â€” v1.36: factor Ã— nivel_tropa_matada Ã— cantidad
      // Aldeano: 2 Ã— nivel; otras tropas: 10 Ã— nivel; criaturas: 10 (sin nivel)
      var attackerXP = 0;
      var defenderXP = 0;
      var atkTroopLvls = (_researchData && _researchData.troop_levels) || {};

      // Atacante gana XP por matar tropas del defensor NPC (nivel 1 siempre)
      Object.keys(defenderCasualties).forEach(function (type) {
        var killed = defenderCasualties[type];
        if (type === '_knight') {
          attackerXP += target.rewards.experience;
        } else if (TROOP_TYPES[type]) {
          var lvl = 1; // NPC siempre nivel 1
          attackerXP += killed * (type === 'aldeano' ? 2 : 10) * lvl;
        } else if (CREATURE_TYPES[type]) {
          attackerXP += killed * 10;
        }
      });

      // Defensor gana XP por matar tropas del atacante (nivel del atacante)
      Object.keys(attackerCasualties).forEach(function (type) {
        var killed = attackerCasualties[type];
        if (TROOP_TYPES[type]) {
          var lvl = atkTroopLvls[type] || 1;
          defenderXP += killed * (type === 'aldeano' ? 2 : 10) * lvl;
        } else if (CREATURE_TYPES[type]) {
          defenderXP += killed * 10;
        }
      });

      // Calcular recuperaciÃ³n de tropas (todo el ejÃ©rcito combinado)
      var attackerRecovered = calculateRecovery(attackerCasualties);

      // Supervivientes totales = combate + recuperados
      var totalSurv = {};
      Object.keys(result.survivors1).forEach(function (type) {
        var n = (result.survivors1[type] || 0) + (attackerRecovered[type] || 0);
        if (n > 0) totalSurv[type] = n;
      });
      Object.keys(attackerRecovered).forEach(function (type) {
        if (!totalSurv[type] && attackerRecovered[type] > 0) totalSurv[type] = attackerRecovered[type];
      });

      // Supervivientes propios incluyendo recuperados
      var ownSurv = Object.assign({}, totalSurv);

      var loot = null;
      if (victoria) {
        loot = { madera: 0, piedra: 0, hierro: 0, provisiones: 0, esencia: 0 };
      }

      var reportHTML = generateBattleReport(
        currentUser.user_metadata?.username || 'Jugador',
        target.name, _atkFullArmy, knightArmy, result, loot, attackerXP, defenderXP, true
      );

      if (victoria) {
        await sbClient.rpc('add_experience', { amount: attackerXP });
        await updateObjective(target.id, 'cleared');
        if (activeVillage && activeVillage.state) {
          activeVillage.state.battles_won_npc = (activeVillage.state.battles_won_npc || 0) + 1;
          scheduleSave();
          sbClient.from('profiles').update({ battles_won_npc: activeVillage.state.battles_won_npc }).eq('id', currentUser.id).then(function(){}).catch(function(){});
        }
        showNotif('Â¡' + target.name + ' derrotado! +' + fmt(attackerXP) + ' XP', 'ok');
      } else {
        await updateObjective(target.id, 'attacked');
        showNotif('Derrota contra ' + target.name + '. Revisa el reporte.', 'err');
      }

      m.troops = ownSurv;
      m.loot   = loot;
      await sendSystemReport(currentUser.id, (victoria ? 'ğŸ†' : 'ğŸ’€') + ' BATALLA: ' + target.name, reportHTML);
    }

    // ============================================================
    // PvP â€” Ataque entre jugadores
    // ============================================================
    async function executeAttackPvP(m) {
      try {
        // 1. Cargar aldea defensora
        var r = await sbClient.from('villages').select('*').eq('id', m.targetId).maybeSingle();
        if (r.error || !r.data) {
          await sendSystemReport(currentUser.id, 'âš”ï¸ ATAQUE PvP', 'âŒ La aldea objetivo ya no existe. Tus tropas regresan.');
          _returnTroopsHome(m); return;
        }
        var targetVillage = r.data;
        var ts = typeof targetVillage.state === 'string' ? JSON.parse(targetVillage.state) : (targetVillage.state || null);

        // Si ts es null (aldea fantasma o sin state blob), cargar desde tablas separadas
        if (!ts) {
          ts = { buildings: {}, troops: {}, creatures: {}, resources: {} };
          var bldR = await sbClient.from('buildings').select('*').eq('village_id', m.targetId).maybeSingle();
          if (bldR.data) {
            Object.keys(bldR.data).forEach(function(k) {
              if (k !== 'village_id') ts.buildings[k] = { level: bldR.data[k] || 0 };
            });
          }
          var trpR = await sbClient.from('troops').select('*').eq('village_id', m.targetId).maybeSingle();
          if (trpR.data) {
            Object.keys(trpR.data).forEach(function(k) {
              if (k !== 'village_id') ts.troops[k] = trpR.data[k] || 0;
            });
          }
          var crtR = await sbClient.from('creatures').select('*').eq('village_id', m.targetId).maybeSingle();
          if (crtR.data) {
            Object.keys(crtR.data).forEach(function(k) {
              if (k !== 'village_id' && k !== 'created_at' && k !== 'updated_at') ts.creatures[k] = crtR.data[k] || 0;
            });
          }
          var resR = await sbClient.from('resources').select('*').eq('village_id', m.targetId).maybeSingle();
          if (resR.data) {
            ts.resources = { madera: resR.data.madera || 0, piedra: resR.data.piedra || 0, hierro: resR.data.hierro || 0, oro: 0, esencia: resR.data.esencia || 0 };
          }
        }

        var wallLvl = (ts.buildings && ts.buildings.muralla && ts.buildings.muralla.level) || 0;

        // 2. Construir contingentes ATACANTES
        var leaderName = (profileCache[currentUser.id] && profileCache[currentUser.id].username) || activeVillage.name || 'Atacante';
        var attackerContingents = [{
          owner_id:     currentUser.id,
          name:         leaderName,
          village_name: activeVillage.name || '',
          village_id:   activeVillage.id,
          troops:       Object.assign({}, m.troops || {})
        }];
        (m.guest_contingents || []).forEach(function (c) {
          if (!c.troops || !Object.values(c.troops).some(function (n) { return n > 0; })) return;
          attackerContingents.push({
            owner_id:     c.owner_id,
            name:         (profileCache[c.owner_id] && profileCache[c.owner_id].username) || c.owner_id.slice(0,8),
            village_name: '',
            village_id:   c.origin_village_id,
            troops:       Object.assign({}, c.troops)
          });
        });

        // 3. Construir contingentes DEFENSORES: dueÃ±o + aliados estacionados
        var defOwnerTroops = {};
        Object.keys(TROOP_TYPES).forEach(function (k) { var n = (ts.troops && ts.troops[k]) || 0; if (n > 0) defOwnerTroops[k] = n; });
        Object.keys(CREATURE_TYPES).forEach(function (k) { var n = (ts.creatures && ts.creatures[k]) || 0; if (n > 0) defOwnerTroops[k] = n; });
        var defenderContingents = [{
          owner_id:     targetVillage.owner_id,
          name:         targetVillage.owner_id === GHOST_OWNER_ID
                          ? (targetVillage.name || 'Aldea Fantasma')
                          : (profileCache[targetVillage.owner_id] && profileCache[targetVillage.owner_id].username) || 'Defensor',
          village_name: targetVillage.name || '',
          village_id:   targetVillage.id,
          troops:       defOwnerTroops
        }];
        var guestDefenders = [];
        if (_guestTroopsTableExists !== false) {
          try {
            var gr = await sbClient.from('guest_troops').select('*').eq('host_village_id', m.targetId);
            if (!gr.error && gr.data) guestDefenders = gr.data;
          } catch (e) { /* ignorar */ }
        }
        guestDefenders.forEach(function (gt) {
          var gTroops = typeof gt.troops === 'string' ? JSON.parse(gt.troops) : (gt.troops || {});
          if (!Object.values(gTroops).some(function (n) { return n > 0; })) return;
          defenderContingents.push({
            owner_id:     gt.owner_id,
            name:         (profileCache[gt.owner_id] && profileCache[gt.owner_id].username) || gt.owner_id.slice(0,8),
            village_name: '',
            village_id:   gt.origin_village_id,
            gt_id:        gt.id,
            troops:       gTroops
          });
        });

        // 4. BATALLAR
        var bResult = simulateBattlePvP(attackerContingents, defenderContingents, wallLvl);
        var victoria = bResult.winner === 1;

        // 5. BotÃ­n â€” capacidad de supervivientes atacantes
        var loot = {};
        if (victoria) {
          var totalCarry = 0;
          bResult.attackerResults.forEach(function (ar) {
            Object.keys(ar.survivors).forEach(function (k) {
              var td = TROOP_TYPES[k];
              if (td && td.capacity > 0) totalCarry += (ar.survivors[k] || 0) * td.capacity;
            });
          });
          var totalAvail = 0, avail = {};
          ['madera','piedra','hierro','oro'].forEach(function (res) {
            var n = (ts.resources && ts.resources[res]) || 0;
            if (n > 0) { avail[res] = n; totalAvail += n; }
          });
          if (totalCarry > 0 && totalAvail > 0) {
            ['madera','piedra','hierro','oro'].forEach(function (res) {
              if (!avail[res]) return;
              var take = Math.min(Math.floor(totalCarry * (avail[res] / totalAvail)), avail[res]);
              if (take > 0) { loot[res] = take; ts.resources[res] = Math.max(0, avail[res] - take); }
            });
          }
        }

        // 6. Guardar defensores
        var defOwnerRes = bResult.defenderResults[0];
        Object.keys(TROOP_TYPES).forEach(function (k) { if (ts.troops) ts.troops[k] = defOwnerRes.survivors[k] || 0; });
        Object.keys(CREATURE_TYPES).forEach(function (k) { if (ts.creatures) ts.creatures[k] = defOwnerRes.survivors[k] || 0; });
        for (var di = 1; di < bResult.defenderResults.length; di++) {
          var dRes = bResult.defenderResults[di];
          var gtId = defenderContingents[di].gt_id;
          if (!gtId) continue;
          var hasSurv = Object.values(dRes.survivors).some(function (n) { return n > 0; });
          if (hasSurv) await sbClient.from('guest_troops').update({ troops: JSON.stringify(dRes.survivors) }).eq('id', gtId);
          else          await sbClient.from('guest_troops').delete().eq('id', gtId);
        }
        // Guardar estado defensor: si es aldea fantasma, actualizar tablas separadas
        if (targetVillage.owner_id === GHOST_OWNER_ID) {
          var trpUpdate = {};
          Object.keys(TROOP_TYPES).forEach(function(k) { trpUpdate[k] = ts.troops[k] || 0; });
          await sbClient.from('troops').update(trpUpdate).eq('village_id', m.targetId);
          var crtUpdate = {};
          Object.keys(CREATURE_TYPES).forEach(function(k) { crtUpdate[k] = ts.creatures[k] || 0; });
          await sbClient.from('creatures').update(crtUpdate).eq('village_id', m.targetId);
          if (Object.keys(loot).length > 0) {
            var resUpdate = { madera: ts.resources.madera || 0, piedra: ts.resources.piedra || 0, hierro: ts.resources.hierro || 0, esencia: ts.resources.esencia || 0 };
            await sbClient.from('resources').update(resUpdate).eq('village_id', m.targetId);
          }
        } else {
          await sbClient.from('villages').update({ state: JSON.stringify(ts) }).eq('id', m.targetId);
        }

        // 7. Retorno propias tropas
        var ownRes = bResult.attackerResults[0];
        m.troops = Object.assign({}, ownRes.survivors);
        Object.keys(ownRes.recovered || {}).forEach(function (k) { m.troops[k] = (m.troops[k] || 0) + (ownRes.recovered[k] || 0); });
        m.loot = loot;

        // 8. Retorno contingentes aliados atacantes
        for (var ai = 1; ai < bResult.attackerResults.length; ai++) {
          var aRes = bResult.attackerResults[ai];
          var aC   = m.guest_contingents[ai - 1];
          var surv = Object.assign({}, aRes.survivors);
          Object.keys(aRes.recovered || {}).forEach(function (k) { surv[k] = (surv[k] || 0) + (aRes.recovered[k] || 0); });
          if (!Object.values(surv).some(function (n) { return n > 0; })) continue;
          var origVR = await sbClient.from('villages').select('id,x,y,state').eq('id', aC.origin_village_id).maybeSingle();
          if (origVR.error || !origVR.data) continue;
          var origV     = origVR.data;
          var origState = typeof origV.state === 'string' ? JSON.parse(origV.state) : origV.state;
          var cMinSpd = 999;
          Object.keys(surv).forEach(function (k) { var td = TROOP_TYPES[k] || CREATURE_TYPES[k]; if ((surv[k]||0) > 0 && td && td.speed < cMinSpd) cMinSpd = td.speed; });
          if (cMinSpd === 999) cMinSpd = 1;
          var cDist = Math.max(Math.abs(m.tx - origV.x), Math.abs(m.ty - origV.y));
          var cSecs = Math.ceil((cDist / cMinSpd) * MISSION_FACTOR);
          if (!origState.mission_queue) origState.mission_queue = [];
          origState.mission_queue.push({ type:'return_reinforce', tx:origV.x, ty:origV.y, troops:surv,
            finish_at: new Date(Date.now() + cSecs*1000).toISOString(), start_at: new Date().toISOString() });
          await sbClient.from('villages').update({ state: JSON.stringify(origState) }).eq('id', aC.origin_village_id);
        }

        // 9. Limpiar active_missions
        await _clearActiveMission(m.mid);

        // 9b. XP por bajas causadas â€” v1.36: factor Ã— nivel_tropa_matada Ã— cantidad
        var pvpXP = 0;
        var pvpAtkLvls = (_researchData && _researchData.troop_levels) || {};
        bResult.defenderResults.forEach(function(dr) {
          Object.keys(dr.casualties || {}).forEach(function(type) {
            var killed = dr.casualties[type] || 0;
            if (TROOP_TYPES[type]) {
              // Nivel de tropas del defensor â€” usamos 1 si no disponible
              var lvl = 1;
              pvpXP += killed * (type === 'aldeano' ? 2 : 10) * lvl;
            } else if (CREATURE_TYPES[type]) {
              pvpXP += killed * 10;
            }
          });
        });
        if (pvpXP > 0) {
          sbClient.rpc('add_experience', { amount: pvpXP }).then(function(){}).catch(function(e){ console.warn('PvP XP error:', e); });
        }

        // 10. Informe y notificaciones
        var reportHtml = generateBattlePvPReport(bResult, wallLvl, loot, { x: m.tx, y: m.ty });
        var titleAtk   = (victoria ? 'ğŸ†' : 'ğŸ’€') + ' BATALLA PvP: ' + (targetVillage.name || '['+m.tx+','+m.ty+']');
        var titleDef   = (victoria ? 'ğŸš¨' : 'ğŸ›¡ï¸') + ' BATALLA PvP: ' + leaderName + ' atacÃ³ tu aldea';
        var sentTo = new Set();
        async function notifyParticipant(uid, title) {
          if (!uid || uid === GHOST_OWNER_ID) return; // aldeas fantasma no tienen buzÃ³n
          if (!sentTo.has(uid)) { await sendSystemReport(uid, title, reportHtml); sentTo.add(uid); }
        }
        await notifyParticipant(currentUser.id, titleAtk);
        for (var ai2 = 1; ai2 < bResult.attackerResults.length; ai2++) await notifyParticipant(bResult.attackerResults[ai2].owner_id, titleAtk);
        await notifyParticipant(targetVillage.owner_id, titleDef);
        for (var di2 = 1; di2 < bResult.defenderResults.length; di2++) await notifyParticipant(bResult.defenderResults[di2].owner_id, titleDef);

        if (victoria) {
          if (targetVillage.owner_id === GHOST_OWNER_ID) {
            // Victoria contra aldea fantasma cuenta como NPC
            if (activeVillage && activeVillage.state) {
              activeVillage.state.battles_won_npc = (activeVillage.state.battles_won_npc || 0) + 1;
              scheduleSave();
              sbClient.from('profiles').update({ battles_won_npc: activeVillage.state.battles_won_npc }).eq('id', currentUser.id).then(function(){}).catch(function(){});
            }
            showNotif('âš”ï¸ Â¡Aldea fantasma derrotada!', 'ok');
          } else {
            if (activeVillage && activeVillage.state) {
              activeVillage.state.battles_won_pvp = (activeVillage.state.battles_won_pvp || 0) + 1;
              scheduleSave();
              sbClient.from('profiles').update({ battles_won_pvp: activeVillage.state.battles_won_pvp }).eq('id', currentUser.id).then(function(){}).catch(function(){});
            }
            showNotif('âš”ï¸ Â¡Victoria PvP contra ' + (targetVillage.name || 'aldea') + '!', 'ok');
          }
        } else {
          if (targetVillage.owner_id !== GHOST_OWNER_ID) {
            if (activeVillage && activeVillage.state) {
              activeVillage.state.battles_lost_pvp = (activeVillage.state.battles_lost_pvp || 0) + 1;
              scheduleSave();
              sbClient.from('profiles').update({ battles_lost_pvp: activeVillage.state.battles_lost_pvp }).eq('id', currentUser.id).then(function(){}).catch(function(){});
            }
          }
          showNotif('ğŸ’€ Derrota PvP. Revisa el informe.', 'err');
        }

      } catch (e) {
        console.error('executeAttackPvP error:', e);
        await sendSystemReport(currentUser.id, 'âš”ï¸ ERROR PvP', 'Error: ' + (e.message || e) + '. Tus tropas regresan.');
        _returnTroopsHome(m);
      }
    }

    // ============================================================
    // ACTIVE MISSIONS â€” visibilidad multi-jugador para ataques conjuntos
    // Tabla Supabase: active_missions (id, mission_id, leader_id, host_village_id,
    //   target_x, target_y, participant_id, troops jsonb, finish_at, status)
    // ============================================================
    var _activeMissionsTableExists = null;

    async function _insertActiveMission(missionId, m, contingents) {
      if (_activeMissionsTableExists === false) return;
      try {
        var rows = [];
        // Fila del lÃ­der
        rows.push({
          mission_id:      missionId,
          leader_id:       currentUser.id,
          host_village_id: activeVillage.id,
          target_x:        m.tx, target_y: m.ty,
          participant_id:  currentUser.id,
          troops:          JSON.stringify(m.troops || {}),
          finish_at:       m.finish_at,
          status:          'active'
        });
        // Fila por contingente aliado
        (contingents || []).forEach(function (c) {
          rows.push({
            mission_id:      missionId,
            leader_id:       currentUser.id,
            host_village_id: activeVillage.id,
            target_x:        m.tx, target_y: m.ty,
            participant_id:  c.owner_id,
            troops:          JSON.stringify(c.troops || {}),
            finish_at:       m.finish_at,
            status:          'active'
          });
        });
        var ir = await sbClient.from('active_missions').insert(rows);
        if (ir.error) {
          if (ir.error.code === '42P01') { _activeMissionsTableExists = false; }
          else console.warn('_insertActiveMission:', ir.error);
        } else { _activeMissionsTableExists = true; }
      } catch (e) { console.warn('_insertActiveMission error:', e); }
    }

    async function _clearActiveMission(missionId) {
      if (_activeMissionsTableExists === false || !missionId) return;
      try { await sbClient.from('active_missions').delete().eq('mission_id', missionId); } catch (e) { /* ignorar */ }
    }

    async function cancelAlliedMission(missionId, leaderVillageId) {
      if (!confirm('Â¿Cancelar este ataque conjunto? Las tropas de TODOS los participantes regresarÃ¡n.')) return;
      if (_activeMissionsTableExists === false) return;
      try {
        // Marcar como cancelada
        await sbClient.from('active_missions').update({ status: 'cancelled' }).eq('mission_id', missionId);

        // Cargar aldea del lÃ­der y eliminar la misiÃ³n de su queue
        var lvr = await sbClient.from('villages').select('id,x,y,state').eq('id', leaderVillageId).maybeSingle();
        if (!lvr.error && lvr.data) {
          var lvState = typeof lvr.data.state === 'string' ? JSON.parse(lvr.data.state) : lvr.data.state;
          var mObj = (lvState.mission_queue || []).find(function (q) { return q.mid === missionId; });
          if (mObj) {
            // Devolver propias tropas al lÃ­der
            var lMinSpd = 999;
            Object.keys(mObj.troops || {}).forEach(function (k) {
              var td = TROOP_TYPES[k] || CREATURE_TYPES[k];
              if ((mObj.troops[k]||0) > 0 && td && td.speed < lMinSpd) lMinSpd = td.speed;
            });
            if (lMinSpd === 999) lMinSpd = 1;
            var lDist = Math.max(Math.abs(mObj.tx - lvr.data.x), Math.abs(mObj.ty - lvr.data.y));
            var lSecs = Math.ceil((lDist / lMinSpd) * MISSION_FACTOR);
            // Eliminar misiÃ³n de ataque y crear retorno
            lvState.mission_queue = (lvState.mission_queue || []).filter(function (q) { return q.mid !== missionId; });
            if (Object.values(mObj.troops || {}).some(function (n) { return n > 0; })) {
              lvState.mission_queue.push({
                type: 'return', tx: lvr.data.x, ty: lvr.data.y, troops: mObj.troops, loot: {},
                finish_at: new Date(Date.now() + lSecs * 1000).toISOString(), start_at: new Date().toISOString()
              });
            }
            // Devolver tropas de cada aliado
            for (var ci = 0; ci < (mObj.guest_contingents || []).length; ci++) {
              var c = mObj.guest_contingents[ci];
              if (!Object.values(c.troops || {}).some(function (n) { return n > 0; })) continue;
              var origVR = await sbClient.from('villages').select('id,x,y,state').eq('id', c.origin_village_id).maybeSingle();
              if (origVR.error || !origVR.data) continue;
              var ov = origVR.data;
              var ovState = typeof ov.state === 'string' ? JSON.parse(ov.state) : ov.state;
              var aMinSpd = 999;
              Object.keys(c.troops).forEach(function (k) {
                var td = TROOP_TYPES[k] || CREATURE_TYPES[k];
                if ((c.troops[k]||0) > 0 && td && td.speed < aMinSpd) aMinSpd = td.speed;
              });
              if (aMinSpd === 999) aMinSpd = 1;
              var aDist = Math.max(Math.abs(mObj.tx - ov.x), Math.abs(mObj.ty - ov.y));
              var aSecs = Math.ceil((aDist / aMinSpd) * MISSION_FACTOR);
              if (!ovState.mission_queue) ovState.mission_queue = [];
              ovState.mission_queue.push({
                type: 'return_reinforce', tx: ov.x, ty: ov.y, troops: c.troops,
                finish_at: new Date(Date.now() + aSecs * 1000).toISOString(), start_at: new Date().toISOString()
              });
              await sbClient.from('villages').update({ state: JSON.stringify(ovState) }).eq('id', ov.id);
            }
            await sbClient.from('villages').update({ state: JSON.stringify(lvState) }).eq('id', lvr.data.id);
          }
        }
        await sbClient.from('active_missions').delete().eq('mission_id', missionId);
        showNotif('âš”ï¸ Ataque conjunto cancelado. Tropas regresando.', 'ok');
        if (activeVillage && activeVillage.id === leaderVillageId) await flushVillage();
        tick();
      } catch (e) {
        console.error('cancelAlliedMission error:', e);
        showNotif('Error cancelando misiÃ³n: ' + (e.message || e), 'err');
      }
    }

    function _returnTroopsHome(m) {
      // Encola retorno inmediato de las tropas
      if (!activeVillage) return;
      var dist = Math.max(Math.abs((m.tx || 0) - activeVillage.x), Math.abs((m.ty || 0) - activeVillage.y));
      var minSpeed = 1;
      Object.keys(m.troops || {}).forEach(function (k) {
        var td = TROOP_TYPES[k] || CREATURE_TYPES[k];
        if ((m.troops[k] || 0) > 0 && td) minSpeed = Math.min(minSpeed, td.speed || 1);
      });
      var secs = Math.ceil((dist / minSpeed) * MISSION_FACTOR);
      activeVillage.state.mission_queue.push({
        type: 'return', tx: activeVillage.x, ty: activeVillage.y,
        troops: m.troops, loot: {},
        finish_at: new Date(Date.now() + secs * 1000).toISOString(),
        start_at: new Date().toISOString()
      });
    }

    // updateObjective definida mÃ¡s abajo (Ãºnica versiÃ³n â€” upsert)

    function resolveQueue(vs) {
      if (!vs.build_queue) return vs;

      var finishAt = new Date(vs.build_queue.finish_at).getTime();
      if (Date.now() >= finishAt) {
        var id = vs.build_queue.id;

        // UPGRADE BUILDING
        if (!vs.buildings[id]) vs.buildings[id] = { level: 1 };
        else vs.buildings[id].level++;

        vs.build_queue = null;

        var def = BUILDINGS.find(function (b) { return b.id === id; });
        showNotif((def ? def.name : id) + ' mejorada!', 'ok');

        // âš ï¸ CRITICAL: Save changes removed from here to avoid side-effects.
        // Caller (tick or loadMyVillages) MUST check if queue changed and save.
      }
      return vs;
    }

    // ============================================================
    // USERNAME (EPIC WARRIOS V2)
    // Reglas:
    // - 4 a 15 caracteres
    // - Solo letras, numeros, "_" y "-"
    // - Debe ser unico
    // - Bloqueo por lista de terminos prohibidos (tabla banned_terms)
    // Nota: el backend (RLS/constraints o Edge Function) debe ser la autoridad final.
    // ============================================================
    function normUsername(u) {
      return (u || '')
        .trim()
        .toLowerCase()
        .normalize('NFD').replace(/[\u0300-\u036f]/g, '') // sin acentos
        .replace(/[^a-z0-9_-]/g, '') // solo permitido
        .replace(/([a-z0-9_-])\1{2,}/g, '$1$1') // colapsa repeticiones largas (aaaa->aa)
        ;
    }
    function isUsernameShapeValid(raw) {
      if (!raw) return { ok: false, msg: 'Escribe un nombre de usuario.' };
      if (raw.length < 4 || raw.length > 15) return { ok: false, msg: 'Debe tener entre 4 y 15 caracteres.' };
      if (!/^[A-Za-z0-9_-]+$/.test(raw)) return { ok: false, msg: 'Solo letras, numeros, "_" y "-".' };
      return { ok: true, msg: '' };
    }
    function setUserMsg(t, type) {
      var el = document.getElementById('userMsg');
      if (!el) return;
      el.textContent = t || '';
      el.className = 'auth-msg ' + (type || '');
    }
    async function fetchBannedTerms() {
      // Mantener pequeÃ±o: en prod, cachea y pagina si hace falta
      var r = await sbClient.from('banned_terms').select('term').limit(1000);
      if (r.error || !r.data) return [];
      return r.data.map(function (x) { return String(x.term || '').toLowerCase(); }).filter(Boolean);
    }
    async function isUsernameBanned(normalized) {
      // Comprueba si contiene cualquier termino prohibido
      // (Esto detecta muchos "derivados" simples porque normalizamos antes)
      var terms = await fetchBannedTerms();
      for (var i = 0; i < terms.length; i++) {
        var t = terms[i];
        if (t && normalized.includes(t)) return true;
      }
      return false;
    }
    async function isUsernameAvailable(normalized) {
      var r = await sbClient.from('profiles').select('id').eq('normalized_username', normalized).limit(1);
      if (r.error) return { ok: false, msg: 'No se pudo comprobar disponibilidad.' };
      if (r.data && r.data.length > 0) return { ok: false, msg: 'Ese nombre ya existe.' };
      return { ok: true, msg: '' };
    }

    // ============================================================
    // AUTH
    // ============================================================
    function switchTab(tab) {
      document.getElementById('tabL').style.display = tab === 'login' ? 'block' : 'none';
      document.getElementById('tabR').style.display = tab === 'register' ? 'block' : 'none';
      document.getElementById('btnTL').classList.toggle('active', tab === 'login');
      document.getElementById('btnTR').classList.toggle('active', tab === 'register');
      setMsg('', '');
    }
    function setMsg(t, type) { var el = document.getElementById('authMsg'); el.textContent = t; el.className = 'auth-msg ' + type; }

    // Username live check (solo UX; el backend manda)
    var userCheckTimer = null;
    async function onUserInput() {
      var raw = (document.getElementById('rUser') || {}).value || '';
      setUserMsg('', '');
      var shape = isUsernameShapeValid(raw);
      if (!shape.ok) { setUserMsg(shape.msg, 'err'); return; }
      var normalized = normUsername(raw);
      clearTimeout(userCheckTimer);
      userCheckTimer = setTimeout(async function () {
        setUserMsg('Comprobando...', '');
        if (await isUsernameBanned(normalized)) { setUserMsg('Nombre no permitido.', 'err'); return; }
        setUserMsg(av.ok ? 'Disponible âœ…' : 'No disponible âŒ', av.ok ? 'ok' : 'err');
      }, 250);
    }

    // ============================================================
    // AUTH & NETWORK
    // ============================================================

    // ============================================================
    // AUTH & NETWORK
    // ============================================================

    async function doLogin() {
      const email = document.getElementById('lEmail').value.trim();
      const pass = document.getElementById('lPass').value;
      if (!email || !pass) { setMsg('Rellena email y contraseÃ±a.', 'err'); return; }

      document.getElementById('lBtn').disabled = true;
      document.getElementById('lBtn').textContent = 'Conectando...';

      const { data, error } = await sbClient.auth.signInWithPassword({ email, password: pass });

      if (error) {
        setMsg('Error: ' + error.message, 'err');
        document.getElementById('lBtn').disabled = false;
        document.getElementById('lBtn').textContent = 'Entrar';
        return;
      }

      currentUser = data.user;
      document.getElementById('authScreen').style.display = 'none';
      document.getElementById('gameWrapper').classList.add('visible');
      await initGame();
    }

    async function doRegister() {
      const userRaw = (document.getElementById('rUser').value || '').trim();
      const email = document.getElementById('rEmail').value.trim();
      const pass = document.getElementById('rPass').value;

      if (!userRaw) { setUserMsg('El nombre de usuario es obligatorio.', 'err'); return; }
      if (!email || !pass) { setMsg('Rellena email y contraseÃ±a.', 'err'); return; }
      if (pass.length < 6) { setMsg('La contraseÃ±a debe tener al menos 6 caracteres.', 'err'); return; }

      document.getElementById('rBtn').disabled = true;
      document.getElementById('rBtn').textContent = 'Creando cuenta...';

      // 1. Sign Up
      const { data, error } = await sbClient.auth.signUp({
        email,
        password: pass,
        options: { data: { username: userRaw } }
      });

      if (error) {
        setMsg('Error: ' + error.message, 'err');
        document.getElementById('rBtn').disabled = false;
        document.getElementById('rBtn').textContent = 'Crear Cuenta';
        return;
      }

      if (data.session) {
        currentUser = data.user;
        document.getElementById('authScreen').style.display = 'none';
        document.getElementById('gameWrapper').classList.add('visible');
        // Ensure profile exists (trigger might have failed or be slow)
        await ensureProfile(currentUser.id, userRaw);
        await initGame();
      } else {
        setMsg('Revisa tu email para confirmar o inicia sesiÃ³n.', 'ok');
        switchTab('login');
        document.getElementById('lEmail').value = email;
        document.getElementById('rBtn').disabled = false;
        document.getElementById('rBtn').textContent = 'Crear Cuenta';
      }
    }

    async function ensureProfile(uid, username) {
      // Just in case the trigger didn't fire or we want to force username
      await sbClient.from('profiles').upsert({ id: uid, username: username }, { onConflict: 'id' });
    }

    async function getMyPlayerData() {
      if (!currentUser) return null;
      try {
        // Try full select first (requires migration columns to exist)
        const { data, error } = await sbClient
          .from('profiles')
          .select('id, username, experience, role, military_score, alliance_tag, battles_won_pvp, battles_lost_pvp, battles_won_npc, troop_levels, weapon_levels, armor_levels')
          .eq('id', currentUser.id)
          .single();
        if (!error) return data;
        // Fallback: columns may not exist yet â€” fetch only guaranteed columns
        console.warn('getMyPlayerData full select failed, trying fallback:', error.message);
        const { data: d2, error: e2 } = await sbClient
          .from('profiles')
          .select('id, username, role')
          .eq('id', currentUser.id)
          .single();
        if (e2) { console.warn('getMyPlayerData fallback error:', e2.message); return null; }
        return { ...d2, experience: 0, military_score: 0, alliance_tag: null };
      } catch (e) {
        console.warn('getMyPlayerData exception:', e);
        return null;
      }
    }

    async function doLogout() {
      await flushVillage();
      // Clean up local state
      if (typeof realtimeChannel !== 'undefined' && realtimeChannel) {
        sbClient.removeChannel(realtimeChannel);
        realtimeChannel = null;
      }
      await sbClient.auth.signOut();
      currentUser = null;
      myVillages = [];
      activeVillage = null;
      activeVillageId = null;
      rankingCache = null;
      clearInterval(uiTimer);
      clearInterval(autoSaveTimer);
      document.getElementById('gameWrapper').classList.remove('visible');
      document.getElementById('authScreen').style.display = 'flex';
      location.reload(); // Hard reload to ensure clean slate
    }


    async function initGame() {
      if (!currentUser) return;

      // 1. Ensure profile exists and get it
      let myName = (currentUser.email || '').split('@')[0];
      await ensureProfile(currentUser.id, myName);

      const profile = await getMyPlayerData();
      myName = profile?.username || myName;
      const myXP = profile?.experience || 0;
      // Guardar stats de batallas en variable global para inyectar en state tras loadMyVillages
      window._profileBattles = {
        battles_won_pvp:  profile?.battles_won_pvp  || 0,
        battles_lost_pvp: profile?.battles_lost_pvp || 0,
        battles_won_npc:  profile?.battles_won_npc  || 0
      };

      const elUser = document.getElementById('ovUser');
      if (elUser) elUser.textContent = myName;
      const elXP = document.getElementById('ovExperience');
      if (elXP) elXP.textContent = formatNumber(myXP);
      const elTop = document.getElementById('topbarUsername');
      if (elTop) elTop.textContent = myName;

      try {
        await loadMyVillages();
        await loadPlayerObjectives();

        if (myVillages.length === 0) {
          await createFirstVillage();
          // Reload to get the fresh full data structure
          await loadMyVillages();
        }

        if (myVillages.length === 0) {
          showNotif('Error: No se pudo cargar ninguna aldea.', 'err');
          return;
        }

        // Select first village by default
        activeVillage = myVillages[0]; // Object ref

        // Inyectar contadores de batallas desde profiles en el state
        if (window._profileBattles && activeVillage && activeVillage.state) {
          activeVillage.state.battles_won_pvp  = window._profileBattles.battles_won_pvp;
          activeVillage.state.battles_lost_pvp = window._profileBattles.battles_lost_pvp;
          activeVillage.state.battles_won_npc  = window._profileBattles.battles_won_npc;
        }

        // Refresh UI
        populateVillageSel();
        // Usar _initSwitch para no pisar el sessionStorage durante el arranque
        window._suppressSessionSave = true;
        switchVillage(activeVillage.id);
        window._suppressSessionSave = false;

      } catch (e) {
        console.error('initGame error:', e);
        showNotif('Error crÃ­tico al iniciar juego.', 'err');
        return;
      }

      // Start Loops
      clearInterval(uiTimer);
      uiTimer = setInterval(tick, 1000);
      clearInterval(autoSaveTimer);
      // autoSaveTimer y processRecalls: eliminados. Modelo evento-reactivo puro.
      // El guardado ocurre en scheduleSave() tras acciones del jugador.
      // processRecalls se llama una vez al login en initGame.

      if (typeof resetUiAnimation === 'function') resetUiAnimation();
      if (typeof ensureUiAnim === 'function') ensureUiAnim();

      if (typeof loadAllVillages === 'function') loadAllVillages();
      // Cargar estado de alianza para el overview (sin bloquear)
      refreshMyAlliance().catch(function () { });

      // â”€â”€ One-shot al login: Ãºnica ronda de red â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      checkIncomingAttacks();
      updateLastSeen();
      updateOnlineCount();
      processRecalls();
      updateUnreadCount(); // Actualizar badge de mensajes no leÃ­dos

      // Mostrar/ocultar botÃ³n admin segÃºn email del usuario autenticado
      checkAdminButton();

      tick();
      showNotif('Â¡Bienvenido, comandante!', 'ok');
      checkAndShowMOTD();

      if (isAdmin()) {
        showNotif('ğŸ”’ Modo Admin Detectado', 'accent');
      }

      // Restaurar posiciÃ³n tras F5 (sessionStorage)
      // Espera 200ms para que initGame termine del todo antes de restaurar
      setTimeout(function restoreSession(attempts) {
        try {
          var lastVillage = sessionStorage.getItem('EW_lastVillage');
          var lastPage = sessionStorage.getItem('EW_lastPage');
          if (!lastVillage && !lastPage) return; // nada que restaurar

          if (myVillages.length === 0 && attempts < 50) {
            return setTimeout(function () { restoreSession(attempts + 1); }, 100);
          }

          if (lastVillage && myVillages.find(function (v) { return v.id === lastVillage; })) {
            window._suppressSessionSave = true;  // no pisar el valor al restaurar
            switchVillage(lastVillage);
            window._suppressSessionSave = false;
          }
          if (lastPage && lastPage !== 'overview') {
            var navEl = document.querySelector('.nav-item[onclick*="\'' + lastPage + '\'"]');
            showPage(lastPage, navEl);
          }
          var cx = sessionStorage.getItem('EW_camX');
          var cy = sessionStorage.getItem('EW_camY');
          if (cx && cy) { mapCamX = parseInt(cx); mapCamY = parseInt(cy); }
        } catch (e) { console.warn('restoreSession error:', e); }
      }, 200);
    }

    // ============================================================
    // OBJECTIVES
    // ============================================================
    async function loadPlayerObjectives() {
      if (!currentUser) return;
      try {
        const { data } = await sbClient.from('player_objectives').select('*').eq('user_id', currentUser.id);
        if (data) playerObjectives = data;
      } catch (e) { }
    }

    async function updateObjective(id, status) {
      if (!currentUser) return;
      try {
        await sbClient.from('player_objectives').upsert({ user_id: currentUser.id, objective_id: id, status: status, last_interaction: new Date().toISOString() });
        await loadPlayerObjectives();
        renderMap();
      } catch (e) { }
    }

    // ============================================================
    // VILLAGES & DATA MAPPING
    // ============================================================
    async function loadMyVillages() {
      // We need to fetch villages AND their resources/buildings/troops to construct the "state" object
      // expected by the game engine.

      // 1. Fetch Villages â€” columnas reales: id, owner_id, name, cx, cy, build_queue, mission_queue, summoning_queue, training_queue, last_aldeano_at, created_at
      const { data: villages, error: vErr } = await sbClient.from('villages')
        .select('id, owner_id, name, cx, cy, build_queue, mission_queue, summoning_queue, training_queue, last_aldeano_at, created_at')
        .eq('owner_id', currentUser.id)
        .order('created_at', { ascending: true });

      if (vErr) { console.error('Error fetching villages:', vErr); throw vErr; }


      if (!villages || villages.length === 0) {
        myVillages = [];
        return;
      }

      // 2. Fetch related data for ALL villages
      const loaded = [];

      for (const v of villages) {
        // Fetch Resources (Using maybeSingle to avoid 406 error if none found)
        let { data: res, error: rErr } = await sbClient.from('resources').select('*').eq('village_id', v.id).maybeSingle();
        if (rErr) console.warn('Error loading resources for village', v.id, rErr);

        // SELF-HEALING: If resources missing, create default
        if (!res) {
          const defRes = { village_id: v.id, madera: 500, piedra: 300, hierro: 100, prov: 0, esencia: 0 };
          const { data: newRes, error: insErr } = await sbClient.from('resources').insert(defRes).select().single();
          if (!insErr) res = newRes;
          else {
            console.error('Failed to self-heal resources:', insErr);
            res = defRes; // Fallback to memory object
          }
        }

        let { data: blds, error: bErr } = await sbClient.from('buildings').select('*').eq('village_id', v.id).maybeSingle();
        if (bErr) console.warn('Error loading buildings for village', v.id, bErr);

        // SELF-HEALING: If buildings missing
        if (!blds) {
          const defBlds = { village_id: v.id, aserradero: 1, cantera: 1, minehierro: 1, granja: 1, almacen: 1, torre: 1, barracas: 1, circulo: 0, reclutamiento: 0, muralla: 0, lab: 0 };
          const { data: newBlds, error: insErr } = await sbClient.from('buildings').insert(defBlds).select().single();
          if (!insErr) blds = newBlds;
          else {
            console.error('Failed to self-heal buildings:', insErr);
            blds = defBlds;
          }
        }

        let { data: trp, error: tErr } = await sbClient.from('troops').select('*').eq('village_id', v.id).maybeSingle();
        if (tErr) console.warn('Error loading troops for village', v.id, tErr);

        // SELF-HEALING: If troops missing
        if (!trp) {
          const defTrp = { village_id: v.id };
          Object.keys(TROOP_TYPES).forEach(k => {
            defTrp[k] = (k === 'aldeano' ? 50 : 0);
          });
          const { data: newTrp, error: insErr } = await sbClient.from('troops').insert(defTrp).select().single();
          if (!insErr) trp = newTrp;
          else {
            console.error('Failed to self-heal troops:', insErr);
            trp = defTrp;
          }
        }

        let { data: crs, error: cErr } = await sbClient.from('creatures').select('*').eq('village_id', v.id).maybeSingle();
        if (cErr) console.warn('Error loading creatures for village', v.id, cErr);

        // SELF-HEALING: If creatures missing
        if (!crs) {
          const defCrs = { village_id: v.id };
          Object.keys(CREATURE_TYPES).forEach(k => {
            defCrs[k] = 0;
          });
          const { data: newCrs, error: insErr } = await sbClient.from('creatures').insert(defCrs).select().single();
          if (!insErr) crs = newCrs;
          else {
            console.error('Failed to self-heal creatures:', insErr);
            crs = defCrs;
          }
        }


        // If data is missing (maybe insert failed too), try to recover using defaults so the game doesn't break
        const safeRes = res || { madera: 500, piedra: 300, hierro: 100, prov: 0, esencia: 0 };
        const safeBlds = blds || { aserradero: 1, cantera: 1, minehierro: 1, granja: 1, almacen: 1, torre: 1, barracas: 1, circulo: 0, reclutamiento: 0, muralla: 0, lab: 0, torreinvocacion: 0 };
        const safeTrp = trp || {}; // Si no hay fila de troops, empezar en 0 â€” no hardcodear 50

        // MAPPING: SQL -> Game State JSON
        const state = {
          resources: {
            madera: Number(safeRes.madera) || 0,
            piedra: Number(safeRes.piedra) || 0,
            hierro: Number(safeRes.hierro) || 0,
            provisiones: Number(safeRes.prov) || 0,
            esencia: Number(safeRes.esencia) || 0,
            aldeanos: 0
          },
          aldeanos_assigned: {
            madera: Number(safeRes.w_madera) || 0,
            piedra: Number(safeRes.w_piedra) || 0,
            hierro: Number(safeRes.w_hierro) || 0,
            provisiones: Number(safeRes.w_prov) || 0,
            esencia: Number(safeRes.w_esencia) || 0
          },
          // v0.17 â€” mapa completo de tropas desde DB
          troops: {},
          buildings: {},
          build_queue: v.build_queue || null,
          mission_queue: (v.mission_queue || []).filter(function (m) {
            // Descartar solo misiones con finish_at hace mÃ¡s de 7 dÃ­as (corruptas)
            var ft = m.finish_at ? new Date(m.finish_at).getTime() : 0;
            return (Date.now() - ft) < 7 * 24 * 3600 * 1000;
          }),
          summoning_queue: (v.summoning_queue || []),
          training_queue: (v.training_queue || []).filter(function (t) {
            var ft = t.finish_at ? new Date(t.finish_at).getTime() : 0;
            return (Date.now() - ft) < 7 * 24 * 3600 * 1000;
          }),
          last_updated: safeRes.last_update || new Date().toISOString(),
          last_aldeano_at: v.last_aldeano_at || null, // timer discreto de aldeanos
          // Legacy/Compat flags
          _aldeanos_total_mode: true,
          owner_name: currentUser.email
        };

        Object.keys(TROOP_TYPES).forEach(k => {
          state.troops[k] = Number(safeTrp[k]) || 0;
        });
        state.resources.aldeanos = state.troops.aldeano || 0;

        // Map creatures from DB
        state.creatures = {};
        const safeCrs = crs || {};
        Object.keys(CREATURE_TYPES).forEach(k => {
          state.creatures[k] = Number(safeCrs[k]) || 0;
        });


        // Map buildings flat columns -> nested objects
        // Columns: aserradero, cantera, etc.
        // bldKeys derivado de BUILDINGS â€” aÃ±adir edificio nuevo solo en BUILDINGS[]
        const bldKeys = BUILDINGS.map(b => b.id);
        // Edificios activos desde nivel 1 (starter); el resto arrancan en 0 (no construidos)
        const starterBlds = ['aserradero', 'cantera', 'minehierro', 'granja', 'almacen', 'torre', 'barracas'];
        bldKeys.forEach(k => {
          var raw = safeBlds[k];
          // Si la columna existe en DB, usar ese valor. Si no existe aÃºn (edificio nuevo), defaultear correctamente.
          var lvl = (raw !== undefined && raw !== null) ? Number(raw) : (starterBlds.includes(k) ? 1 : 0);
          state.buildings[k] = { level: lvl };
        });

        // Attach state to village object
        v.state = state;
        v.x = Number(v.cx); v.y = Number(v.cy); // Ensure numbers

        // IMMEDIATE OFFLINE PROGRESSION:
        // Check if a building finished while we were offline
        if (v.state.build_queue) {
          const oldQ = JSON.stringify(v.state.build_queue);
          v.state = resolveQueue(v.state);
          const newQ = JSON.stringify(v.state.build_queue);

          if (oldQ !== newQ) {
            // We use the new generic save helper
            await saveVillage(v);
          }
        }

        loaded.push(v);
      }

      myVillages = loaded;
    }

    async function loadAllVillages() {
      // Cargar TODAS las aldeas del mapa (para el mapa global)
      // FIX: 'state' and 'user_id' do not exist in schema. Use 'owner_id'.
      // We don't have 'state' column in villages, so we can't show points/score yet unless we join resources.
      var r = await sbClient.from('villages').select('id, owner_id, name, cx, cy');
      if (r.error) { console.error('Error loading world:', r.error); return; }
      if (r.data) {
        allVillages = r.data.map(function (v) {
          v.x = Number(v.cx); v.y = Number(v.cy); // Ensure numbers
          return v;
        });
      }
    }

    function populateVillageSel() {
      var sel = document.getElementById('villageSel');
      if (!sel) return;
      sel.innerHTML = '';
      myVillages.forEach(function (v) {
        var o = document.createElement('option');
        o.value = v.id;
        o.textContent = v.name + ' [' + v.x + ',' + v.y + ']';
        sel.appendChild(o);
      });
      if (activeVillage) sel.value = activeVillage.id;
    }

    function switchVillage(id) {
      var v = myVillages.find(function (v) { return v.id === id; });
      if (v) {
        activeVillage = v;
        mapCamX = null;
        mapCamY = null;
        resetUiAnimation();
        var sel = document.getElementById('villageSel');
        if (sel) sel.value = v.id;
        // Guardar aldea seleccionada para restaurar tras F5 (no durante arranque)
        if (!window._suppressSessionSave) { try { sessionStorage.setItem('EW_lastVillage', v.id); } catch (e) { } }
        tick();
        // Re-renderizar la pÃ¡gina activa si es sensible a la aldea seleccionada
        var activePage = document.querySelector('.page.active');
        if (activePage) {
          var pid = activePage.id;
          if (pid === 'page-recursos') { renderRecursos && renderRecursos(); }
          if (pid === 'page-buildings') { renderBuildings && renderBuildings(calcRes(activeVillage.state)); }
          if (pid === 'page-fleet') { renderTroops && renderTroops(); renderTrainingQueue && renderTrainingQueue(); }
          if (pid === 'page-creatures') { renderCreatures && renderCreatures(); renderSummoningQueue && renderSummoningQueue(); }
          if (pid === 'page-map') { renderMap && renderMap(); }
          if (pid === 'page-overview') { renderReinforcementsPanel && renderReinforcementsPanel(); }
        }
      }
    }

    function getWorkerSum(w) {
      if (!w) return 0;
      return (w.madera || 0) + (w.piedra || 0) + (w.hierro || 0) + (w.provisiones || 0) + (w.esencia || 0);
    }

    async function createFirstVillage() {
      showNotif('Fundando primera colonia...', 'ok');

      let cx, cy;
      let found = false;
      for (let i = 0; i < 100; i++) {
        cx = Math.floor(Math.random() * MAP_SIZE);
        cy = Math.floor(Math.random() * MAP_SIZE);
        // Simple check (collisions will fail on insert unique constraint)
        const { error } = await sbClient.from('villages').select('id').eq('cx', cx).eq('cy', cy).single();
        if (error) { found = true; break; } // Assuming error means "not found" (good)
      }

      const vName = 'Aldea 1';

      // Insert Village
      const { data: v, error: err } = await sbClient.from('villages').insert({
        owner_id: currentUser.id,
        name: vName,
        cx: cx,
        cy: cy,
        build_queue: null
      }).select().single();

      if (err) { throw new Error(err.message); }

      // Insert Related
      await sbClient.from('resources').insert({ village_id: v.id });
      // NEW: Start everything at Level 1
      await sbClient.from('buildings').insert({
        village_id: v.id,
        aserradero: 1, cantera: 1, minehierro: 1, granja: 1, almacen: 1, torre: 1, barracas: 1, circulo: 1, reclutamiento: 1, muralla: 0, lab: 0
      });
      const initialTroops = { village_id: v.id };
      Object.keys(TROOP_TYPES).forEach(k => {
        initialTroops[k] = (k === 'aldeano' ? 50 : 0);
      });
      await sbClient.from('troops').insert(initialTroops);
    }

    // Generic save function for ANY village (not just active)
    async function saveVillage(v) {
      if (!v || !currentUser) return;

      // Snapshot: calcular recursos actuales antes de guardar
      // Esto asegura que guardamos el valor real acumulado, no el del Ãºltimo tick
      snapshotResources(v.state);

      const s = v.state;
      const w = s.aldeanos_assigned || {};
      // 1. Update Resources
      const { error: rErr } = await sbClient.from('resources').update({
        madera: s.resources.madera,
        piedra: s.resources.piedra,
        hierro: s.resources.hierro,
        prov: s.resources.provisiones,
        esencia: s.resources.esencia,
        w_madera: (s.aldeanos_assigned && s.aldeanos_assigned.madera) || 0,
        w_piedra: (s.aldeanos_assigned && s.aldeanos_assigned.piedra) || 0,
        w_hierro: (s.aldeanos_assigned && s.aldeanos_assigned.hierro) || 0,
        w_prov: (s.aldeanos_assigned && s.aldeanos_assigned.provisiones) || 0,
        w_esencia: (s.aldeanos_assigned && s.aldeanos_assigned.esencia) || 0,
        last_update: new Date().toISOString()
      }).eq('village_id', v.id);

      if (rErr) throw rErr;

      // 2. Update Buildings
      const bUpd = {};
      for (let k in s.buildings) { bUpd[k] = s.buildings[k].level; }
      const { error: bErr } = await sbClient.from('buildings').update(bUpd).eq('village_id', v.id);
      if (bErr) {
        console.error('Buildings save error:', bErr);
        throw bErr;
      }

      // 3. Update Troops â€” all types
      const trpUpd = {};
      const trps = s.troops || defaultTroops();
      Object.keys(TROOP_TYPES).forEach(function (k) { trpUpd[k] = trps[k] || 0; });
      // Sync aldeanos: el total real de aldeanos en barracas se guarda en troops.aldeano.
      // resources.aldeanos es la fuente de verdad en memoria â€” actualizamos troops para que coincida.
      // Usamos una asignaciÃ³n directa sin ||, para que aldeano=0 sea un valor vÃ¡lido y no se sobreescriba.
      trpUpd.aldeano = (s.resources.aldeanos !== undefined && s.resources.aldeanos !== null)
        ? Math.max(0, Math.floor(s.resources.aldeanos))
        : (trps.aldeano || 0);
      // Mantener sincronizado el estado en memoria tambiÃ©n
      s.troops.aldeano = trpUpd.aldeano;
      await sbClient.from('troops').update(trpUpd).eq('village_id', v.id);

      // 4b. Actualizar military_score â€” suma TODAS las aldeas + criaturas del jugador
      try {
        const allVils = await sbClient.from('villages').select('id').eq('owner_id', currentUser.id);
        if (!allVils.error && allVils.data && allVils.data.length > 0) {
          const vilIds = allVils.data.map(vv => vv.id);
          const allTrps = await sbClient.from('troops').select('*').in('village_id', vilIds);
          const allCrs = await sbClient.from('creatures').select('*').in('village_id', vilIds);
          let grandTotal = 0;
          if (!allTrps.error && allTrps.data) {
            allTrps.data.forEach(row => { Object.keys(TROOP_TYPES).forEach(k => { grandTotal += (Number(row[k]) || 0); }); });
          }
          if (!allCrs.error && allCrs.data) {
            allCrs.data.forEach(row => { Object.keys(CREATURE_TYPES).forEach(k => { grandTotal += (Number(row[k]) || 0); }); });
          }
          await sbClient.from('profiles').update({ military_score: grandTotal }).eq('id', currentUser.id);
        }
      } catch (e) { console.warn('military_score update failed', e); }

      // 4c. Update Creatures
      const crUpd = {};
      const crs = s.creatures || defaultCreatures();
      Object.keys(CREATURE_TYPES).forEach(function (k) { crUpd[k] = crs[k] || 0; });
      await sbClient.from('creatures').update(crUpd).eq('village_id', v.id);

      // 4. Update Village (Queue, Missions, Name, aldeano timer, summoning queue, training queue)
      await sbClient.from('villages').update({
        build_queue: s.build_queue,
        mission_queue: s.mission_queue || [],
        summoning_queue: s.summoning_queue || [],
        training_queue: s.training_queue || [],
        name: v.name,
        last_aldeano_at: s.last_aldeano_at || null
      }).eq('id', v.id);
    }

    async function flushVillage() {
      if (!activeVillage) return;
      if (isFlushing) { pendingFlush = true; return; }

      isFlushing = true;
      setSave('saving');

      try {
        await saveVillage(activeVillage);
        setSave('saved');
      } catch (e) {
        console.error('Save error details:', e);
        if (e.message) console.error('Message:', e.message);
        setSave('error');
        showNotif('Error guardando: ' + e.message, 'err');
      } finally {
        isFlushing = false;
        if (pendingFlush) {
          pendingFlush = false;
          flushVillage();
        }
      }
    }

    var saveDebounce = null;
    var modalBuildingId = null; // tracks which building is open in modal
    function scheduleSave() {
      clearTimeout(saveDebounce);
      saveDebounce = setTimeout(flushVillage, 2000);
    }

    function setSave(s) {
      var dot = document.getElementById('saveDot');
      var txt = document.getElementById('saveTxt');
      dot.className = 'save-dot ' + s;
      txt.textContent = s === 'saving' ? 'guardando...' : s === 'saved' ? 'guardado' : '';
    }


    // ============================================================
    // UI ANIMATION â€” nÃºmeros que suben y bajan suave (tipo barra)
    // ============================================================
    let uiShown = null;
    let uiTarget = null;
    let uiAnimStarted = false;

    // Cache de elementos DOM frecuentes â€” evita querySelector 60 veces/segundo
    let _elCache = {};
    function _el(id) {
      if (!_elCache[id]) _elCache[id] = document.getElementById(id);
      return _elCache[id];
    }

    function resetUiAnimation() {
      uiShown = { madera: 0, piedra: 0, hierro: 0, provisiones: 0, esencia: 0, aldeanos: 0, capPctMa: 0, capPctPi: 0, capPctHi: 0, capPctPr: 0, capPctEs: 0, capPctAld: 0 };
      uiTarget = null;
    }

    function ensureUiAnim() {
      // AnimaciÃ³n desactivada temporalmente â€” los valores se muestran directos desde calcRes()
      // para garantizar que lo que se ve es exactamente lo que hay en estado.
      // Reactivar cuando el sistema de producciÃ³n estÃ© verificado.
      if (uiAnimStarted) return;
      uiAnimStarted = true;
      function step() {
        if (uiShown && uiTarget) {
          // Sin lerp: copiamos target directamente a shown
          var keys = ['madera', 'piedra', 'hierro', 'provisiones', 'esencia', 'aldeanos', 'capPctMa', 'capPctPi', 'capPctHi', 'capPctPr', 'capPctEs', 'capPctAld'];
          keys.forEach(function (key) { uiShown[key] = uiTarget[key]; });
          renderAnimatedUi();
        }
        requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
    }

    function renderAnimatedUi() {
      if (!activeVillage || !uiShown) return;
      var vs = activeVillage.state;
      var aldGranja = vs.aldeanos_granja || 0;
      var barrCap = getBarracksCapacity(vs.buildings);
      var cap = getCapacity(vs.buildings);

      var madera = Math.round(uiShown.madera || 0);
      var piedra = Math.round(uiShown.piedra || 0);
      var hierro = Math.round(uiShown.hierro || 0);
      var prov = Math.round(uiShown.provisiones || 0);
      var esencia = Math.round(uiShown.esencia || 0);
      var aldLibres = Math.round(uiShown.aldeanos || 0);

      var stored = Math.round(uiShown.stored || 0);
      var capPct = Math.max(0, Math.min(100, uiShown.capPct || 0));

      // Topbar â€” valores
      _el('rMadera').textContent = fmt(madera);
      _el('rPiedra').textContent = fmt(piedra);
      _el('rHierro').textContent = fmt(hierro);
      _el('rProv').textContent = fmt(prov);
      _el('rEsencia').textContent = fmt(esencia);

      // Barras de capacidad individuales por recurso
      function setBar(id, pct, color) {
        var b = _el(id); if (!b) return;
        var cls = pct >= 100 ? 'full' : pct >= 80 ? 'warn' : 'ok';
        b.style.width = pct + '%';
        if (color) b.style.background = color;
        else b.className = 'cap-bar ' + cls;
      }
      setBar('capBarMa', uiShown.capPctMa || 0);
      setBar('capBarPi', uiShown.capPctPi || 0);
      setBar('capBarHi', uiShown.capPctHi || 0);
      setBar('capBarPr', uiShown.capPctPr || 0);
      setBar('capBarEs', uiShown.capPctEs || 0, 'var(--esencia)');
      setBar('capBarAld', uiShown.capPctAld || 0, 'var(--aldeanos)');

      // Overview â€” valores (pueden no existir si se rediseÃ±Ã³ la pÃ¡gina)
      if (_el('ovMadera')) _el('ovMadera').textContent = fmt(madera);
      if (_el('ovPiedra')) _el('ovPiedra').textContent = fmt(piedra);
      if (_el('ovHierro')) _el('ovHierro').textContent = fmt(hierro);
      if (_el('ovProv')) _el('ovProv').textContent = fmt(prov);
      if (_el('ovEsencia')) _el('ovEsencia').textContent = fmt(esencia);

      // Arriba: aldeanos libres. Abajo izq: total tropas en base. Abajo der: capacidad.
      var tropasEnBase = getBarracksUsed(vs); // todos los que estÃ¡n en base (no en misiÃ³n)
      _el('rAldeanos').textContent = aldLibres;
      if (_el('rTropasBase')) _el('rTropasBase').textContent = tropasEnBase;
      if (_el('rBarrCap')) _el('rBarrCap').textContent = '/ ' + barrCap;
      if (_el('ovAldeanos')) _el('ovAldeanos').textContent = aldLibres + ' libres / ' + aldGranja + ' en granja';
    }

    // ============================================================
    // UI TICK (every second)
    // ============================================================
    function tick() {
      if (!activeVillage) return;

      if (!activeVillage.state.build_queue) activeVillage.state.build_queue = null;
      var oldQ = activeVillage.state.build_queue ? JSON.stringify(activeVillage.state.build_queue) : null;
      if (!activeVillage.state.mission_queue) activeVillage.state.mission_queue = [];
      var oldM = JSON.stringify(activeVillage.state.mission_queue);
      if (!activeVillage.state.summoning_queue) activeVillage.state.summoning_queue = [];
      var oldS = JSON.stringify(activeVillage.state.summoning_queue);

      // â”€â”€ Colas locales â€” cero red â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      activeVillage.state = resolveQueue(activeVillage.state);
      activeVillage.state = resolveSummoningQueue(activeVillage.state);
      activeVillage.state = resolveTrainingQueue(activeVillage.state);

      // Si una cola local completÃ³ â†’ guardar
      var newQ2 = activeVillage.state.build_queue ? JSON.stringify(activeVillage.state.build_queue) : null;
      var newM2 = JSON.stringify(activeVillage.state.mission_queue || []);
      var newS2 = JSON.stringify(activeVillage.state.summoning_queue || []);
      if ((oldQ && !newQ2) || (oldM !== newM2) || (oldS !== newS2)) {
        scheduleSave();
      }

      // â”€â”€ resolveMissions â€” REACTIVO, no polling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Solo se lanza cuando el contador local de una misiÃ³n llega a cero.
      // NUNCA se llama en cada tick por defecto.
      var _nowMs2 = Date.now();
      var hasMissionDue = (activeVillage.state.mission_queue || []).some(function (m) {
        return m.finish_at && new Date(m.finish_at).getTime() <= _nowMs2;
      });
      if (hasMissionDue && !_missionWatchScheduled) {
        _missionWatchScheduled = true;
        resolveMissions(activeVillage.state).then(function (updated) {
          activeVillage.state = updated;
          _missionWatchScheduled = false;
          scheduleSave();
        }).catch(function () { _missionWatchScheduled = false; });
      }

      var vs = activeVillage.state;
      var w = vs.aldeanos_assigned || defaultAssignments();
      if (w.esencia === undefined) w.esencia = 0;
      var res = calcRes(vs);
      var prod = getProd(vs.buildings, 0, w);
      var cap = getCapacity(vs.buildings);
      // Porcentaje individual de cada recurso respecto al almacÃ©n
      var capPctMa = cap > 0 ? Math.min(100, Math.round(res.madera / cap * 100)) : 0;
      var capPctPi = cap > 0 ? Math.min(100, Math.round(res.piedra / cap * 100)) : 0;
      var capPctHi = cap > 0 ? Math.min(100, Math.round(res.hierro / cap * 100)) : 0;
      var capPctPr = cap > 0 ? Math.min(100, Math.round(res.provisiones / cap * 100)) : 0;
      var capPctEs = cap > 0 ? Math.min(100, Math.round(res.esencia / cap * 100)) : 0;
      var barrCapTick = getBarracksCapacity(vs.buildings);
      var aldEnBaseTick = Math.max(0, (vs.troops && vs.troops.aldeano) || 0);
      var capPctAld = barrCapTick > 0 ? Math.min(100, Math.round(aldEnBaseTick / barrCapTick * 100)) : 0;

      // v1.17: Actualizar display de barracas en el tick (para que refleje tropas en movimiento)
      var usedBarracas = getBarracksUsed(vs);
      var barrPctTick = barrCapTick > 0 ? Math.round(usedBarracas / barrCapTick * 100) : 0;
      var elCapTick = document.getElementById('recAldCap');
      if (elCapTick) elCapTick.textContent = usedBarracas + ' / ' + barrCapTick + ' (' + barrPctTick + '%)';

      // IMPORTANTE: tick() NO escribe a state.resources.
      // calcRes() calcula (now - last_updated) cada vez que se llama.
      // Si escribiÃ©ramos el resultado a state.resources, el siguiente tick
      // volverÃ­a a sumar las mismas horas sobre el nuevo valor â€” duplicando infinitamente.
      // state.resources solo se actualiza en snapshotResources() â†’ llamado desde saveVillage().
      // tick() solo usa calcRes() para la UI, no para el estado.

      // Production rates (instantÃ¡neos)
      _el('rMaderaR').textContent = '+' + fmt(prod.madera) + '/h';
      _el('rPiedraR').textContent = '+' + fmt(prod.piedra) + '/h';
      _el('rHierroR').textContent = '+' + fmt(prod.hierro) + '/h';
      _el('rProvR').textContent = '+' + fmt(prod.provisiones) + '/h';
      _el('rEsenciaR').textContent = '+' + fmt(prod.esencia) + '/h';

      // Objetivos para animaciÃ³n (sube y baja)
      if (!uiShown) resetUiAnimation();
      ensureUiAnim();
      uiTarget = {
        madera: res.madera,
        piedra: res.piedra,
        hierro: res.hierro,
        provisiones: res.provisiones,
        esencia: res.esencia,
        aldeanos: res.aldeanos,
        capPctMa, capPctPi, capPctHi, capPctPr, capPctEs, capPctAld
      };

      if (_el('ovVillageName')) _el('ovVillageName').textContent = activeVillage.name;
      if (_el('ovVillageCoords')) _el('ovVillageCoords').textContent = 'Coordenadas: [' + activeVillage.x + ', ' + activeVillage.y + ']';
      // Overview player stats
      if (_el('ovUser')) {
        var displayUsername = window._playerUsername || (currentUser ? (currentUser.email || '--').split('@')[0] : '--');
        _el('ovUser').textContent = displayUsername;
      }
      if (_el('ovAlliance')) {
        var alTag = (window._playerAllianceTag) ? '[' + window._playerAllianceTag + ']' : '';
        var alName = window._playerAllianceName || '';
        var alStr = alName ? (alName + (alTag ? ' ' + alTag : '')) : (alTag || 'â€”');
        _el('ovAlliance').textContent = alStr;
      }
      if (_el('ovBattlesWon')) _el('ovBattlesWon').textContent = (vs.battles_won_pvp || 0);
      if (_el('ovBattlesLost')) _el('ovBattlesLost').textContent = (vs.battles_lost_pvp || 0);
      if (_el('ovBattlesNPC')) _el('ovBattlesNPC').textContent = (vs.battles_won_npc || 0);
      // Troop movement alerts in overview
      if (_el('ovAlertsBox')) {
        var alerts = _incomingAttacks || [];
        var allMissions = (vs.mission_queue || []);
        var myOutgoing = allMissions.filter(function (m) { return m.type !== 'return'; });
        var myReturning = allMissions.filter(function (m) { return m.type === 'return'; });
        var alertLines = '';
        alerts.forEach(function (a) {
          var eta = Math.max(0, Math.ceil((new Date(a.finish_at).getTime() - Date.now()) / 1000));
          var fromName = a.fromVillage || 'Enemigo';
          alertLines += '<div style="background:rgba(255,61,90,.07);border:1px solid rgba(255,61,90,.2);border-radius:6px;padding:7px 10px;margin-bottom:5px;">'
            + '<span style="color:var(--danger);">ğŸš¨ Ataque entrante</span>'
            + '<span style="color:var(--dim);font-size:.72rem;margin-left:8px;">desde ' + escapeHtml(fromName) + '</span>'
            + '<span style="float:right;color:var(--danger);font-size:.75rem;">ETA ' + fmtTime(eta) + '</span>'
            + '</div>';
        });
        myOutgoing.forEach(function (m) {
          var eta = Math.max(0, Math.ceil((new Date(m.finish_at).getTime() - Date.now()) / 1000));
          var ico = m.type === 'spy' ? 'ğŸ”' : m.type === 'found' ? 'ğŸ ' : m.type === 'move' ? 'âš”' : m.type === 'reinforce' ? 'ğŸ›¡ï¸' : m.type === 'transport' ? 'ğŸ“¦' : 'âš”ï¸';
          var label = m.type === 'spy' ? 'Espionaje' : m.type === 'found' ? 'Colonos â†’ [' + m.tx + ',' + m.ty + ']' : m.type === 'move' ? 'Moviendo tropas â†’ [' + m.tx + ',' + m.ty + ']' : m.type === 'reinforce' ? 'Refuerzo â†’ [' + m.tx + ',' + m.ty + ']' : m.type === 'transport' ? 'Caravana â†’ [' + m.tx + ',' + m.ty + ']' : 'Ataque';
          alertLines += '<div style="background:rgba(0,212,255,.05);border:1px solid rgba(0,212,255,.1);border-radius:6px;padding:7px 10px;margin-bottom:5px;">'
            + '<span style="color:var(--accent);">' + ico + ' ' + label + '</span>'
            + '<span style="float:right;color:var(--accent);font-size:.75rem;">ETA ' + fmtTime(eta) + '</span>'
            + '</div>';
        });
        myReturning.forEach(function (m) {
          var eta = Math.max(0, Math.ceil((new Date(m.finish_at).getTime() - Date.now()) / 1000));
          alertLines += '<div style="background:rgba(79,255,176,.04);border:1px solid rgba(79,255,176,.1);border-radius:6px;padding:7px 10px;margin-bottom:5px;">'
            + '<span style="color:var(--ok);">â†©ï¸ Tropas regresando</span>'
            + '<span style="float:right;color:var(--ok);font-size:.75rem;">ETA ' + fmtTime(eta) + '</span>'
            + '</div>';
        });
        _el('ovAlertsBox').innerHTML = alertLines || '<span style="color:var(--dim);font-size:.8rem;">Sin movimientos activos.</span>';
      }

      renderQueue(vs);
      updateAlertsButton();
      updateGranjaPanel();
      // Reinforce panel â€” solo cada 60s
      var nowMs = Date.now();
      if (nowMs - _lastReinforcementsCheck > 60000 && document.getElementById('page-overview').classList.contains('active')) {
        _lastReinforcementsCheck = nowMs;
        renderReinforcementsPanel();
      }
      if (document.getElementById('page-buildings').classList.contains('active')) {
        renderBuildings(res);
      }
      if (document.getElementById('page-creatures') && document.getElementById('page-creatures').classList.contains('active')) {
        renderSummoningQueue();
      }
      if (document.getElementById('page-fleet') && document.getElementById('page-fleet').classList.contains('active')) {
        renderTrainingQueue();
      }
    }

    // ============================================================
    // ALERTS â€” incoming attacks detection
    // ============================================================
    var _incomingAttacks = []; // cache updated periodically
    var _lastAlertsCheck = 0;

    var _lastSeenUpdate = 0;
    var _lastOnlineCheck = 0;
    var _lastReinforcementsCheck = 0;
    var _lastAlliancesCheck = 0;
    var _lastMapLoad = 0;
    var _lastResourceSync = 0;

    async function updateLastSeen() {
      if (!currentUser) return;
      try {
        await sbClient.from('profiles').update({ last_seen: new Date().toISOString() }).eq('id', currentUser.id);
      } catch (e) { }
    }

    async function updateOnlineCount() {
      try {
        var cutoff = new Date(Date.now() - 60000).toISOString(); // last 60s
        var r = await sbClient.from('profiles').select('id', { count: 'exact', head: true }).gte('last_seen', cutoff);
        var count = r.count || 0;
        var el = document.getElementById('activePlayers');
        if (el) el.textContent = 'ğŸŸ¢ ' + count + ' online';
      } catch (e) { }
    }

    function updateAlertsButton() {
      var count = _incomingAttacks.length;
      var btn = document.getElementById('alertsBtn');
      var badge = document.getElementById('alertsBadge');
      var label = document.getElementById('alertsBtnLabel');
      if (!btn) return;

      if (count > 0) {
        btn.classList.add('has-alerts');
        if (badge) { badge.textContent = count; badge.style.display = 'flex'; }
        if (label) label.textContent = count + ' Ataque' + (count > 1 ? 's' : '');
      } else {
        btn.classList.remove('has-alerts');
        if (badge) badge.style.display = 'none';
        if (label) label.textContent = 'Alertas';
      }

      // Refrescar datos cada 30s sin bloquear el tick
      var now = Date.now();
      if (now - _lastAlertsCheck > 30000) {
        _lastAlertsCheck = now;
        checkIncomingAttacks();
      }
    }

    async function checkIncomingAttacks() {
      if (!activeVillage || !sbClient || !currentUser) return;
      try {
        // Coordenadas de todas mis aldeas
        var myCoords = myVillages.map(function (v) { return { x: v.x, y: v.y, id: v.id, name: v.name }; });
        if (myCoords.length === 0) return;

        // Cargar mission_queue de aldeas enemigas (las que no son mÃ­as)
        var { data, error } = await sbClient
          .from('villages')
          .select('id, name, cx, cy, owner_id, mission_queue')
          .neq('owner_id', currentUser.id);

        if (error || !data) return;

        var attacks = [];
        var now = Date.now();

        data.forEach(function (village) {
          var mq = village.mission_queue;
          if (!Array.isArray(mq)) return;
          mq.forEach(function (m) {
            if (m.type !== 'attack') return;
            // Â¿apunta a alguna de mis aldeas?
            var target = myCoords.find(function (c) { return c.x === m.tx && c.y === m.ty; });
            if (!target) return;
            var finish = new Date(m.finish_at).getTime();
            if (finish <= now) return; // ya llegÃ³, tick la resolverÃ¡
            attacks.push({
              fromName: village.name || '[' + village.cx + ',' + village.cy + ']',
              fromCoords: [village.cx, village.cy],
              toName: target.name,
              toCoords: [m.tx, m.ty],
              finish_at: m.finish_at,
              secsLeft: Math.ceil((finish - now) / 1000)
            });
          });
        });

        // Ordenar por llegada mÃ¡s prÃ³xima
        attacks.sort(function (a, b) { return a.secsLeft - b.secsLeft; });
        _incomingAttacks = attacks;
      } catch (e) {
        console.warn('checkIncomingAttacks error:', e);
      }
    }

    function toggleAlertsPanel() {
      var existing = document.getElementById('alertsModalOverlay');
      if (existing) { existing.remove(); return; }

      var attacks = _incomingAttacks;
      var inner = attacks.length === 0
        ? '<div class="alerts-empty">âœ… Sin ataques entrantes detectados</div>'
        : attacks.map(function (a) {
          var t = fmtTime(a.secsLeft);
          return '<div class="alert-item">'
            + '<div class="alert-title">âš”ï¸ Ataque entrante a ' + a.toName + '</div>'
            + '<div class="alert-sub">Desde: ' + a.fromName + ' [' + a.fromCoords[0] + ',' + a.fromCoords[1] + ']</div>'
            + '<div class="alert-time">â± Llega en: ' + t + '</div>'
            + '</div>';
        }).join('');

      var overlay = document.createElement('div');
      overlay.id = 'alertsModalOverlay';
      overlay.className = 'alerts-modal';
      overlay.innerHTML = '<div class="alerts-panel">'
        + '<div class="alerts-header">'
        + '<h3>ğŸ”” Alertas (' + attacks.length + ')</h3>'
        + '<button onclick="document.getElementById(\'alertsModalOverlay\').remove()" style="background:none;border:none;color:var(--dim);cursor:pointer;font-size:1rem;">âœ•</button>'
        + '</div>'
        + inner
        + '</div>';

      // Cierra al click fuera del panel
      overlay.addEventListener('click', function (e) {
        if (e.target === overlay) overlay.remove();
      });

      document.body.appendChild(overlay);
    }

    // ============================================================
    // ============================================================
    function startBuild(id) {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      if (vs.build_queue) { showNotif('Ya hay una construccion en curso.', 'err'); return; }
      var def = BUILDINGS.find(function (b) { return b.id === id; });
      var lvl = (vs.buildings[id] && vs.buildings[id].level) || 0;
      var cost = def.cost(lvl);
      var res = calcRes(vs);
      if (!canAfford(cost, res)) { showNotif('Recursos insuficientes.', 'err'); return; }

      // Snapshot primero (fija last_updated = ahora y escribe valores reales)
      // Luego resta el coste â€” nunca puede quedar negativo porque canAfford ya lo comprobÃ³
      snapshotResources(vs);
      vs.resources.madera = Math.max(0, vs.resources.madera - (cost.madera || 0));
      vs.resources.piedra = Math.max(0, vs.resources.piedra - (cost.piedra || 0));
      vs.resources.hierro = Math.max(0, vs.resources.hierro - (cost.hierro || 0));
      vs.resources.provisiones = Math.max(0, vs.resources.provisiones - (cost.provisiones || 0));
      vs.resources.esencia = Math.max(0, vs.resources.esencia - (cost.esencia || 0));
      // last_updated ya lo fijÃ³ snapshotResources()

      // Store finish timestamp â€” this is what makes offline work
      var secs = def.time(lvl);
      vs.build_queue = { id: id, finish_at: new Date(Date.now() + secs * 1000).toISOString() };

      showNotif('Construyendo ' + def.name + ' nivel ' + (lvl + 1) + '...', 'ok');
      flushVillage(); // save immediately to Supabase
      tick();
      renderBuildings(calcRes(vs));
    }

    function canAfford(cost, res, cap, blds) {
      // Recursos individuales suficientes
      var resOk = (res.madera >= (cost.madera || 0)) && (res.piedra >= (cost.piedra || 0))
        && (res.hierro >= (cost.hierro || 0)) && (res.provisiones >= (cost.provisiones || 0))
        && (res.esencia >= (cost.esencia || 0));
      if (!resOk) return false;
      // Espacio libre en almacen para lo que no es esencia (el coste se va, no ocupa)
      return true;
    }

    // ============================================================
    // ============================================================
    function renderBuildings(res) {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      if (!res) res = calcRes(vs); // fallback si no se pasÃ³ res
      var grid = document.getElementById('bldGrid');
      grid.innerHTML = '';

      BUILDINGS.forEach(function (def) {
        var lvl = (vs.buildings[def.id] && vs.buildings[def.id].level) || 0;
        var next = lvl + 1;
        var cost = def.cost(lvl);
        var prod = def.prod(next);
        var inQueue = vs.build_queue && vs.build_queue.id === def.id;
        var anyQueue = !!vs.build_queue;
        var afford = canAfford(cost, res);
        var icon = def.icon || 'ğŸ—ï¸';

        var timeLeftSec = 0, pct = 0;
        if (inQueue) {
          var finish = new Date(vs.build_queue.finish_at).getTime();
          timeLeftSec = Math.max(0, Math.ceil((finish - Date.now()) / 1000));
          var total = def.time(lvl);
          pct = Math.min(100, Math.round(((total - timeLeftSec) / total) * 100));
        }

        var prodHTML = '';
        if (prod.madera) prodHTML += '<span class="pbadge" style="color:var(--madera);border-color:rgba(200,164,90,.3);background:rgba(200,164,90,.05)">ğŸŒ² +' + fmt(prod.madera) + '/h</span>';
        if (prod.piedra) prodHTML += '<span class="pbadge" style="color:var(--piedra);border-color:rgba(160,168,176,.3);background:rgba(160,168,176,.05)">â›°ï¸ +' + fmt(prod.piedra) + '/h</span>';
        if (prod.hierro) prodHTML += '<span class="pbadge" style="color:var(--hierro);border-color:rgba(224,120,96,.3);background:rgba(224,120,96,.05)">âš™ï¸ +' + fmt(prod.hierro) + '/h</span>';
        if (prod.provisiones) prodHTML += '<span class="pbadge" style="color:var(--prov);border-color:rgba(111,207,122,.3);background:rgba(111,207,122,.05)">ğŸŒ¾ +' + fmt(prod.provisiones) + '/h</span>';
        if (prod.esencia) prodHTML += '<span class="pbadge" style="color:var(--esencia);border-color:rgba(192,132,252,.3);background:rgba(192,132,252,.05)">âœ¨ +' + fmt(prod.esencia) + '/h</span>';

        var costHTML = '';
        if (cost.madera) costHTML += '<span class="cost-i ' + (res.madera >= (cost.madera || 0) ? 'ok' : 'no') + '">ğŸŒ² ' + fmt(cost.madera) + '</span>';
        if (cost.piedra) costHTML += '<span class="cost-i ' + (res.piedra >= (cost.piedra || 0) ? 'ok' : 'no') + '">â›°ï¸ ' + fmt(cost.piedra) + '</span>';
        if (cost.hierro) costHTML += '<span class="cost-i ' + (res.hierro >= (cost.hierro || 0) ? 'ok' : 'no') + '">âš™ï¸ ' + fmt(cost.hierro) + '</span>';
        if (cost.provisiones) costHTML += '<span class="cost-i ' + (res.provisiones >= (cost.provisiones || 0) ? 'ok' : 'no') + '">ğŸŒ¾ ' + fmt(cost.provisiones) + '</span>';
        if (cost.esencia) costHTML += '<span class="cost-i ' + (res.esencia >= (cost.esencia || 0) ? 'ok' : 'no') + '">âœ¨ ' + fmt(cost.esencia) + '</span>';

        var btnCls = 'avail', btnTxt = 'Mejorar a Nivel ' + next;
        if (inQueue) { btnCls = 'busy'; btnTxt = 'Construyendo... (' + timeLeftSec + 's)'; }
        else if (!afford || anyQueue) { btnCls = 'insuf'; btnTxt = !afford ? 'Recursos insuficientes' : 'Cola ocupada'; }

        var card = document.createElement('div');
        card.className = 'bld-card';
        card.innerHTML = '<div class="bld-head" onclick="openBuildingDetail(\'' + def.id + '\')" style="cursor:pointer"><div class="bld-ico">' + icon + '</div><div><div class="bld-name">' + def.name + '</div><div class="bld-lvl">Nivel: <span class="lvl-n">' + lvl + '</span></div></div><span class="detail-badge">ver detalle &rsaquo;</span></div>'
          + '<div class="bld-body"><div class="bld-desc">'
          + (def.id === 'reclutamiento'
            ? 'Nivel ' + lvl + ' â†’ ' + getAldeanosProd(vs.buildings) + ' aldeanos/h'
            : def.id === 'barracas'
              ? 'Nivel ' + lvl + ' â†’ ' + getBarracksCapacity(vs.buildings) + ' plazas de tropas'
              : def.id === 'granja'
                ? 'Nivel ' + lvl + ' â†’ ' + (5 + lvl) + ' provisiones/aldeano/h en granja'
                : 'Nivel actual: ' + lvl) + '</div>'
          + (prodHTML ? '<div class="prod-row">' + prodHTML + '</div>' : '')
          + '<div class="cost-row">' + costHTML + '</div>'
          + (inQueue ? '<div class="pbar-wrap"><div class="pbar-fill" style="width:' + pct + '%"></div></div>' : '')
          + '<button class="bld-btn ' + btnCls + '" onclick="startBuild(\'' + def.id + '\')">' + btnTxt + '</button></div>';
        grid.appendChild(card);
      });
    }

    // ============================================================
    // ============================================================
    // ============================================================
    // VER TROPAS EN MOVIMIENTO â€” modal informativo
    // ============================================================
    function showMissionTroops(missionRef) {
      var vs = activeVillage && activeVillage.state;
      if (!vs) return;
      var m = (vs.mission_queue || []).find(function (q) { return q.mid === missionRef || q.finish_at === missionRef; });
      if (!m) { showNotif('MisiÃ³n no encontrada', 'err'); return; }

      var troops = m.troops || {};
      var hasTroops = Object.keys(troops).some(function (k) { return (troops[k] || 0) > 0; });
      if (!hasTroops) { showNotif('Esta misiÃ³n no lleva unidades', 'info'); return; }

      // Determinar nombre e icono de la misiÃ³n
      var missionName, missionIcon;
      if (m.type === 'spy')              { missionIcon = 'ğŸ¹'; missionName = 'Espionaje â†’ [' + m.tx + ',' + m.ty + ']'; }
      else if (m.type === 'return')      { missionIcon = 'ğŸ '; missionName = 'Tropas regresando a casa'; }
      else if (m.type === 'return_reinforce') { missionIcon = 'â†©ï¸'; missionName = 'Tropas volviendo a casa'; }
      else if (m.type === 'reinforce')   { missionIcon = 'ğŸ›¡ï¸'; missionName = 'Refuerzo â†’ [' + m.tx + ',' + m.ty + ']'; }
      else if (m.type === 'transport')   { missionIcon = 'ğŸ“¦'; missionName = 'Caravana â†’ [' + m.tx + ',' + m.ty + ']'; }
      else if (m.type === 'move')        { missionIcon = 'âš”ï¸'; missionName = 'Tropas â†’ [' + m.tx + ',' + m.ty + ']'; }
      else                               { missionIcon = 'âš”ï¸'; missionName = 'Ataque â†’ [' + m.tx + ',' + m.ty + ']'; }

      // Tiempo restante
      var tl = Math.max(0, Math.ceil((new Date(m.finish_at).getTime() - Date.now()) / 1000));
      var timeStr = tl > 3600 ? Math.floor(tl/3600) + 'h ' + Math.floor((tl%3600)/60) + 'm ' + (tl%60) + 's'
                  : tl > 60  ? Math.floor(tl/60) + 'm ' + (tl%60) + 's'
                  : tl + 's';

      // Separar tropas y criaturas
      var troopRows = '', creatureRows = '', totalUnits = 0;
      Object.keys(troops).forEach(function (k) {
        var qty = troops[k] || 0;
        if (qty <= 0) return;
        totalUnits += qty;
        var td = TROOP_TYPES[k];
        var cd = CREATURE_TYPES[k];
        if (td) {
          troopRows += '<div style="display:flex;align-items:center;gap:8px;padding:5px 0;border-bottom:1px solid var(--border);">'
            + '<span style="font-size:1.3rem;">' + td.icon + '</span>'
            + '<span style="flex:1;color:var(--text);font-size:.88rem;">' + td.name + '</span>'
            + '<span style="color:var(--accent);font-size:.95rem;font-weight:bold;">Ã—' + fmt(qty) + '</span>'
            + '</div>';
        } else if (cd) {
          creatureRows += '<div style="display:flex;align-items:center;gap:8px;padding:5px 0;border-bottom:1px solid var(--border);">'
            + '<span style="font-size:1.3rem;">' + cd.icon + '</span>'
            + '<span style="flex:1;color:var(--text);font-size:.88rem;">' + cd.name + '</span>'
            + '<span style="color:var(--accent2);font-size:.95rem;font-weight:bold;">Ã—' + fmt(qty) + '</span>'
            + '</div>';
        }
      });

      // Secciones de contenido
      var sectTroops = troopRows
        ? '<div style="font-size:.72rem;color:var(--dim);text-transform:uppercase;letter-spacing:.05em;margin:12px 0 4px;">âš”ï¸ Tropas</div>' + troopRows
        : '';
      var sectCreatures = creatureRows
        ? '<div style="font-size:.72rem;color:var(--dim);text-transform:uppercase;letter-spacing:.05em;margin:12px 0 4px;">ğŸ‰ Criaturas</div>' + creatureRows
        : '';

      // Contingentes aliados (si los hay)
      var guestHTML = '';
      if (m.guest_contingents && m.guest_contingents.length > 0) {
        m.guest_contingents.forEach(function (gc) {
          if (!gc.troops || !Object.values(gc.troops).some(function(n){return n>0;})) return;
          var gName = (profileCache[gc.owner_id] && profileCache[gc.owner_id].username) || gc.owner_id.slice(0,8);
          var gRows = '';
          Object.keys(gc.troops).forEach(function(k){
            var qty2 = gc.troops[k]||0; if(!qty2) return;
            var td2 = TROOP_TYPES[k]; var cd2 = CREATURE_TYPES[k];
            var info = td2||cd2; if(!info) return;
            gRows += '<div style="display:flex;align-items:center;gap:8px;padding:3px 0;">'
              + '<span style="font-size:1.1rem;">' + info.icon + '</span>'
              + '<span style="flex:1;color:var(--dim);font-size:.82rem;">' + info.name + '</span>'
              + '<span style="color:var(--text);font-size:.88rem;">Ã—' + fmt(qty2) + '</span>'
              + '</div>';
          });
          if (gRows) {
            guestHTML += '<div style="background:var(--panel2);border-radius:6px;padding:8px;margin-top:8px;">'
              + '<div style="font-size:.72rem;color:#e87030;margin-bottom:4px;">ğŸ¤ ' + escapeHtml(gName) + ' (aliado)</div>'
              + gRows + '</div>';
          }
        });
      }

      // Construir y mostrar el modal
      var existing = document.getElementById('missionTroopsModal');
      if (existing) existing.remove();
      var overlay = document.createElement('div');
      overlay.id = 'missionTroopsModal';
      overlay.style.cssText = 'position:fixed;inset:0;z-index:9999;background:rgba(0,0,0,.78);display:flex;align-items:center;justify-content:center;';
      overlay.onclick = function (e) { if (e.target === overlay) overlay.remove(); };
      overlay.innerHTML = '<div style="background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:20px;max-width:360px;width:92%;font-family:VT323,monospace;max-height:80vh;overflow-y:auto;">'
        + '<div style="display:flex;align-items:center;gap:10px;margin-bottom:12px;border-bottom:1px solid var(--border);padding-bottom:10px;">'
        + '<span style="font-size:1.8rem;">' + missionIcon + '</span>'
        + '<div style="flex:1;">'
        + '<div style="font-size:1rem;color:var(--accent);">' + missionName + '</div>'
        + '<div style="font-size:.72rem;color:var(--dim);">â± ' + timeStr + ' Â· ' + fmt(totalUnits) + ' unidades en total</div>'
        + '</div>'
        + '<button onclick="document.getElementById(\'missionTroopsModal\').remove()" style="background:none;border:none;color:var(--dim);font-size:1.2rem;cursor:pointer;padding:0 4px;">âœ•</button>'
        + '</div>'
        + sectTroops
        + sectCreatures
        + guestHTML
        + '</div>';
      document.body.appendChild(overlay);
    }

    function renderQueue(vs) {
      var ids = ['qItems', 'qItemsOv'];
      ids.forEach(function (elId) {
        var el = document.getElementById(elId);
        var emId = elId === 'qItems' ? 'qEmpty' : 'qEmptyOv';
        var em = document.getElementById(emId);
        if (!vs.build_queue) { em.style.display = 'block'; el.innerHTML = ''; return; }
        em.style.display = 'none';
        var q = vs.build_queue;
        var def = BUILDINGS.find(function (b) { return b.id === q.id; });
        var finish = new Date(q.finish_at).getTime();
        var tl = Math.max(0, Math.ceil((finish - Date.now()) / 1000));
        var lvl = ((vs.buildings[q.id] && vs.buildings[q.id].level) || 0);
        var total = def ? def.time(lvl) : 60;
        var pct = Math.min(100, Math.round(((total - tl) / total) * 100));
        var icon = def ? def.icon : 'ğŸ—ï¸';
        el.innerHTML = '<div class="queue-item"><div class="queue-icon">' + icon + '</div>'
          + '<div class="queue-info"><div class="queue-name">' + (def ? def.name : q.id) + ' -> Nivel ' + (lvl + 1) + '</div>'
          + '<div class="queue-time">' + tl + 's restantes</div>'
          + '<div class="qbar"><div class="qbar-fill" style="width:' + pct + '%"></div></div></div></div>';
      });

      var mIds = ['qItems', 'qItemsOv']; // We use the same containers or add specific ones
      mIds.forEach(function (elId) {
        var el = document.getElementById(elId);
        if (!vs.mission_queue || vs.mission_queue.length === 0) return;

        vs.mission_queue.forEach(m => {
          var finish = new Date(m.finish_at).getTime();
          var now = Date.now();
          var tl = Math.max(0, Math.ceil((finish - now) / 1000));

          // FILTRO MEJORADO: No mostrar misiones completadas
          // Si ya terminÃ³ (tl=0) y es una misiÃ³n de retorno, no mostrar (serÃ¡ procesada en resolveMissions)
          if (tl <= 0 && m.type === 'return') return;
          // Para otras misiones, dar 5 segundos de gracia antes de ocultar
          if (tl <= 0 && now - finish > 5000) return;

          var start = m.start_at ? new Date(m.start_at).getTime() : (finish - 60000);
          var total = Math.max(1, Math.ceil((finish - start) / 1000));
          var pct = Math.min(100, Math.round(((total - tl) / total) * 100));

          var icon, name, color;
          if (m.type === 'spy') { icon = 'ğŸ¹'; name = 'Espionaje a [' + m.tx + ',' + m.ty + ']'; color = 'var(--accent)'; }
          else if (m.type === 'return') { icon = 'ğŸ '; name = 'Tropas regresando'; color = 'var(--ok)'; }
          else if (m.type === 'found') { icon = 'ğŸ˜ï¸'; name = 'Colonos hacia [' + m.tx + ',' + m.ty + ']'; color = 'var(--gold)'; }
          else if (m.type === 'move') { icon = 'âš”'; name = 'Tropas â†’ [' + m.tx + ',' + m.ty + ']'; color = 'var(--accent)'; }
          else if (m.type === 'reinforce') { icon = 'ğŸ›¡ï¸'; name = 'Refuerzo â†’ [' + m.tx + ',' + m.ty + ']'; color = 'var(--accent2)'; }
          else if (m.type === 'transport') { icon = 'ğŸ“¦'; name = 'Caravana â†’ [' + m.tx + ',' + m.ty + ']'; color = 'var(--madera)'; }
          else if (m.type === 'return_reinforce') { icon = 'â†©'; name = 'Tropas volviendo a casa'; color = 'var(--ok)'; }
          else { icon = 'âš”ï¸'; name = 'Ataque a [' + m.tx + ',' + m.ty + ']'; color = 'var(--danger)'; }

          var timeStr = tl > 3600 ? Math.floor(tl / 3600) + 'h ' + Math.floor((tl % 3600) / 60) + 'm'
            : tl > 60 ? Math.floor(tl / 60) + 'm ' + (tl % 60) + 's'
              : tl + 's';

          var div = document.createElement('div');
          div.className = 'queue-item mission';
          div.style.borderLeftColor = color;
          var cancelBtn = (m.type !== 'return' && m.type !== 'found' && m.type !== 'move' && m.type !== 'reinforce' && m.type !== 'transport' && m.type !== 'return_reinforce')
            ? '<button onclick="cancelMission(\'' + (m.mid || m.finish_at) + '\')" style="background:rgba(255,61,90,.1);border:1px solid rgba(255,61,90,.3);color:var(--danger);padding:3px 8px;border-radius:3px;font-size:.62rem;cursor:pointer;margin-top:4px;">âœ— Cancelar</button>'
            : '';
          var hasTroopsInMission = m.troops && Object.keys(m.troops).some(function(k){return (m.troops[k]||0)>0;});
          var viewBtn = hasTroopsInMission
            ? '<button onclick="showMissionTroops(\'' + escapeJs(m.mid || m.finish_at) + '\')" style="background:rgba(100,180,255,.08);border:1px solid rgba(100,180,255,.25);color:var(--accent);padding:3px 8px;border-radius:3px;font-size:.62rem;cursor:pointer;margin-top:4px;margin-right:4px;">ğŸ‘ Ver tropas</button>'
            : '';
          div.innerHTML = '<div class="queue-icon">' + icon + '</div>'
            + '<div class="queue-info"><div class="queue-name">' + name + '</div>'
            + '<div class="queue-time">' + timeStr + '</div>'
            + '<div class="qbar"><div class="qbar-fill" style="width:' + pct + '%; background:' + color + '"></div></div>'
            + '<div style="display:flex;flex-wrap:wrap;gap:2px;">' + viewBtn + cancelBtn + '</div>'
            + '</div>';
          el.appendChild(div);
        });

        // Misiones aliadas â€” ataques conjuntos donde YO participo pero no soy el lÃ­der
        if (_activeMissionsTableExists !== false && currentUser) {
          sbClient.from('active_missions')
            .select('*')
            .eq('participant_id', currentUser.id)
            .eq('status', 'active')
            .then(function (amr) {
              if (amr.error || !amr.data) return;
              amr.data.forEach(function (am) {
                if (am.leader_id === currentUser.id) return; // ya visible en mi propia queue
                var finish = new Date(am.finish_at).getTime();
                var now2 = Date.now();
                var tl2 = Math.max(0, Math.ceil((finish - now2) / 1000));
                var timeStr2 = tl2 > 3600 ? Math.floor(tl2/3600) + 'h ' + Math.floor((tl2%3600)/60) + 'm'
                  : tl2 > 60 ? Math.floor(tl2/60) + 'm ' + (tl2%60) + 's' : tl2 + 's';
                var start2 = new Date(am.created_at || am.finish_at).getTime();
                var total2 = Math.max(1, Math.ceil((finish - start2) / 1000));
                var pct2 = Math.min(100, Math.round(((total2 - tl2) / total2) * 100));
                var leaderName = (profileCache[am.leader_id] && profileCache[am.leader_id].username) || am.leader_id.slice(0,8);
                var aDiv = document.createElement('div');
                aDiv.className = 'queue-item mission';
                aDiv.style.borderLeftColor = '#e87030';
                aDiv.style.opacity = '0.85';
                aDiv.innerHTML = '<div class="queue-icon">âš”ï¸</div>'
                  + '<div class="queue-info">'
                  + '<div class="queue-name" style="color:#e87030;">Ataque conjunto [' + am.target_x + ',' + am.target_y + ']</div>'
                  + '<div style="font-size:.62rem;color:var(--dim);">Liderado por ' + escapeHtml(leaderName) + '</div>'
                  + '<div class="queue-time">' + timeStr2 + '</div>'
                  + '<div class="qbar"><div class="qbar-fill" style="width:' + pct2 + '%;background:#e87030;"></div></div>'
                  + '<button onclick="cancelAlliedMission(\'' + am.mission_id + '\',\'' + am.host_village_id + '\')" '
                  + 'style="background:rgba(255,61,90,.1);border:1px solid rgba(255,61,90,.3);color:var(--danger);padding:3px 8px;border-radius:3px;font-size:.62rem;cursor:pointer;margin-top:4px;">âœ— Cancelar (todos)</button>'
                  + '</div>';
                el.appendChild(aDiv);
              });
              if (_activeMissionsTableExists === null) _activeMissionsTableExists = true;
            }).catch(function (e) {
              if (e && e.code === '42P01') _activeMissionsTableExists = false;
            });
        }
      });
    }

    // ============================================================
    // MAP â€” con cÃ¡mara libre (offset), flechas y WASD
    // ============================================================
    var mapCamX = null; // null = centrado en aldea
    var mapCamY = null;

    function panMap(dx, dy, resetToVillage) {
      if (!activeVillage) return;
      if (resetToVillage) {
        mapCamX = activeVillage.x;
        mapCamY = activeVillage.y;
      } else {
        if (mapCamX === null) mapCamX = activeVillage.x;
        if (mapCamY === null) mapCamY = activeVillage.y;
        mapCamX = Math.max(1, Math.min(MAP_SIZE, mapCamX + dx));
        mapCamY = Math.max(1, Math.min(MAP_SIZE, mapCamY + dy));
      }
      renderMap();
      try { sessionStorage.setItem('EW_camX', String(mapCamX)); sessionStorage.setItem('EW_camY', String(mapCamY)); } catch (e) { }
    }

    // Teclado: flechas + WASD (solo cuando el mapa estÃ¡ activo)
    document.addEventListener('keydown', function (e) {
      var mapActive = document.getElementById('page-map') &&
        document.getElementById('page-map').classList.contains('active');
      if (!mapActive) return;
      // No interferir con inputs de texto
      if (['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement && document.activeElement.tagName)) return;
      var moved = false;
      if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') { panMap(0, -1); moved = true; }
      if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') { panMap(0, 1); moved = true; }
      if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') { panMap(-1, 0); moved = true; }
      if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') { panMap(1, 0); moved = true; }
      if (moved) e.preventDefault();
    });

    // ============================================================
    // MINIMAPA â€” canvas 30Ã—30, centrado en la cÃ¡mara del mapa principal
    // No es interactivo. Se actualiza cada vez que renderMap() lo llama.
    // Colores: propio=cian, aliado=verde, enemigo=rojo, npc=dorado
    // ============================================================
    var MINI_COLS = 30;
    var MINI_CELL = 9; // px por celda (9px * 30 = 270px)
    var MINI_GAP = 0;

    function renderMinimap(cx, cy) {
      var canvas = document.getElementById('minimapCanvas');
      if (!canvas) return;
      var ctx = canvas.getContext('2d');
      var W = canvas.width;
      var H = canvas.height;
      ctx.clearRect(0, 0, W, H);

      // Fondo
      ctx.fillStyle = 'rgba(10,10,16,0.95)';
      ctx.fillRect(0, 0, W, H);

      // Lookups
      var lookup = {};
      (allVillages || []).forEach(function (v) { lookup[v.x + ',' + v.y] = v; });
      var npcLookup = {};
      (typeof NPC_CASTLES !== 'undefined' ? NPC_CASTLES : []).forEach(function (n) { npcLookup[n.x + ',' + n.y] = n; });

      var half = Math.floor(MINI_COLS / 2); // 15
      var cellPx = MINI_CELL;

      for (var row = 0; row < MINI_COLS; row++) {
        for (var col = 0; col < MINI_COLS; col++) {
          var wx = cx - half + col;
          var wy = cy - half + row;
          var key = wx + ',' + wy;
          var px = col * cellPx;
          var py = row * cellPx;

          if (wx < 1 || wx > MAP_SIZE || wy < 1 || wy > MAP_SIZE) {
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(px, py, cellPx - 1, cellPx - 1);
            continue;
          }

          var vill = lookup[key];
          var npc = npcLookup[key];

          if (vill) {
            var isOwn = currentUser && (vill.owner_id === currentUser.id);
            var isAlly = !isOwn && (_allyUserIds && _allyUserIds.has(vill.owner_id));
            if (isOwn) ctx.fillStyle = 'rgba(0,212,255,0.85)';
            else if (isAlly) ctx.fillStyle = 'rgba(96,208,96,0.85)';
            else ctx.fillStyle = 'rgba(255,61,90,0.85)';
            ctx.fillRect(px, py, cellPx - 1, cellPx - 1);
          } else if (npc) {
            ctx.fillStyle = 'rgba(255,230,0,0.7)';
            ctx.fillRect(px, py, cellPx - 1, cellPx - 1);
          } else {
            ctx.fillStyle = 'rgba(255,255,255,0.025)';
            ctx.fillRect(px, py, cellPx - 1, cellPx - 1);
          }
        }
      }

      // Dibujar encuadre de lo que muestra el mapa principal (15x15)
      var mainR = MAP_VIEW; // 7 â†’ 15Ã—15
      var mainSize = mainR * 2 + 1; // 15
      var frameLeft = (half - mainR) * cellPx;
      var frameTop = (half - mainR) * cellPx;
      var framePx = mainSize * cellPx;
      ctx.strokeStyle = 'rgba(240,192,64,0.7)';
      ctx.lineWidth = 1.5;
      ctx.strokeRect(frameLeft + 0.5, frameTop + 0.5, framePx - cellPx, framePx - cellPx);

      // Punto central (aldea activa si estÃ¡ en el encuadre)
      if (activeVillage) {
        var avx = activeVillage.x, avy = activeVillage.y;
        var dc = avx - (cx - half), dr = avy - (cy - half);
        if (dc >= 0 && dc < MINI_COLS && dr >= 0 && dr < MINI_COLS) {
          ctx.fillStyle = 'rgba(255,255,255,0.9)';
          ctx.beginPath();
          ctx.arc(dc * cellPx + cellPx / 2, dr * cellPx + cellPx / 2, 3, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    function renderMap() {
      if (!activeVillage) { return; }
      if (allVillages.length === 0) {
        document.getElementById('mapCoordsDisplay').textContent = 'Cargando...';
        // Solo recargar mapa si han pasado mÃ¡s de 5 minutos (reduce queries)
        var _nowMap = Date.now();
        var _doLoad = (_nowMap - _lastMapLoad) > 300000 || allVillages.length === 0;
        _lastMapLoad = _doLoad ? _nowMap : _lastMapLoad;
        (_doLoad ? loadAllVillages() : Promise.resolve()).then(function () {
          if (allVillages.length > 0) renderMap();
          else document.getElementById('mapCoordsDisplay').textContent = 'No se pudieron cargar los datos del mapa.';
        });
        return;
      }

      // CÃ¡mara: si es null, centrar en aldea
      var cx = (mapCamX !== null) ? mapCamX : activeVillage.x;
      var cy = (mapCamY !== null) ? mapCamY : activeVillage.y;
      if (mapCamX === null) { mapCamX = activeVillage.x; mapCamY = activeVillage.y; }

      var r = MAP_VIEW;
      var size = r * 2 + 1;

      var npcLookup = {};
      (typeof NPC_CASTLES !== 'undefined' ? NPC_CASTLES : []).forEach(function (n) { npcLookup[n.x + ',' + n.y] = n; });

      // Construir lookup de aldeas por coordenada
      var lookup = {};
      allVillages.forEach(function (v) { lookup[v.x + ',' + v.y] = v; });

      var grid = document.getElementById('mapGrid');
      grid.style.gridTemplateColumns = 'repeat(' + size + ', 28px)';
      grid.innerHTML = '';

      // Indica si la cÃ¡mara estÃ¡ descentrada del jugador
      var isOffCenter = (cx !== activeVillage.x || cy !== activeVillage.y);
      document.getElementById('mapCoordsDisplay').textContent =
        'CÃ¡mara: [' + cx + ', ' + cy + ']' +
        (isOffCenter ? '  |  Tu aldea: [' + activeVillage.x + ', ' + activeVillage.y + ']  |  (âŒ‚ para volver)' : '  |  Vista: [' + (cx - r) + ',' + (cy - r) + '] a [' + (cx + r) + ',' + (cy + r) + ']');

      renderMinimap(cx, cy);

      for (var dy2 = -r; dy2 <= r; dy2++) {
        for (var dx2 = -r; dx2 <= r; dx2++) {
          var wx = cx + dx2, wy = cy + dy2;
          var key = wx + ',' + wy;
          var vill = lookup[key];
          var npc = npcLookup[key];

          var cell = document.createElement('div');
          cell.className = 'map-cell';
          cell.title = '[' + wx + ', ' + wy + ']';

          if (wx < 1 || wx > MAP_SIZE || wy < 1 || wy > MAP_SIZE) {
            cell.classList.add('out-of-bounds');
          } else if (vill) {
            var isOwn = (vill.owner_id === currentUser.id);
            var isAlly = !isOwn && (_allyUserIds && _allyUserIds.has(vill.owner_id));
            cell.classList.add(isOwn ? 'own' : (isAlly ? 'ally' : 'enemy'));
            cell.textContent = isOwn ? 'ğŸ ' : (isAlly ? 'ğŸ¤' : 'âš”ï¸');
            if (wx === activeVillage.x && wy === activeVillage.y) cell.classList.add('center-marker');
            (function (v, own, ally, x, y) { cell.onclick = function () { selectCell(v, own, ally, x, y); }; })(vill, isOwn, isAlly, wx, wy);
          } else if (npc) {
            cell.classList.add('npc');
            var obj = playerObjectives.find(o => o.objective_id === npc.id);
            var isCleared = obj && obj.status === 'cleared';
            cell.textContent = isCleared ? 'ğŸ°' : 'ğŸ›¡ï¸';
            if (isCleared) { cell.style.opacity = '0.4'; cell.title += ' (SUPERADO)'; }
            (function (n, nx, ny) { cell.onclick = function () { selectNPC(n, nx, ny); }; })(npc, wx, wy);
          } else {
            cell.classList.add('empty');
            if (wx === activeVillage.x && wy === activeVillage.y) cell.classList.add('center-marker');
            (function (x, y) { cell.onclick = function () { selectCell(null, false, x, y); }; })(wx, wy);
          }
          grid.appendChild(cell);
        }
      }
    }

    function selectNPC(npc, x, y) {
      var panel = document.getElementById('mapPanel');
      var title = document.getElementById('mapPanelTitle');
      var sub = document.getElementById('mapPanelSub');
      var actions = document.getElementById('mapActions');
      panel.classList.add('show');

      var inRange = isInTorreRange(x, y);
      var obj = playerObjectives.find(o => o.objective_id === npc.id);
      var isCleared = obj && obj.status === 'cleared';
      var isSpied = obj && obj.status === 'spied';

      // Fecha de derrota (guardada en last_interaction)
      var clearDateStr = '';
      if (isCleared && obj.last_interaction) {
        var d = new Date(obj.last_interaction);
        clearDateStr = ' Â· ' + d.toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit', year: 'numeric' })
          + ' ' + d.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
      }

      var statusTag = isCleared
        ? ' <span style="color:var(--ok)">[DERROTADO' + clearDateStr + ']</span>'
        : isSpied ? ' <span style="color:var(--accent)">[ESPIADO]</span>' : '';

      title.innerHTML = npc.name + ' ' + (npc.icon || 'ğŸ‡') + statusTag;

      // Stats: solo visibles si espiado o derrotado
      if (isCleared || isSpied) {
        sub.innerHTML = '[' + x + ', ' + y + '] Â· '
          + 'PG: ' + fmt(npc.hp) + ' Â· CA: ' + npc.defense + ' Â· XP: ' + fmt(npc.rewards.experience);
      } else {
        sub.innerHTML = '[' + x + ', ' + y + '] Â· <span style="color:var(--dim);font-style:italic;">Stats desconocidos â€” envÃ­a un explorador</span>';
      }

      if (isCleared) {
        actions.innerHTML = '<span style="color:var(--ok);font-size:.72rem;">âœ… Ya derrotaste a este caballero.</span>';
      } else if (inRange) {
        actions.innerHTML = ''
          + '<button class="map-action-btn spy" onclick="openMissionModal(\'spy\', \'' + npc.id + '\', ' + x + ', ' + y + ')">ğŸ” Espiar</button>'
          + '<button class="map-action-btn atk" onclick="openMissionModal(\'attack\', \'' + npc.id + '\', ' + x + ', ' + y + ')">âš”ï¸ Atacar</button>';
      } else {
        actions.innerHTML = '<span style="color:var(--danger);font-size:.72rem;">âš  Fuera de alcance â€” mejora la Torre de VigÃ­a</span>';
      }
    }

    async function openMissionModal(type, targetId, x, y) {
      // v1.22: Bloquear ataques/espionaje a aliados por cÃ³digo
      if (type === 'attack' || type === 'spy') {
        var targetVill = allVillages.find(function (v) { return v.id === targetId; });
        if (targetVill && _allyUserIds && _allyUserIds.has(targetVill.owner_id)) {
          showNotif('âš ï¸ No puedes ' + (type === 'attack' ? 'atacar' : 'espiar') + ' a un aliado.', 'err');
          return;
        }
      }
      if (!activeVillage) return;
      var vs = activeVillage.state;
      var res = calcRes(vs);
      var troops = vs.troops || {};

      // Aldeanos LIBRES (no asignados a recursos) â€” los Ãºnicos que pueden enviarse
      var aldLibres = res.aldeanos_libres || 0;

      var html = '<div class="bld-modal-overlay" id="missionOverlay" onclick="closeMissionOverlay(event)">'
        + '<div class="bld-modal" style="max-width:400px;">'
        + '<div class="bld-modal-head">'
        + '<div class="bld-modal-icon">' + (type === 'spy' ? 'ğŸ¹' : 'âš”ï¸') + '</div>'
        + '<div><div class="bld-modal-title">' + (type === 'spy' ? 'Preparar Espionaje' : 'Enviar Ataque') + '</div>'
        + '<div class="bld-modal-sub">Destino: [' + x + ', ' + y + ']</div></div>'
        + '<button class="bld-modal-close" onclick="document.getElementById(\'bldModal\').style.display=\'none\';">&#x2715;</button>'
        + '</div>'
        + '<div class="bld-modal-body" style="padding:15px;">';

      if (type === 'spy') {
        var scouts = troops.explorador || 0;
        if (scouts <= 0) {
          html += '<p style="color:var(--danger); text-align:center;">Necesitas al menos 1 Explorador para espiar.</p>';
        } else {
          html += '<p>Selecciona cuÃ¡ntos exploradores enviar:</p>'
            + '<input type="number" id="mUnits_explorador" value="1" min="1" max="' + scouts + '" style="width:100%; margin-bottom:10px;">'
            + '<p style="font-size:0.7rem; color:var(--dim);">Solo los exploradores pueden realizar misiones de espionaje.</p>';
        }
      } else {
        html += '<p>Selecciona tus tropas:</p>';
        Object.keys(TROOP_TYPES).forEach(k => {
          var count = (k === 'aldeano') ? aldLibres : (troops[k] || 0);
          if (count > 0) {
            html += '<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">'
              + '<span>' + TROOP_TYPES[k].icon + ' ' + TROOP_TYPES[k].name + ' (' + count + ' disp.)</span>'
              + '<input type="number" id="mUnits_' + k + '" value="0" min="0" max="' + count + '" style="width:60px;" oninput="calcMissionETA(' + x + ',' + y + ')">'
              + '</div>';
          }
        });

        var creatures = vs.creatures || defaultCreatures();
        var hasCreatures = false;
        Object.keys(CREATURE_TYPES).forEach(k => {
          var count = creatures[k] || 0;
          if (count > 0) {
            if (!hasCreatures) {
              html += '<div style="margin-top:16px;padding-top:12px;border-top:1px solid var(--border);"><p style="color:var(--accent);font-size:.85rem;">ğŸ‰ Criaturas:</p></div>';
              hasCreatures = true;
            }
            html += '<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">'
              + '<span>' + CREATURE_TYPES[k].icon + ' ' + CREATURE_TYPES[k].name + ' (' + count + ' disponibles)</span>'
              + '<input type="number" id="mUnits_' + k + '" value="0" min="0" max="' + count + '" style="width:60px;">'
              + '</div>';
          }
        });

        if (Object.values(troops).reduce((a, b) => a + b, 0) === 0 && !hasCreatures) {
          html += '<p style="color:var(--danger);">No tienes tropas ni criaturas disponibles.</p>';
        }

        // Tropas aliadas estacionadas â€” SOLO para ataques PvP (no NPC)
        var isPvPTarget = allVillages && allVillages.some(function (v) { return v.id === targetId; });
        if (isPvPTarget && _guestTroopsTableExists !== false) {
          try {
            var gtr = await sbClient.from('guest_troops')
              .select('id,owner_id,troops')
              .eq('host_village_id', activeVillage.id);
            if (!gtr.error && gtr.data && gtr.data.length > 0) {
              var hasGuestTroops = false;
              var guestHtml = '';
              gtr.data.forEach(function (gt) {
                var gTroops = typeof gt.troops === 'string' ? JSON.parse(gt.troops) : (gt.troops || {});
                var ownerName = (profileCache[gt.owner_id] && profileCache[gt.owner_id].username)
                  ? profileCache[gt.owner_id].username : '(aliado)';
                Object.keys(gTroops).forEach(function (k) {
                  var n = gTroops[k] || 0;
                  if (n <= 0) return;
                  var tDef = TROOP_TYPES[k] || CREATURE_TYPES[k];
                  if (!tDef) return;
                  hasGuestTroops = true;
                  guestHtml += '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">'
                    + '<span style="color:var(--accent2);">' + tDef.icon + ' ' + tDef.name
                    + ' <span style="color:var(--dim);font-size:.68rem;">(' + n + ' disp. Â· ' + escapeHtml(ownerName) + ')</span></span>'
                    + '<input type="number" id="gUnits_' + gt.id + '_' + k + '" value="0" min="0" max="' + n
                    + '" data-gtid="' + gt.id + '" data-troop="' + k
                    + '" data-ownerid="' + gt.owner_id + '" data-origvid="' + gt.origin_village_id
                    + '" style="width:60px;" oninput="calcMissionETA(' + x + ',' + y + ')">'
                    + '</div>';
                });
              });
              if (hasGuestTroops) {
                html += '<div style="margin-top:16px;padding-top:12px;border-top:1px solid var(--border);">'
                  + '<p style="color:var(--accent2);font-size:.85rem;">ğŸ›¡ï¸ Tropas aliadas estacionadas aquÃ­:</p>'
                  + '<p style="color:var(--dim);font-size:.68rem;margin-top:-6px;margin-bottom:8px;">Puedes incluirlas en el ataque. Sus bajas son permanentes.</p>'
                  + '</div>';
                html += guestHtml;
              }
            }
          } catch (e) { /* ignorar error de guest_troops */ }
        }
      }

      // ETA based on distance + slowest troop
      var dist = Math.max(Math.abs(x - activeVillage.x), Math.abs(y - activeVillage.y));
      html += '</div>'
        + '<div style="padding:8px 15px;border-top:1px solid var(--border);background:var(--panel2);">'
        + '<div style="font-size:.68rem;color:var(--dim);margin-bottom:2px;">ğŸ“ Distancia: ' + dist + ' casillas</div>'
        + '<div id="missionETA" style="font-size:.8rem;color:var(--accent);">Selecciona tropas para ver ETA</div>'
        + '</div>'
        + '<div class="bld-modal-footer">'
        + '<button class="bld-footer-btn avail" onclick="executeMissionClick(\'' + type + '\', \'' + targetId + '\', ' + x + ', ' + y + ')">Confirmar MisiÃ³n</button>'
        + '</div>'
        + '</div></div>';
      var wrap = document.getElementById('bldModal'); // reusing building modal container
      wrap.innerHTML = html;
      wrap.style.display = 'block';
    }

    function calcMissionETA(destX, destY) {
      if (!activeVillage) return;
      var dist = Math.max(Math.abs(destX - activeVillage.x), Math.abs(destY - activeVillage.y));
      var minSpeed = Infinity;
      Object.keys(TROOP_TYPES).forEach(function (k) {
        var input = document.getElementById('mUnits_' + k);
        if (input && parseInt(input.value) > 0) {
          var spd = TROOP_TYPES[k].speed || 1;
          if (spd < minSpeed) minSpeed = spd;
        }
      });
      Object.keys(CREATURE_TYPES).forEach(function (k) {
        var input = document.getElementById('mUnits_' + k);
        if (input && parseInt(input.value) > 0) {
          var spd = CREATURE_TYPES[k].speed || 1;
          if (spd < minSpeed) minSpeed = spd;
        }
      });
      var etaEl = document.getElementById('missionETA');
      if (!etaEl) return;
      if (!isFinite(minSpeed)) {
        etaEl.textContent = 'Selecciona tropas para ver ETA';
        etaEl.style.color = 'var(--dim)';
        return;
      }
      // Speed = casillas/min
      var etaSecs = Math.ceil((dist / minSpeed) * 60);
      var arrivalTime = new Date(Date.now() + etaSecs * 1000);
      var arrStr = arrivalTime.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
      etaEl.textContent = 'â± ' + fmtTime(etaSecs) + ' Â· Llegada ~' + arrStr + ' (vel. mÃ­n: ' + minSpeed + ')';
      etaEl.style.color = 'var(--accent)';
    }

    function closeMissionOverlay(event) {
      if (event.target.id === 'missionOverlay') {
        document.getElementById('bldModal').style.display = 'none';
      }
    }

    async function executeMissionClick(type, targetId, x, y) {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      var res = calcRes(vs);
      var selectedTroops = {};
      var total = 0;

      // Collect troops
      Object.keys(TROOP_TYPES).forEach(k => {
        var el = document.getElementById('mUnits_' + k);
        if (el) {
          var val = parseInt(el.value) || 0;
          if (val > 0) {
            selectedTroops[k] = val;
            total += val;
          }
        }
      });

      // Collect creatures
      Object.keys(CREATURE_TYPES).forEach(k => {
        var el = document.getElementById('mUnits_' + k);
        if (el) {
          var val = parseInt(el.value) || 0;
          if (val > 0) {
            selectedTroops[k] = val;
            total += val;
          }
        }
      });

      if (total <= 0) {
        showNotif("Debes seleccionar al menos una unidad.", "err");
        return;
      }

      // Verificar aldeanos libres si se seleccionaron
      if (selectedTroops.aldeano && selectedTroops.aldeano > 0) {
        var aldLibres = res.aldeanos_libres || 0;
        if (selectedTroops.aldeano > aldLibres) {
          showNotif('Solo tienes ' + aldLibres + ' aldeanos libres. ' + (res.aldeanos_total - aldLibres) + ' estÃ¡n asignados a recursos.', 'err');
          return;
        }
      }

      // Verificar tropas y criaturas disponibles
      for (var k in selectedTroops) {
        if (k === 'aldeano') continue; // ya verificado arriba

        if (TROOP_TYPES[k]) {
          var available = vs.troops[k] || 0;
          if (selectedTroops[k] > available) {
            showNotif('No tienes suficientes ' + TROOP_TYPES[k].name + 's', 'err');
            return;
          }
        } else if (CREATURE_TYPES[k]) {
          var available = (vs.creatures && vs.creatures[k]) || 0;
          if (selectedTroops[k] > available) {
            showNotif('No tienes suficientes ' + CREATURE_TYPES[k].name + 's', 'err');
            return;
          }
        }
      }

      document.getElementById('bldModal').style.display = 'none';
      // Recolectar tropas aliadas agrupadas por contingente (gt_id â†’ {owner_id, origin_village_id, troops})
      var contingentsMap = {};
      var guestInputs = document.querySelectorAll('[id^="gUnits_"]');
      guestInputs.forEach(function (el) {
        var val = parseInt(el.value) || 0;
        if (val <= 0) return;
        var gtId = el.dataset.gtid;
        var troopKey = el.dataset.troop;
        if (!contingentsMap[gtId]) {
          contingentsMap[gtId] = {
            gt_id: gtId,
            owner_id: el.dataset.ownerid,
            origin_village_id: el.dataset.origvid,
            troops: {}
          };
        }
        contingentsMap[gtId].troops[troopKey] = (contingentsMap[gtId].troops[troopKey] || 0) + val;
        total += val;
      });
      var guestContingents = Object.values(contingentsMap).filter(function (c) {
        return Object.values(c.troops).some(function (n) { return n > 0; });
      });
      if (total <= 0) { showNotif('Debes seleccionar al menos una unidad.', 'err'); return; }
      await startMission(type, x, y, targetId, selectedTroops,
        guestContingents.length > 0 ? guestContingents : null);
    }

    function goToCoords() {
      var x = parseInt(document.getElementById('mapGoX').value);
      var y = parseInt(document.getElementById('mapGoY').value);
      if (isNaN(x) || isNaN(y)) { showNotif('Coordenadas invÃ¡lidas', 'err'); return; }
      if (x < 1 || x > MAP_SIZE || y < 1 || y > MAP_SIZE) {
        showNotif('Coordenadas fuera del mapa (1-' + MAP_SIZE + ')', 'err'); return;
      }
      mapCamX = x;
      mapCamY = y;
      renderMap();
      showNotif('Navegando a [' + x + ', ' + y + ']', 'ok');
    }

    async function foundVillage(x, y) {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      var myVillagesList = myVillages || [];
      if (myVillagesList.length >= 10) { showNotif('MÃ¡ximo 10 aldeas', 'err'); return; }
      var exploradores = (vs.troops && vs.troops.explorador) || 0;
      if (exploradores < 1) { showNotif('Necesitas al menos 1 explorador', 'err'); return; }
      var aldeanos = (vs.troops && vs.troops.aldeano) || 0;
      if (aldeanos < 50) { showNotif('Necesitas 50 aldeanos', 'err'); return; }

      // Calcular tiempo de viaje â€” el mÃ¡s lento marca la velocidad (aldeano speed=1, explorador speed=4)
      var dist = Math.max(Math.abs(x - activeVillage.x), Math.abs(y - activeVillage.y));
      var foundingTroops = { explorador: 1, aldeano: 50 };
      var minSpeed = Object.keys(foundingTroops).reduce(function (min, k) {
        var spd = (TROOP_TYPES[k] && TROOP_TYPES[k].speed) || 1;
        return Math.min(min, spd);
      }, 999);
      if (minSpeed === 999) minSpeed = 1;
      var seconds = Math.ceil((dist / minSpeed) * MISSION_FACTOR);
      var arrivalStr = new Date(Date.now() + seconds * 1000).toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });

      if (!confirm('Fundar aldea en [' + x + ', ' + y + ']?\n\nConsume 1 explorador + 50 aldeanos.\nTiempo de viaje: ' + fmtTime(seconds) + ' (llegada ~' + arrivalStr + ')')) return;

      // Guardar valores originales por si hay que revertir
      var origExploradores = exploradores;
      var origAldeanos = aldeanos;
      var origAssigned = vs.aldeanos_assigned ? JSON.parse(JSON.stringify(vs.aldeanos_assigned)) : null;

      // Consumir tropas
      vs.troops.explorador = Math.max(0, exploradores - 1);
      consumeAldeanos(vs, 50);

      // AÃ±adir misiÃ³n de fundaciÃ³n al queue
      var finishAt = new Date(Date.now() + seconds * 1000).toISOString();
      if (!vs.mission_queue) vs.mission_queue = [];
      vs.mission_queue.push({
        type: 'found',
        tx: x,
        ty: y,
        targetId: null,
        troops: { explorador: 1, aldeano: 50 },
        finish_at: finishAt,
        start_at: new Date().toISOString()
      });

      try {
        flushVillage();
        showNotif('ğŸ  Colonos en camino a [' + x + ', ' + y + ']! LlegarÃ¡n en ' + fmtTime(seconds), 'ok');
        tick();
      } catch (e) {
        // Revertir si falla el guardado
        vs.troops.explorador = origExploradores;
        vs.troops.aldeano = origAldeanos;
        if (origAssigned) vs.aldeanos_assigned = origAssigned;
        vs.mission_queue = vs.mission_queue.filter(function (m) { return m.finish_at !== finishAt; });
        showNotif('Error al enviar colonos: ' + (e.message || e), 'err');
        console.error('foundVillage error:', e);
      }
    }

    async function executeFounding(m) {
      // Crear la aldea en Supabase cuando llegan los colonos
      var myVillagesList = myVillages || [];
      if (myVillagesList.length >= 10) {
        await sendSystemReport(currentUser.id, 'âš ï¸ COLONOS RECHAZADOS',
          'Tus colonos llegaron a [' + m.tx + ', ' + m.ty + '] pero ya tienes el mÃ¡ximo de 10 aldeas. Los colonos se perdieron.');
        return;
      }
      // Verificar que la casilla siga libre
      var occupied = allVillages.find(function (v) { return v.x === m.tx && v.y === m.ty; });
      if (occupied) {
        await sendSystemReport(currentUser.id, 'âš ï¸ COLONOS RECHAZADOS',
          'Tus colonos llegaron a [' + m.tx + ', ' + m.ty + '] pero otro jugador ya fundÃ³ una aldea ahÃ­. Los colonos se perdieron.');
        return;
      }
      try {
        var newVillageName = 'Aldea ' + (myVillagesList.length + 1);
        var r = await sbClient.from('villages').insert({
          owner_id: currentUser.id,
          name: newVillageName,
          cx: m.tx,
          cy: m.ty,
          build_queue: null,
          mission_queue: [],
          summoning_queue: [],
          training_queue: []
        }).select('id').single();
        if (r.error) throw r.error;

        var newId = r.data.id;
        await sbClient.from('resources').insert({ village_id: newId, madera: 500, piedra: 300, hierro: 100, prov: 200, esencia: 0 });
        await sbClient.from('buildings').insert({
          village_id: newId,
          aserradero: 1, cantera: 1, minehierro: 1, granja: 1, almacen: 1,
          torre: 1, barracas: 1, circulo: 1, reclutamiento: 1,
          muralla: 0, lab: 0
        });
        var newTroops = { village_id: newId };
        Object.keys(TROOP_TYPES).forEach(function (k) { newTroops[k] = k === 'aldeano' ? 50 : 0; });
        await sbClient.from('troops').insert(newTroops);

        await sendSystemReport(currentUser.id, 'ğŸ  Â¡NUEVA ALDEA FUNDADA!',
          'Tus colonos han llegado a [' + m.tx + ', ' + m.ty + '] y han fundado ' + newVillageName + '.\nÂ¡Ya puedes seleccionarla en el desplegable de aldeas!');
        showNotif('Â¡Nueva aldea fundada en [' + m.tx + ', ' + m.ty + ']!', 'ok');
        await loadMyVillages();
        renderMap();
      } catch (e) {
        console.error('executeFounding error:', e);
        await sendSystemReport(currentUser.id, 'âŒ ERROR AL FUNDAR ALDEA',
          'Los colonos llegaron a [' + m.tx + ', ' + m.ty + '] pero ocurriÃ³ un error al crear la aldea: ' + (e.message || e));
      }
    }

    async function openMapDM(targetUserId, targetName) {
      if (!targetUserId) { showNotif('No se puede identificar al jugador', 'err'); return; }
      showNotif('Abriendo chat con ' + targetName + 'â€¦', 'ok');
      // Navigate to messages and open DM
      showPage('messages', document.querySelector('.nav-item[onclick*="messages"]'));
      await new Promise(r => setTimeout(r, 300));
      try {
        var r = await sbClient.rpc('get_or_create_dm_thread', {
          p_user1: currentUser.id, p_user2: targetUserId
        });
        if (r.error) throw r.error;
        currentThreadId = r.data;
        currentThreadType = 'dm';
        renderMessagesHeader('dm', 'DM con ' + targetName);
        subscribeToThread(currentThreadId);
        await loadThreadMessages('dm');
        await renderThreads();
      } catch (e) {
        showNotif('Error: ' + e.message, 'err');
      }
    }

    function selectCell(village, isOwn, isAlly, x, y) {
      // backward compat: if called with 4 args (old path), shift
      if (typeof isAlly === 'number') { y = x; x = isAlly; isAlly = false; }
      var panel = document.getElementById('mapPanel');
      var title = document.getElementById('mapPanelTitle');
      var sub = document.getElementById('mapPanelSub');
      var actions = document.getElementById('mapActions');
      panel.classList.add('show');

      var inRange = isInTorreRange(x, y);
      var rng = activeVillage ? getTorreRange(activeVillage.state.buildings) : 0;
      var rngTag = rng === 0
        ? ' <span style="color:var(--danger);font-size:.64rem;">âš  Sin torre</span>'
        : (inRange
          ? ' <span style="color:var(--ok);font-size:.64rem;">âœ“ En rango (' + rng + ')</span>'
          : ' <span style="color:var(--danger);font-size:.64rem;">âœ— Fuera de rango (' + rng + ')</span>');

      if (!village) {
        title.textContent = 'Casilla vacÃ­a';
        sub.innerHTML = '[' + x + ', ' + y + ']' + rngTag;
        if (inRange) {
          var myVillageCount = (myVillages || []).length;
          if (myVillageCount >= 10) {
            actions.innerHTML = '<span style="font-size:.7rem;color:var(--danger);">MÃ¡ximo 10 aldeas alcanzado.</span>';
          } else {
            actions.innerHTML = '<button class="map-action-btn move" onclick="foundVillage(' + x + ',' + y + ')">ğŸ  Fundar Aldea<br><span style="font-size:.6rem;color:rgba(255,255,255,.6);">Consume 1 explorador + 50 aldeanos</span></button>';
          }
        } else {
          var rng2 = activeVillage ? getTorreRange(activeVillage.state.buildings) : 0;
          var outMsg = rng2 === 0
            ? '<span style="font-size:.7rem;color:var(--danger)">âš  No tienes Torre de VigÃ­a. ConstrÃºyela para poder fundar aldeas aquÃ­.</span>'
            : '<span style="font-size:.7rem;color:var(--danger)">âš  Fuera de alcance. Mejora la Torre de VigÃ­a (nivel actual: ' + rng2 + ') para fundar una aldea aquÃ­.</span>';
          actions.innerHTML = outMsg;
        }
        return;
      }

      var ownerName = (village.state && village.state.owner_name) ? village.state.owner_name : 'Desconocido';

      if (isOwn) {
        title.textContent = (village.name || 'Mi Aldea') + ' ğŸ ';
        sub.innerHTML = '[' + x + ', ' + y + '] Â· Tuya' + rngTag;
        if (village.id === activeVillage.id) {
          actions.innerHTML = '<span style="font-size:.7rem;color:var(--dim);">Esta es tu aldea activa.</span>';
        } else {
          var vid2 = village.id || '';
          var vname2 = escapeJs(village.name || 'Aldea');
          actions.innerHTML = ''
            + '<button class="map-action-btn move" onclick="openMoveModal(\'' + vid2 + '\',\'' + vname2 + '\',' + x + ',' + y + ',false)">âš” Mover tropas</button>'
            + '<button class="map-action-btn move" style="background:rgba(212,146,58,.1);border-color:var(--madera);color:var(--madera);" onclick="openTransportModal(\'' + vid2 + '\',\'' + vname2 + '\',' + x + ',' + y + ',false)">ğŸ“¦ Transportar recursos</button>';
        }
      } else if (isAlly) {
        var allyOwnerId = (village.owner_id || '');
        var allyVid = (village.id || '');
        var allyVname = escapeJs(village.name || 'Aldea aliada');
        title.textContent = (village.name || 'Aldea aliada') + ' ğŸ¤';
        sub.innerHTML = '[' + x + ', ' + y + '] Â· Aliado' + rngTag;
        if (inRange) {
          actions.innerHTML = ''
            + '<button class="map-action-btn move" onclick="openMoveModal(\'' + allyVid + '\',\'' + allyVname + '\',' + x + ',' + y + ',true)">ğŸ›¡ï¸ Enviar refuerzo</button>'
            + '<button class="map-action-btn move" style="background:rgba(212,146,58,.1);border-color:var(--madera);color:var(--madera);" onclick="openTransportModal(\'' + allyVid + '\',\'' + allyVname + '\',' + x + ',' + y + ',true)">ğŸ“¦ Enviar recursos</button>'
            + '<button class="map-action-btn spy" style="background:rgba(0,212,255,.1);border-color:var(--accent);color:var(--accent);" onclick="openMapDM(\'' + allyOwnerId + '\',\'' + escapeJs(ownerName || 'Aliado') + '\')">âœ‰ï¸ Mensaje</button>';
        } else {
          actions.innerHTML = '<span style="color:var(--danger);font-size:.72rem;">âš  Fuera de alcance â€” mejora la Torre de VigÃ­a</span>';
        }
      } else {
        title.textContent = (village.name || 'Aldea enemiga') + ' âš”ï¸';
        sub.textContent = '[' + x + ', ' + y + '] Â· ' + String(ownerName || '');
        var span = document.createElement('span');
        span.style.fontSize = '.64rem';
        span.style.marginLeft = '6px';
        if (rng === 0) { span.style.color = 'var(--danger)'; span.textContent = 'âš  Sin torre'; }
        else if (inRange) { span.style.color = 'var(--ok)'; span.textContent = 'âœ“ En rango (' + rng + ')'; }
        else { span.style.color = 'var(--danger)'; span.textContent = 'âœ— Fuera de rango (' + rng + ')'; }
        sub.appendChild(span);
        var ownerId = (village.owner_id || village.user_id || '');
        var vid = (village.id || '');
        if (inRange) {
          actions.innerHTML = ''
            + '<button class="map-action-btn atk" onclick="openMissionModal(\'attack\',\'' + vid + '\',' + x + ',' + y + ')">âš”ï¸ Atacar</button>'
            + '<button class="map-action-btn spy" onclick="openMissionModal(\'spy\',\'' + vid + '\',' + x + ',' + y + ')">ğŸ” Espiar</button>'
            + '<button class="map-action-btn move" style="background:rgba(0,212,255,.1);border-color:var(--accent);color:var(--accent);" onclick="openMapDM(\'' + ownerId + '\',\'' + escapeJs(ownerName) + '\')">âœ‰ï¸ Mensaje</button>';
        } else {
          actions.innerHTML = '<span style="color:var(--danger);font-size:.72rem;">âš  Fuera de alcance â€” mejora la Torre de VigÃ­a</span>';
        }
      }
    }

    // ================================================================
    // MOVE / TRANSPORT / REINFORCE SYSTEM
    // ================================================================

    var _allyUserIds = new Set();

    async function loadAllyUserIds() {
      _allyUserIds = new Set();
      if (!_myAllianceId) return;
      try {
        var r = await sbClient.from('alliance_members')
          .select('user_id').eq('alliance_id', _myAllianceId).eq('status', 'active');
        if (r.data) r.data.forEach(function (m) {
          if (m.user_id !== currentUser.id) _allyUserIds.add(m.user_id);
        });
      } catch (e) { console.warn('loadAllyUserIds error', e); }
    }

    function calcTotalCapacity(troops) {
      var cap = 0;
      Object.keys(troops).forEach(function (k) {
        var count = troops[k] || 0;
        if (count <= 0) return;
        var td = TROOP_TYPES[k] || CREATURE_TYPES[k];
        cap += count * ((td && td.capacity) || 0);
      });
      return cap;
    }

    // ============================================================
    // MOVER TROPAS - 2 PASOS
    // Paso 1: Seleccionar tropas â†’ Paso 2: Seleccionar recursos (opcional)
    // Las tropas SE QUEDAN permanentemente en destino
    // ============================================================
    function openMoveModal(destVillageId, destVillageName, tx, ty, isAllyDest) {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      var res = calcRes(vs);
      var troops = vs.troops || {};
      var aldLibres = res.aldeanos_libres || 0;
      var dist = Math.max(Math.abs(tx - activeVillage.x), Math.abs(ty - activeVillage.y));

      // PASO 1: Seleccionar tropas
      var troopRows = '';
      var hasTroops = false;
      Object.keys(TROOP_TYPES).forEach(function (k) {
        var count = (k === 'aldeano') ? aldLibres : (troops[k] || 0);
        if (count <= 0) return;
        hasTroops = true;
        var capInfo = (TROOP_TYPES[k].capacity || 0) > 0 ? ' â€¢ Cap: ' + TROOP_TYPES[k].capacity : '';
        troopRows += '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">'
          + '<span>' + TROOP_TYPES[k].icon + ' ' + TROOP_TYPES[k].name + ' (' + count + ' disp.)<span style="color:var(--dim);font-size:.7rem;">' + capInfo + '</span></span>'
          + '<input type="number" id="mv_troop_' + k + '" value="0" min="0" max="' + count + '" style="width:64px;" oninput="calcMoveCapacity()">'
          + '</div>';
      });

      // Agregar criaturas
      var creatures = vs.creatures || defaultCreatures();
      Object.keys(CREATURE_TYPES).forEach(function (k) {
        var count = creatures[k] || 0;
        if (count <= 0) return;
        hasTroops = true;
        troopRows += '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">'
          + '<span>' + CREATURE_TYPES[k].icon + ' ' + CREATURE_TYPES[k].name + ' (' + count + ' disponibles)</span>'
          + '<input type="number" id="mv_troop_' + k + '" value="0" min="0" max="' + count + '" style="width:64px;" oninput="calcMoveCapacity()">'
          + '</div>';
      });

      if (!hasTroops) {
        showNotif('No tienes tropas disponibles.', 'err');
        return;
      }

      var titleTxt = isAllyDest ? 'ğŸ›¡ï¸ Enviar refuerzo' : 'âš” Mover tropas';
      var note = isAllyDest
        ? '<div style="font-size:.72rem;color:var(--accent2);margin-bottom:10px;">Las tropas se quedarÃ¡n en la aldea aliada. TÃº o el aliado podÃ©is llamarlas de vuelta.</div>'
        : '<div style="font-size:.72rem;color:var(--accent);margin-bottom:10px;">Las tropas pasarÃ¡n a ser de esta aldea permanentemente.</div>';

      var html = '<div class="bld-modal-overlay" id="moveOverlay" onclick="closeMoveOverlay(event)">'
        + '<div class="bld-modal" style="max-width:420px;">'
        + '<div class="bld-modal-head"><div class="bld-modal-icon">' + (isAllyDest ? 'ğŸ›¡ï¸' : 'âš”') + '</div>'
        + '<div><div class="bld-modal-title">' + titleTxt + '</div>'
        + '<div class="bld-modal-sub">Paso 1/2: Selecciona tropas â€¢ Hacia ' + escapeHtml(destVillageName) + '</div></div>'
        + '<button class="bld-modal-close" onclick="document.getElementById(\'bldModal\').style.display=\'none\';">&#x2715;</button>'
        + '</div><div class="bld-modal-body" style="padding:15px;">' + note
        + '<div style="font-size:.68rem;color:var(--accent);margin-bottom:6px;">Capacidad de carga: <b id="mvCapDisplay">0</b> unidades</div>'
        + troopRows
        + '</div><div style="padding:8px 15px;border-top:1px solid var(--border);background:var(--panel2);">'
        + '<div style="font-size:.68rem;color:var(--dim);">ğŸ“ Distancia: ' + dist + ' casillas</div>'
        + '<div id="mvTroopETA" style="font-size:.8rem;color:var(--dim);">Selecciona tropas para ver ETA</div>'
        + '</div><div class="bld-modal-footer">'
        + '<button class="bld-footer-btn avail" onclick="moveStep2(\'' + destVillageId + '\',\'' + escapeJs(destVillageName) + '\',' + tx + ',' + ty + ',' + (isAllyDest ? 'true' : 'false') + ')">Siguiente â†’</button>'
        + '</div></div></div>';

      window._moveDest = { vid: destVillageId, name: destVillageName, tx: tx, ty: ty, isAlly: isAllyDest, dist: dist };

      var wrap = document.getElementById('bldModal');
      wrap.innerHTML = html;
      wrap.style.display = 'block';
    }

    function calcMoveCapacity() {
      var totalCap = 0;
      var minSpeed = Infinity;
      var hasTroops = false;

      Object.keys(TROOP_TYPES).forEach(function (k) {
        var el = document.getElementById('mv_troop_' + k);
        if (!el) return;
        var qty = parseInt(el.value) || 0;
        if (qty > 0) {
          hasTroops = true;
          totalCap += qty * (TROOP_TYPES[k].capacity || 0);
          var spd = TROOP_TYPES[k].speed || 1;
          if (spd < minSpeed) minSpeed = spd;
        }
      });

      Object.keys(CREATURE_TYPES).forEach(function (k) {
        var el = document.getElementById('mv_troop_' + k);
        if (!el) return;
        var qty = parseInt(el.value) || 0;
        if (qty > 0) {
          hasTroops = true;
          // Criaturas NO tienen capacidad de carga
          var spd = CREATURE_TYPES[k].speed || 1;
          if (spd < minSpeed) minSpeed = spd;
        }
      });

      var capEl = document.getElementById('mvCapDisplay');
      if (capEl) capEl.textContent = totalCap;

      var etaEl = document.getElementById('mvTroopETA');
      if (etaEl) {
        if (!hasTroops) {
          etaEl.textContent = 'Selecciona tropas para ver ETA';
          etaEl.style.color = 'var(--dim)';
        } else {
          var dist = (window._moveDest && window._moveDest.dist) || 0;
          var secs = Math.ceil((dist / minSpeed) * MISSION_FACTOR);
          var arr = new Date(Date.now() + secs * 1000).toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
          etaEl.textContent = 'â± ' + fmtTime(secs) + ' â€¢ Llegada ~' + arr + ' (vel: ' + minSpeed + ')';
          etaEl.style.color = 'var(--accent)';
        }
      }
    }

    function moveStep2(destVillageId, destVillageName, tx, ty, isAllyDest) {
      // Recoger tropas seleccionadas
      var selectedTroops = {};
      var totalCap = 0;
      var minSpeed = Infinity;
      var hasTroops = false;

      Object.keys(TROOP_TYPES).forEach(function (k) {
        var el = document.getElementById('mv_troop_' + k);
        if (!el) return;
        var qty = parseInt(el.value) || 0;
        if (qty > 0) {
          selectedTroops[k] = qty;
          hasTroops = true;
          totalCap += qty * (TROOP_TYPES[k].capacity || 0);
          var spd = TROOP_TYPES[k].speed || 1;
          if (spd < minSpeed) minSpeed = spd;
        }
      });

      Object.keys(CREATURE_TYPES).forEach(function (k) {
        var el = document.getElementById('mv_troop_' + k);
        if (!el) return;
        var qty = parseInt(el.value) || 0;
        if (qty > 0) {
          selectedTroops[k] = qty;
          hasTroops = true;
          var spd = CREATURE_TYPES[k].speed || 1;
          if (spd < minSpeed) minSpeed = spd;
        }
      });

      if (!hasTroops) {
        showNotif('Selecciona al menos una tropa.', 'err');
        return;
      }

      // PASO 2: Seleccionar recursos (opcional)
      var vs = activeVillage.state;
      var dist = Math.max(Math.abs(tx - activeVillage.x), Math.abs(ty - activeVillage.y));

      var resRows = '';
      if (totalCap > 0) {
        var resKeys = ['madera', 'piedra', 'hierro', 'provisiones', 'esencia'];
        var resIcons = { madera: 'ğŸŒ²', piedra: 'â›°ï¸', hierro: 'âš™ï¸', provisiones: 'ğŸŒ¾', esencia: 'âœ¨' };
        resKeys.forEach(function (rk) {
          var have = Math.floor(vs.resources[rk] || 0);
          if (have <= 0) return;
          resRows += '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">'
            + '<span>' + resIcons[rk] + ' ' + rk.charAt(0).toUpperCase() + rk.slice(1) + ' (' + fmt(have) + ' disp.)</span>'
            + '<input type="number" id="mv_' + rk + '" value="0" min="0" max="' + Math.min(have, totalCap) + '" style="width:80px;" oninput="calcMoveLoad()">'
            + '</div>';
        });
      }

      var troopSummary = '';
      Object.keys(selectedTroops).forEach(function (k) {
        var typeData = TROOP_TYPES[k] || CREATURE_TYPES[k];
        troopSummary += (typeData.icon || '') + ' ' + selectedTroops[k] + ' ' + (typeData.name || k) + ' â€¢ ';
      });
      troopSummary = troopSummary.slice(0, -3);

      var titleTxt = isAllyDest ? 'ğŸ›¡ï¸ Enviar refuerzo' : 'âš” Mover tropas';
      var note = isAllyDest
        ? 'Las tropas se quedarÃ¡n en la aldea aliada hasta que las llames de vuelta.'
        : 'Las tropas pasarÃ¡n a ser de esta aldea permanentemente.';

      var html = '<div class="bld-modal-overlay" id="moveOverlay" onclick="closeMoveOverlay(event)">'
        + '<div class="bld-modal" style="max-width:420px;">'
        + '<div class="bld-modal-head"><div class="bld-modal-icon">' + (isAllyDest ? 'ğŸ›¡ï¸' : 'âš”') + '</div>'
        + '<div><div class="bld-modal-title">' + titleTxt + '</div>'
        + '<div class="bld-modal-sub">Paso 2/2: Recursos (opcional) â€¢ Hacia ' + escapeHtml(destVillageName) + '</div></div>'
        + '<button class="bld-modal-close" onclick="document.getElementById(\'bldModal\').style.display=\'none\';">&#x2715;</button>'
        + '</div><div class="bld-modal-body" style="padding:15px;">'
        + '<div style="font-size:.7rem;color:var(--dim);margin-bottom:6px;padding:6px 8px;background:var(--panel2);border-radius:4px;">' + troopSummary + '</div>'
        + '<div style="font-size:.68rem;color:var(--accent2);margin-bottom:8px;">' + note + '</div>';

      if (totalCap > 0 && resRows) {
        html += '<div style="font-size:.68rem;color:var(--accent);margin-bottom:6px;">Capacidad: <b id="mvCapDisplay2">' + totalCap + '</b> uds â€¢ Cargado: <b id="mvLoadDisplay" style="color:var(--ok)">0</b></div>'
          + resRows;
      } else if (totalCap > 0) {
        html += '<p style="color:var(--dim);font-size:.75rem;">Sin recursos disponibles para enviar.</p>';
      } else {
        html += '<p style="color:var(--dim);font-size:.75rem;">Las tropas seleccionadas no tienen capacidad de carga.</p>';
      }

      html += '</div><div style="padding:8px 15px;border-top:1px solid var(--border);background:var(--panel2);">'
        + '<div style="font-size:.68rem;color:var(--dim);">ğŸ“ ' + dist + ' casillas â€¢ ETA: <span id="mvETA">' + fmtTime(Math.ceil((dist / minSpeed) * MISSION_FACTOR)) + '</span></div>'
        + '<div id="mvWarning" style="font-size:.68rem;color:var(--danger);min-height:14px;"></div>'
        + '</div><div class="bld-modal-footer">'
        + '<button class="bld-footer-btn" style="background:var(--border);color:var(--dim);" onclick="openMoveModal(\'' + destVillageId + '\',\'' + escapeJs(destVillageName) + '\',' + tx + ',' + ty + ',' + (isAllyDest ? 'true' : 'false') + ')">â† AtrÃ¡s</button>'
        + '<button class="bld-footer-btn avail" onclick="executeMoveClick(\'' + destVillageId + '\',' + tx + ',' + ty + ',' + (isAllyDest ? 'true' : 'false') + ')">Enviar tropas</button>'
        + '</div></div></div>';

      window._moveTotalCap = totalCap;
      window._moveMinSpeed = minSpeed;
      window._moveDist = dist;
      window._moveSelectedTroops = selectedTroops;

      var wrap = document.getElementById('bldModal');
      wrap.innerHTML = html;
      wrap.style.display = 'block';
      if (totalCap > 0) calcMoveLoad();
    }

    function calcMoveLoad() {
      var load = 0;
      ['madera', 'piedra', 'hierro', 'provisiones', 'esencia'].forEach(function (rk) {
        var el = document.getElementById('mv_' + rk);
        if (el) load += parseInt(el.value) || 0;
      });
      var loadEl = document.getElementById('mvLoadDisplay');
      var warnEl = document.getElementById('mvWarning');
      if (loadEl) { loadEl.textContent = load; loadEl.style.color = load > (window._moveTotalCap || 0) ? 'var(--danger)' : 'var(--ok)'; }
      if (warnEl) warnEl.textContent = load > (window._moveTotalCap || 0) ? 'âš  Sobrepasa la capacidad de carga' : '';
    }

    function closeMoveOverlay(event) {
      if (event.target.id === 'moveOverlay') document.getElementById('bldModal').style.display = 'none';
    }

    async function executeMoveClick(destVillageId, tx, ty, isAllyDest) {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      var res = calcRes(vs);

      // Usar tropas pre-seleccionadas del paso 1
      var selectedTroops = window._moveSelectedTroops || {};
      if (Object.keys(selectedTroops).length === 0) {
        showNotif('No hay tropas seleccionadas.', 'err');
        return;
      }

      // Validar que tenemos las tropas
      var aldLibres = res.aldeanos_libres || 0;
      for (var k in selectedTroops) {
        var needed = selectedTroops[k];
        var available = 0;
        if (k === 'aldeano') {
          available = aldLibres;
        } else if (TROOP_TYPES[k]) {
          available = vs.troops[k] || 0;
        } else if (CREATURE_TYPES[k]) {
          available = (vs.creatures && vs.creatures[k]) || 0;
        }
        if (needed > available) {
          var typeData = TROOP_TYPES[k] || CREATURE_TYPES[k];
          showNotif('No tienes suficientes ' + (typeData ? typeData.name : k) + 's.', 'err');
          return;
        }
      }

      // Recoger recursos opcionales
      var cargo = {}; var totalLoad = 0;
      ['madera', 'piedra', 'hierro', 'provisiones', 'esencia'].forEach(function (rk) {
        var el = document.getElementById('mv_' + rk);
        var v = parseInt((el && el.value) || 0);
        if (v > 0) { cargo[rk] = v; totalLoad += v; }
      });

      // Validar capacidad si hay recursos
      if (totalLoad > 0) {
        var totalCap = window._moveTotalCap || 0;
        if (totalLoad > totalCap) {
          showNotif('Sobrepasa la capacidad de carga.', 'err');
          return;
        }
        for (var rk in cargo) {
          if (cargo[rk] > Math.floor(vs.resources[rk] || 0)) {
            showNotif('No tienes suficientes ' + rk + '.', 'err');
            return;
          }
        }
      }

      document.getElementById('bldModal').style.display = 'none';

      var dist = Math.max(Math.abs(tx - activeVillage.x), Math.abs(ty - activeVillage.y));
      var minSpeed = window._moveMinSpeed || 1;
      var seconds = Math.ceil((dist / minSpeed) * MISSION_FACTOR);
      var finishAt = new Date(Date.now() + seconds * 1000).toISOString();

      snapshotResources(vs);

      // Descontar recursos
      for (var rk in cargo) {
        vs.resources[rk] = Math.max(0, (vs.resources[rk] || 0) - cargo[rk]);
      }

      // Descontar tropas
      Object.keys(selectedTroops).forEach(function (k) {
        if (k === 'aldeano') {
          vs.resources.aldeanos = Math.max(0, (vs.resources.aldeanos || 0) - selectedTroops[k]);
          vs.troops.aldeano = vs.resources.aldeanos;
        } else if (TROOP_TYPES[k]) {
          vs.troops[k] = Math.max(0, (vs.troops[k] || 0) - selectedTroops[k]);
        } else if (CREATURE_TYPES[k]) {
          vs.creatures[k] = Math.max(0, ((vs.creatures && vs.creatures[k]) || 0) - selectedTroops[k]);
        }
      });

      if (!vs.mission_queue) vs.mission_queue = [];
      vs.mission_queue.push({
        type: isAllyDest ? 'reinforce' : 'move',
        tx: tx, ty: ty, targetId: destVillageId,
        troops: selectedTroops,
        cargo: cargo, // Recursos opcionales
        finish_at: finishAt,
        start_at: new Date().toISOString(),
        origin_village_id: activeVillage.id,
        origin_owner_id: currentUser.id
      });

      await flushVillage();
      var cargoMsg = totalLoad > 0 ? ' (con ' + totalLoad + ' recursos)' : '';
      showNotif((isAllyDest ? 'ğŸ›¡ï¸ Refuerzo enviado' : 'âš” Tropas en camino') + cargoMsg + ' â€¢ ' + fmtTime(seconds), 'ok');
      tick();
    }

    function _calcMinTroopSpeed(troops, aldLibres) {
      var minSpeed = Infinity;
      Object.keys(TROOP_TYPES).forEach(function (k) {
        var count = (k === 'aldeano') ? aldLibres : (troops[k] || 0);
        if (count > 0 && (TROOP_TYPES[k].capacity || 0) > 0) {
          var spd = TROOP_TYPES[k].speed || 1;
          if (spd < minSpeed) minSpeed = spd;
        }
      });
      return isFinite(minSpeed) ? minSpeed : 1;
    }

    // ============================================================
    // TRANSPORTE DE MATERIAL - 2 PASOS
    // Paso 1: Seleccionar tropas â†’ Paso 2: Seleccionar recursos
    // Las tropas VAN, DEJAN recursos y VUELVEN
    // ============================================================
    function openTransportModal(destVillageId, destVillageName, tx, ty, isAllyDest) {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      var res = calcRes(vs);
      var troops = vs.troops || {};
      var aldLibres = res.aldeanos_libres || 0;
      var dist = Math.max(Math.abs(tx - activeVillage.x), Math.abs(ty - activeVillage.y));

      // PASO 1: Seleccionar tropas
      var troopRows = '';
      var hasTroops = false;
      Object.keys(TROOP_TYPES).forEach(function (k) {
        var count = (k === 'aldeano') ? aldLibres : (troops[k] || 0);
        if (count <= 0) return;
        if ((TROOP_TYPES[k].capacity || 0) <= 0) return; // Solo tropas con capacidad
        hasTroops = true;
        troopRows += '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">'
          + '<span>' + TROOP_TYPES[k].icon + ' ' + TROOP_TYPES[k].name + ' (' + count + ' disp.) <span style="color:var(--dim);font-size:.7rem;">â€¢ Cap: ' + TROOP_TYPES[k].capacity + '</span></span>'
          + '<input type="number" id="tr_troop_' + k + '" value="0" min="0" max="' + count + '" style="width:64px;" oninput="calcTransportCapacity()">'
          + '</div>';
      });

      if (!hasTroops) {
        showNotif('No tienes tropas con capacidad de carga disponibles.', 'err');
        return;
      }

      var html = '<div class="bld-modal-overlay" id="transportOverlay" onclick="closeTransportOverlay(event)">'
        + '<div class="bld-modal" style="max-width:420px;">'
        + '<div class="bld-modal-head"><div class="bld-modal-icon">ğŸ“¦</div>'
        + '<div><div class="bld-modal-title">Transporte de material</div>'
        + '<div class="bld-modal-sub">Paso 1/2: Selecciona tropas â€¢ Hacia ' + escapeHtml(destVillageName) + '</div></div>'
        + '<button class="bld-modal-close" onclick="document.getElementById(\'bldModal\').style.display=\'none\';">&#x2715;</button>'
        + '</div><div class="bld-modal-body" style="padding:15px;">'
        + '<div style="font-size:.72rem;color:var(--accent2);margin-bottom:10px;">Las tropas irÃ¡n, dejarÃ¡n el material y volverÃ¡n automÃ¡ticamente.</div>'
        + '<div style="font-size:.68rem;color:var(--accent);margin-bottom:6px;">Capacidad total: <b id="trCapDisplay">0</b> unidades</div>'
        + troopRows
        + '</div><div style="padding:8px 15px;border-top:1px solid var(--border);background:var(--panel2);">'
        + '<div style="font-size:.68rem;color:var(--dim);">ğŸ“ Distancia: ' + dist + ' casillas</div>'
        + '<div id="trTroopETA" style="font-size:.8rem;color:var(--dim);">Selecciona tropas para ver ETA</div>'
        + '</div><div class="bld-modal-footer">'
        + '<button class="bld-footer-btn avail" onclick="transportStep2(\'' + destVillageId + '\',\'' + escapeJs(destVillageName) + '\',' + tx + ',' + ty + ',' + (isAllyDest ? 'true' : 'false') + ')">Siguiente â†’</button>'
        + '</div></div></div>';

      window._transportDest = { vid: destVillageId, name: destVillageName, tx: tx, ty: ty, isAlly: isAllyDest, dist: dist };

      var wrap = document.getElementById('bldModal');
      wrap.innerHTML = html;
      wrap.style.display = 'block';
    }

    function calcTransportCapacity() {
      var totalCap = 0;
      var minSpeed = Infinity;
      var hasTroops = false;

      Object.keys(TROOP_TYPES).forEach(function (k) {
        var el = document.getElementById('tr_troop_' + k);
        if (!el) return;
        var qty = parseInt(el.value) || 0;
        if (qty > 0) {
          hasTroops = true;
          totalCap += qty * (TROOP_TYPES[k].capacity || 0);
          var spd = TROOP_TYPES[k].speed || 1;
          if (spd < minSpeed) minSpeed = spd;
        }
      });

      var capEl = document.getElementById('trCapDisplay');
      if (capEl) capEl.textContent = totalCap;

      var etaEl = document.getElementById('trTroopETA');
      if (etaEl) {
        if (!hasTroops) {
          etaEl.textContent = 'Selecciona tropas para ver ETA';
          etaEl.style.color = 'var(--dim)';
        } else {
          var dist = (window._transportDest && window._transportDest.dist) || 0;
          var secs = Math.ceil((dist / minSpeed) * MISSION_FACTOR);
          var arr = new Date(Date.now() + secs * 1000).toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
          etaEl.textContent = 'â± Ida: ' + fmtTime(secs) + ' â€¢ Vuelta: ' + fmtTime(secs) + ' â€¢ Llegada ~' + arr + ' (vel: ' + minSpeed + ')';
          etaEl.style.color = 'var(--accent)';
        }
      }
    }

    function transportStep2(destVillageId, destVillageName, tx, ty, isAllyDest) {
      // Recoger tropas seleccionadas
      var selectedTroops = {};
      var totalCap = 0;
      var minSpeed = Infinity;
      var hasTroops = false;

      Object.keys(TROOP_TYPES).forEach(function (k) {
        var el = document.getElementById('tr_troop_' + k);
        if (!el) return;
        var qty = parseInt(el.value) || 0;
        if (qty > 0) {
          selectedTroops[k] = qty;
          hasTroops = true;
          totalCap += qty * (TROOP_TYPES[k].capacity || 0);
          var spd = TROOP_TYPES[k].speed || 1;
          if (spd < minSpeed) minSpeed = spd;
        }
      });

      if (!hasTroops) {
        showNotif('Selecciona al menos una tropa.', 'err');
        return;
      }

      // PASO 2: Seleccionar recursos
      var vs = activeVillage.state;
      var dist = Math.max(Math.abs(tx - activeVillage.x), Math.abs(ty - activeVillage.y));

      var resRows = '';
      var resKeys = ['madera', 'piedra', 'hierro', 'provisiones', 'esencia'];
      var resIcons = { madera: 'ğŸŒ²', piedra: 'â›°ï¸', hierro: 'âš™ï¸', provisiones: 'ğŸŒ¾', esencia: 'âœ¨' };
      resKeys.forEach(function (rk) {
        var have = Math.floor(vs.resources[rk] || 0);
        if (have <= 0) return;
        resRows += '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">'
          + '<span>' + resIcons[rk] + ' ' + rk.charAt(0).toUpperCase() + rk.slice(1) + ' (' + fmt(have) + ' disp.)</span>'
          + '<input type="number" id="tr_' + rk + '" value="0" min="0" max="' + Math.min(have, totalCap) + '" style="width:80px;" oninput="calcTransportLoad()">'
          + '</div>';
      });

      var troopSummary = '';
      Object.keys(selectedTroops).forEach(function (k) {
        troopSummary += TROOP_TYPES[k].icon + ' ' + selectedTroops[k] + ' ' + TROOP_TYPES[k].name + '(s) â€¢ ';
      });
      troopSummary = troopSummary.slice(0, -3); // quitar Ãºltimo â€¢

      var html = '<div class="bld-modal-overlay" id="transportOverlay" onclick="closeTransportOverlay(event)">'
        + '<div class="bld-modal" style="max-width:420px;">'
        + '<div class="bld-modal-head"><div class="bld-modal-icon">ğŸ“¦</div>'
        + '<div><div class="bld-modal-title">Transporte de material</div>'
        + '<div class="bld-modal-sub">Paso 2/2: Selecciona recursos â€¢ Hacia ' + escapeHtml(destVillageName) + '</div></div>'
        + '<button class="bld-modal-close" onclick="document.getElementById(\'bldModal\').style.display=\'none\';">&#x2715;</button>'
        + '</div><div class="bld-modal-body" style="padding:15px;">'
        + '<div style="font-size:.7rem;color:var(--dim);margin-bottom:6px;padding:6px 8px;background:var(--panel2);border-radius:4px;">' + troopSummary + '</div>'
        + '<div style="font-size:.68rem;color:var(--accent);margin-bottom:6px;">Capacidad: <b id="trCapDisplay2">' + totalCap + '</b> uds â€¢ Cargado: <b id="trLoadDisplay" style="color:var(--ok)">0</b></div>'
        + (resRows || '<p style="color:var(--dim);">Sin recursos disponibles.</p>')
        + '</div><div style="padding:8px 15px;border-top:1px solid var(--border);background:var(--panel2);">'
        + '<div style="font-size:.68rem;color:var(--dim);">ğŸ“ ' + dist + ' casillas â€¢ ETA: <span id="trETA">' + fmtTime(Math.ceil((dist / minSpeed) * MISSION_FACTOR)) + '</span></div>'
        + '<div id="trWarning" style="font-size:.68rem;color:var(--danger);min-height:14px;"></div>'
        + '</div><div class="bld-modal-footer">'
        + '<button class="bld-footer-btn" style="background:var(--border);color:var(--dim);" onclick="openTransportModal(\'' + destVillageId + '\',\'' + escapeJs(destVillageName) + '\',' + tx + ',' + ty + ',' + (isAllyDest ? 'true' : 'false') + ')">â† AtrÃ¡s</button>'
        + '<button class="bld-footer-btn avail" onclick="executeTransportClick(\'' + destVillageId + '\',' + tx + ',' + ty + ',' + (isAllyDest ? 'true' : 'false') + ')">Enviar transporte</button>'
        + '</div></div></div>';

      window._transportTotalCap = totalCap;
      window._transportMinSpeed = minSpeed;
      window._transportDist = dist;
      window._transportSelectedTroops = selectedTroops;

      var wrap = document.getElementById('bldModal');
      wrap.innerHTML = html;
      wrap.style.display = 'block';
      calcTransportLoad();
    }

    function closeTransportOverlay(event) {
      if (event.target.id === 'transportOverlay') {
        document.getElementById('bldModal').style.display = 'none';
      }
    }

    function calcTransportLoad() {
      var load = 0;
      ['madera', 'piedra', 'hierro', 'provisiones', 'esencia'].forEach(function (rk) {
        var el = document.getElementById('tr_' + rk);
        if (el) load += parseInt(el.value) || 0;
      });
      var loadEl = document.getElementById('trLoadDisplay');
      var warnEl = document.getElementById('trWarning');
      var etaEl = document.getElementById('trETA');
      if (loadEl) { loadEl.textContent = load; loadEl.style.color = load > (window._transportTotalCap || 0) ? 'var(--danger)' : 'var(--ok)'; }
      if (warnEl) warnEl.textContent = load > (window._transportTotalCap || 0) ? '\u26a0 Sobrepasa la capacidad de carga' : '';
      if (etaEl && window._transportDist != null) {
        var secs = Math.ceil((window._transportDist / (window._transportMinSpeed || 1)) * MISSION_FACTOR);
        etaEl.textContent = fmtTime(secs);
      }
    }

    async function executeTransportClick(destVillageId, tx, ty, isAllyDest) {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      var res = calcRes(vs);
      var aldLibres = res.aldeanos_libres || 0;

      // Validar tropas seleccionadas
      var selectedTroops = window._transportSelectedTroops || {};
      if (Object.keys(selectedTroops).length === 0) {
        showNotif('No hay tropas seleccionadas.', 'err');
        return;
      }

      // Validar que tenemos las tropas
      for (var k in selectedTroops) {
        var needed = selectedTroops[k];
        var available = (k === 'aldeano') ? aldLibres : (vs.troops[k] || 0);
        if (needed > available) {
          showNotif('No tienes suficientes ' + TROOP_TYPES[k].name + 's.', 'err');
          return;
        }
      }

      // Recoger recursos seleccionados
      var cargo = {}; var totalLoad = 0;
      ['madera', 'piedra', 'hierro', 'provisiones', 'esencia'].forEach(function (rk) {
        var el = document.getElementById('tr_' + rk);
        var v = parseInt((el && el.value) || 0);
        if (v > 0) { cargo[rk] = v; totalLoad += v; }
      });

      if (totalLoad <= 0) { showNotif('Selecciona al menos un recurso.', 'err'); return; }
      if (totalLoad > (window._transportTotalCap || 0)) { showNotif('Sobrepasa la capacidad de carga.', 'err'); return; }

      for (var rk in cargo) {
        if (cargo[rk] > Math.floor(vs.resources[rk] || 0)) { showNotif('No tienes suficientes ' + rk + '.', 'err'); return; }
      }

      document.getElementById('bldModal').style.display = 'none';

      var minSpeed = window._transportMinSpeed || 1;
      var dist = Math.max(Math.abs(tx - activeVillage.x), Math.abs(ty - activeVillage.y));
      var seconds = Math.ceil((dist / minSpeed) * MISSION_FACTOR);
      var finishAt = new Date(Date.now() + seconds * 1000).toISOString();

      snapshotResources(vs);

      // Descontar recursos
      for (var rk in cargo) vs.resources[rk] = Math.max(0, (vs.resources[rk] || 0) - cargo[rk]);

      // Descontar tropas temporalmente
      for (var k in selectedTroops) {
        if (k === 'aldeano') {
          vs.resources.aldeanos = Math.max(0, (vs.resources.aldeanos || 0) - selectedTroops[k]);
          vs.troops.aldeano = vs.resources.aldeanos; // mantener sincronizado
        } else {
          vs.troops[k] = Math.max(0, (vs.troops[k] || 0) - selectedTroops[k]);
        }
      }

      if (!vs.mission_queue) vs.mission_queue = [];
      vs.mission_queue.push({
        type: 'transport',
        status: 'going', // 'going' -> 'returning'
        tx: tx,
        ty: ty,
        targetId: destVillageId,
        troops: selectedTroops,
        resources: cargo,
        is_ally: isAllyDest,
        finish_at: finishAt,
        start_at: new Date().toISOString(),
        origin_village_id: activeVillage.id,
        minSpeed: minSpeed
      });

      await flushVillage();
      showNotif('ğŸ“¦ Transporte en camino â€¢ ' + fmtTime(seconds), 'ok');
      tick();
    }

    async function executeMove(m) {
      try {
        var destVillage = myVillages.find(function (v) { return v.id === m.targetId; });
        if (!destVillage) { await loadMyVillages(); destVillage = myVillages.find(function (v) { return v.id === m.targetId; }); }
        if (!destVillage) {
          await sendSystemReport(currentUser.id, '\u26a0\ufe0f MOVIMIENTO FALLIDO', 'Las tropas llegaron a [' + m.tx + ', ' + m.ty + '] pero la aldea no existe o ya no es tuya.');
          return;
        }
        var dvs = destVillage.state;

        // Entregar recursos si hay cargo
        var cargoMsg = '';
        if (m.cargo && Object.keys(m.cargo).length > 0) {
          var rr = await sbClient.from('resources').select('madera,piedra,hierro,prov,esencia').eq('village_id', m.targetId).single();
          if (!rr.error) {
            var newRes = {
              madera: (Number(rr.data.madera) || 0) + (m.cargo.madera || 0),
              piedra: (Number(rr.data.piedra) || 0) + (m.cargo.piedra || 0),
              hierro: (Number(rr.data.hierro) || 0) + (m.cargo.hierro || 0),
              prov: (Number(rr.data.prov) || 0) + (m.cargo.provisiones || 0),
              esencia: (Number(rr.data.esencia) || 0) + (m.cargo.esencia || 0),
              last_update: new Date().toISOString()
            };
            await sbClient.from('resources').update(newRes).eq('village_id', m.targetId);
            dvs.resources.madera = newRes.madera;
            dvs.resources.piedra = newRes.piedra;
            dvs.resources.hierro = newRes.hierro;
            dvs.resources.provisiones = newRes.prov;
            dvs.resources.esencia = newRes.esencia;

            var cargoList = Object.keys(m.cargo).filter(function (k) { return m.cargo[k] > 0; })
              .map(function (k) { return fmt(m.cargo[k]) + ' ' + k; }).join(', ');
            cargoMsg = '\nğŸ“¦ Entregaron: ' + cargoList;
          }
        }

        var freeSlots = Math.max(0, getBarracksCapacity(dvs.buildings) - getBarracksUsed(dvs));
        var slotsNeeded = 0;
        Object.keys(m.troops).forEach(function (k) {
          var count = m.troops[k] || 0;
          if (count > 0) slotsNeeded += (k === 'aldeano') ? count : count * ((TROOP_TYPES[k] && TROOP_TYPES[k].barracasSlots) || 1);
        });
        var pct = slotsNeeded > freeSlots ? freeSlots / slotsNeeded : 1;
        var accepted = {}, rejected = {}, anyRejected = false;
        Object.keys(m.troops).forEach(function (k) {
          var count = m.troops[k] || 0;
          var toAccept = Math.floor(count * pct);
          accepted[k] = toAccept;
          if (toAccept < count) { rejected[k] = count - toAccept; anyRejected = true; }
        });
        Object.keys(accepted).forEach(function (k) {
          if ((accepted[k] || 0) <= 0) return;
          if (TROOP_TYPES[k]) dvs.troops[k] = (dvs.troops[k] || 0) + accepted[k];
          else if (CREATURE_TYPES[k]) { if (!dvs.creatures) dvs.creatures = defaultCreatures(); dvs.creatures[k] = (dvs.creatures[k] || 0) + accepted[k]; }
        });
        await saveVillage(destVillage);
        if (anyRejected) {
          var origV = myVillages.find(function (v) { return v.id === m.origin_village_id; });
          if (origV) {
            Object.keys(rejected).forEach(function (k) {
              if ((rejected[k] || 0) <= 0) return;
              if (TROOP_TYPES[k]) origV.state.troops[k] = (origV.state.troops[k] || 0) + rejected[k];
              else if (CREATURE_TYPES[k]) origV.state.creatures[k] = (origV.state.creatures[k] || 0) + rejected[k];
            });
            await saveVillage(origV);
          }
        }
        var rejMsg = anyRejected ? '\n\u26a0\ufe0f Algunas tropas volvieron (barracas llenas en destino).' : '';
        await sendSystemReport(currentUser.id, '\u2694 TROPAS TRASLADADAS',
          'Tropas llegaron a ' + (destVillage.name || 'aldea') + ' [' + m.tx + ', ' + m.ty + '] y ya son de esa aldea.' + cargoMsg + rejMsg);
        renderMap();
      } catch (e) { console.error('executeMove error:', e); }
    }

    async function executeReinforce(m) {
      if (_guestTroopsTableExists === false) {
        // Tabla no disponible â€” devolver tropas a origen
        var origV = myVillages.find(function (v) { return v.id === m.origin_village_id; });
        if (origV) {
          Object.keys(m.troops).forEach(function (k) {
            if (TROOP_TYPES[k]) origV.state.troops[k] = (origV.state.troops[k] || 0) + (m.troops[k] || 0);
            else if (CREATURE_TYPES[k]) origV.state.creatures[k] = (origV.state.creatures[k] || 0) + (m.troops[k] || 0);
          });
          await saveVillage(origV);
        }
        await sendSystemReport(currentUser.id, 'âš ï¸ REFUERZO NO DISPONIBLE',
          'El sistema de refuerzos a aliados aÃºn no estÃ¡ activo. Las tropas han regresado a casa.');
        return;
      }
      try {
        var troopJson = JSON.stringify(m.troops);
        var r = await sbClient.from('guest_troops').insert({
          owner_id: m.origin_owner_id || currentUser.id,
          origin_village_id: m.origin_village_id,
          host_village_id: m.targetId,
          troops: troopJson,
          arrived_at: new Date().toISOString(),
          recall_requested: false
        });
        if (r.error) throw r.error;
        await sendSystemReport(currentUser.id, '\u{1f6e1}\ufe0f REFUERZO ENTREGADO',
          'Tus tropas llegaron a [' + m.tx + ', ' + m.ty + '] y est\u00e1n estacionadas. Pulsa "Volver" cuando quieras recuperarlas.');
        renderReinforcementsPanel();
      } catch (e) {
        console.error('executeReinforce error:', e);
        var origV = myVillages.find(function (v) { return v.id === m.origin_village_id; });
        if (origV) {
          Object.keys(m.troops).forEach(function (k) {
            if (TROOP_TYPES[k]) origV.state.troops[k] = (origV.state.troops[k] || 0) + (m.troops[k] || 0);
            else if (CREATURE_TYPES[k]) origV.state.creatures[k] = (origV.state.creatures[k] || 0) + (m.troops[k] || 0);
          });
          await saveVillage(origV);
        }
        await sendSystemReport(currentUser.id, '\u26a0\ufe0f REFUERZO FALLIDO',
          'Las tropas no pudieron llegar y volvieron a casa. Error: ' + (e.message || e));
      }
    }

    async function executeTransport(m) {
      try {
        var cargo = m.cargo || {};
        var rr = await sbClient.from('resources').select('madera,piedra,hierro,prov,esencia').eq('village_id', m.targetId).single();
        if (rr.error) throw rr.error;
        var newRes = {
          madera: (Number(rr.data.madera) || 0) + (cargo.madera || 0),
          piedra: (Number(rr.data.piedra) || 0) + (cargo.piedra || 0),
          hierro: (Number(rr.data.hierro) || 0) + (cargo.hierro || 0),
          prov: (Number(rr.data.prov) || 0) + (cargo.provisiones || 0),
          esencia: (Number(rr.data.esencia) || 0) + (cargo.esencia || 0),
          last_update: new Date().toISOString()
        };
        await sbClient.from('resources').update(newRes).eq('village_id', m.targetId);
        var destV = myVillages.find(function (v) { return v.id === m.targetId; });
        if (destV) {
          destV.state.resources.madera = newRes.madera; destV.state.resources.piedra = newRes.piedra;
          destV.state.resources.hierro = newRes.hierro; destV.state.resources.provisiones = newRes.prov;
          destV.state.resources.esencia = newRes.esencia;
        }
        var cargoStr = Object.keys(cargo).filter(function (k) { return cargo[k] > 0; })
          .map(function (k) { return fmt(cargo[k]) + ' ' + k; }).join(', ');
        await sendSystemReport(currentUser.id, '\ud83d\udce6 CARAVANA LLEG\u00d3',
          'Tu caravana entreg\u00f3 ' + cargoStr + ' en [' + m.tx + ', ' + m.ty + '].');
        renderMap();
      } catch (e) {
        console.error('executeTransport error:', e);
        var origV = myVillages.find(function (v) { return v.id === m.origin_village_id; });
        if (origV && m.cargo) {
          Object.keys(m.cargo).forEach(function (rk) { origV.state.resources[rk] = (origV.state.resources[rk] || 0) + (m.cargo[rk] || 0); });
          await saveVillage(origV);
        }
        await sendSystemReport(currentUser.id, '\u26a0\ufe0f CARAVANA FALLIDA',
          'Los recursos volvieron a tu aldea. Error: ' + (e.message || e));
      }
    }

    var _guestTroopsTableExists = null; // null=unknown, true=yes, false=no

    async function renderReinforcementsPanel() {
      var card = document.getElementById('ovReinforcementsCard');
      var box = document.getElementById('ovReinforcementsBox');
      if (!card || !box || !activeVillage) return;
      // Si ya sabemos que la tabla no existe, no volver a intentar
      if (_guestTroopsTableExists === false) { card.style.display = 'none'; return; }
      try {
        var r = await sbClient.from('guest_troops')
          .select('id,owner_id,origin_village_id,host_village_id,troops,arrived_at,recall_requested')
          .eq('host_village_id', activeVillage.id);
        if (r.error) {
          // Tabla no existe o error de schema â€” desactivar silenciosamente
          _guestTroopsTableExists = false;
          card.style.display = 'none';
          return;
        }
        _guestTroopsTableExists = true;
        if (!r.data || r.data.length === 0) { card.style.display = 'none'; return; }
        card.style.display = '';
        var html = '';
        r.data.forEach(function (gt) {
          // Owner name: look up from profileCache if available
          var ownerName = (profileCache[gt.owner_id] && profileCache[gt.owner_id].username) ? profileCache[gt.owner_id].username : gt.owner_id.slice(0, 8);
          // Look up origin village from local allVillages cache
          var origV = allVillages.find(function (v) { return v.id === gt.origin_village_id; })
            || myVillages.find(function (v) { return v.id === gt.origin_village_id; });
          var origName = (origV && origV.name) ? origV.name : 'Aldea';
          var origCoords = origV ? '[' + origV.x + ',' + origV.y + ']' : '';
          var troops = typeof gt.troops === 'string' ? JSON.parse(gt.troops) : (gt.troops || {});
          var troopStr = Object.keys(troops).filter(function (k) { return (troops[k] || 0) > 0; })
            .map(function (k) { return troops[k] + ' ' + ((TROOP_TYPES[k] && TROOP_TYPES[k].icon) || k); }).join(', ');
          var isOwner = gt.owner_id === currentUser.id;
          html += '<div style="display:flex;align-items:center;justify-content:space-between;padding:6px 8px;background:var(--panel2);border-radius:6px;margin-bottom:6px;border:1px solid rgba(96,208,96,.2);">'
            + '<div><span style="color:var(--accent2);">\u{1f6e1}\ufe0f ' + escapeHtml(ownerName) + '</span>'
            + '<span style="color:var(--dim);font-size:.72rem;"> desde ' + escapeHtml(origName) + ' ' + origCoords + '</span>'
            + (gt.recall_requested ? '<span style="color:var(--danger);font-size:.68rem;"> \u00b7 \u21a9 RETIRO SOLICITADO</span>' : '')
            + '<br><span style="font-size:.75rem;">' + escapeHtml(troopStr || 'sin tropas') + '</span>'
            + '</div>'
            + '<button onclick="recallReinforcement(\'' + gt.id + '\')" style="padding:3px 8px;background:rgba(224,64,64,.1);border:1px solid var(--danger);color:var(--danger);border-radius:3px;font-size:.62rem;cursor:pointer;margin-left:8px;">'
            + (isOwner ? '\u21a9 Volver' : '\u21a9 Devolver') + '</button>'
            + (isOwner ? '<button onclick="moveGuestTroops(\'' + gt.id + '\',\'' + escapeJs(JSON.stringify(troops)) + '\')" style="padding:3px 8px;background:rgba(0,212,255,.1);border:1px solid var(--accent);color:var(--accent);border-radius:3px;font-size:.62rem;cursor:pointer;margin-left:4px;">âš” Mover</button>' : '')
            + '</div>';
        });
        box.innerHTML = html;
      } catch (e) { card.style.display = 'none'; }
    }

    async function recallReinforcement(guestTroopId) {
      var r = await sbClient.from('guest_troops').update({ recall_requested: true }).eq('id', guestTroopId);
      if (r.error) { showNotif('Error: ' + r.error.message, 'err'); return; }
      showNotif('\u21a9 Retiro solicitado. Las tropas volver\u00e1n a casa.', 'ok');
      renderReinforcementsPanel();
    }

    function moveGuestTroops(guestTroopId, troopsJson) {
      if (!activeVillage) return;
      var troops = {};
      try { troops = JSON.parse(troopsJson); } catch (e) { showNotif('Error leyendo tropas', 'err'); return; }
      var availableVillages = (myVillages || []).filter(function (v) { return v.id !== activeVillage.id; });
      if (availableVillages.length === 0) {
        showNotif('No tienes otras aldeas a las que mover las tropas.', 'err'); return;
      }
      var opts = availableVillages.map(function (v) {
        return '<option value="' + v.id + '" data-x="' + v.x + '" data-y="' + v.y + '">'
          + escapeHtml(v.name || 'Aldea') + ' [' + v.x + ',' + v.y + ']</option>';
      }).join('');
      var troopStr = Object.keys(troops).filter(function (k) { return (troops[k] || 0) > 0; })
        .map(function (k) {
          var t = TROOP_TYPES[k] || CREATURE_TYPES[k];
          return (t ? t.icon + ' ' + troops[k] + ' ' + t.name : k + ' x' + troops[k]);
        }).join(', ');
      var html = '<div class="bld-modal-overlay" id="moveGuestOverlay" onclick="if(event.target.id===\'moveGuestOverlay\')document.getElementById(\'bldModal\').style.display=\'none\'">'
        + '<div class="bld-modal" style="max-width:380px;">'
        + '<div class="bld-modal-head"><div class="bld-modal-icon">âš”</div>'
        + '<div><div class="bld-modal-title">Mover tropas aliadas</div>'
        + '<div class="bld-modal-sub">Elige aldea destino</div></div>'
        + '<button class="bld-modal-close" onclick="document.getElementById(\'bldModal\').style.display=\'none\'">&#x2715;</button>'
        + '</div><div class="bld-modal-body" style="padding:15px;">'
        + '<div style="color:var(--accent2);font-size:.8rem;margin-bottom:10px;">ğŸ›¡ï¸ Tropas: ' + escapeHtml(troopStr) + '</div>'
        + '<div style="font-size:.75rem;color:var(--dim);margin-bottom:12px;">Las tropas marcharÃ¡n como misiÃ³n de movimiento y serÃ¡n permanentes en destino.</div>'
        + '<label style="font-size:.8rem;color:var(--dim);">Aldea destino:</label>'
        + '<select id="moveGuestDestSel" style="width:100%;margin-top:4px;background:var(--panel2);border:1px solid var(--border);color:var(--text);border-radius:4px;padding:5px;font-family:VT323,monospace;font-size:.9rem;">'
        + opts + '</select>'
        + '</div><div class="bld-modal-footer">'
        + '<button class="bld-footer-btn avail" onclick="confirmMoveGuestTroops(\'' + guestTroopId + '\',' + JSON.stringify(JSON.stringify(troops)) + ')">âš” Mover</button>'
        + '</div></div></div>';
      var wrap = document.getElementById('bldModal');
      wrap.innerHTML = html;
      wrap.style.display = 'block';
    }

    async function confirmMoveGuestTroops(guestTroopId, troopsJson) {
      var sel = document.getElementById('moveGuestDestSel');
      if (!sel || !activeVillage) return;
      var destId = sel.value;
      var opt = sel.options[sel.selectedIndex];
      var tx = parseInt(opt.dataset.x), ty = parseInt(opt.dataset.y);
      var troops = {};
      try { troops = JSON.parse(troopsJson); } catch (e) { showNotif('Error', 'err'); return; }

      var dist = Math.max(Math.abs(tx - activeVillage.x), Math.abs(ty - activeVillage.y));
      var minSpeed = 999;
      Object.keys(troops).forEach(function (k) {
        var td = TROOP_TYPES[k] || CREATURE_TYPES[k];
        if ((troops[k] || 0) > 0 && td && td.speed < minSpeed) minSpeed = td.speed;
      });
      if (minSpeed === 999) minSpeed = 1;
      var secs = Math.ceil((dist / minSpeed) * MISSION_FACTOR);
      var finishAt = new Date(Date.now() + secs * 1000).toISOString();

      // Eliminar de guest_troops
      var dr = await sbClient.from('guest_troops').delete().eq('id', guestTroopId);
      if (dr.error) { showNotif('Error: ' + dr.error.message, 'err'); return; }

      // Crear misiÃ³n de movimiento desde la aldea activa hacia destino
      if (!activeVillage.state.mission_queue) activeVillage.state.mission_queue = [];
      activeVillage.state.mission_queue.push({
        mid: Math.random().toString(36).slice(2, 10) + Date.now().toString(36),
        type: 'move', tx: tx, ty: ty, targetId: destId, troops: troops,
        finish_at: finishAt, start_at: new Date().toISOString()
      });
      await flushVillage();
      document.getElementById('bldModal').style.display = 'none';
      showNotif('âš” Tropas en marcha â†’ [' + tx + ',' + ty + '] en ' + fmtTime(secs), 'ok');
      renderReinforcementsPanel();
    }

    async function processRecalls() {
      if (!currentUser) return;
      if (_guestTroopsTableExists === false) return; // tabla no existe, no intentar
      try {
        var r = await sbClient.from('guest_troops')
          .select('id,origin_village_id,host_village_id,troops')
          .eq('owner_id', currentUser.id).eq('recall_requested', true);
        if (r.error || !r.data || r.data.length === 0) return;
        for (var i = 0; i < r.data.length; i++) {
          var gt = r.data[i];
          var origVillage = myVillages.find(function (v) { return v.id === gt.origin_village_id; });
          if (!origVillage) continue;
          var hv = allVillages.find(function (v) { return v.id === gt.host_village_id; });
          var tx = hv ? Number(hv.x) : 0, ty = hv ? Number(hv.y) : 0;
          var dist = Math.max(Math.abs(tx - origVillage.x), Math.abs(ty - origVillage.y));
          var troops = typeof gt.troops === 'string' ? JSON.parse(gt.troops) : (gt.troops || {});
          var minSpeed = 999;
          Object.keys(troops).forEach(function (k) {
            var td = TROOP_TYPES[k] || CREATURE_TYPES[k];
            if ((troops[k] || 0) > 0 && td && td.speed < minSpeed) minSpeed = td.speed;
          });
          if (minSpeed === 999) minSpeed = 1;
          var seconds = Math.ceil((dist / minSpeed) * MISSION_FACTOR);
          var finishAt = new Date(Date.now() + seconds * 1000).toISOString();
          if (!origVillage.state.mission_queue) origVillage.state.mission_queue = [];
          origVillage.state.mission_queue.push({
            type: 'return_reinforce', tx: origVillage.x, ty: origVillage.y,
            troops: troops, finish_at: finishAt, start_at: new Date().toISOString()
          });
          await saveVillage(origVillage);
          await sbClient.from('guest_troops').delete().eq('id', gt.id);
        }
      } catch (e) { console.warn('processRecalls error:', e); }
    }

    // ============================================================
    // SIMULADOR DE BATALLA â€” v0.23 embebido, motor unificado con standalone
    // ============================================================
    var _simIframe = null;

    // Simulador cargado desde game-simulator.js


    function showPage(name, el) {
      document.querySelectorAll('.page').forEach(function (p) { p.classList.remove('active'); });
      document.querySelectorAll('.nav-item').forEach(function (n) { n.classList.remove('active'); });
      document.getElementById('page-' + name).classList.add('active');
      if (el) el.classList.add('active');
      setTimeout(function () { if (name === 'buildings') renderBuildings(); if (name === 'map') renderMap(); }, 50);
      if (name === 'ranking') renderRanking();
      if (name === 'alliances') renderAlliances();
      if (name === 'research') renderResearch(); // v1.35: Centro de InvestigaciÃ³n
      if (name === 'messages') { renderThreads(); renderMessagesHeader(); }
      if (name === 'recursos') renderRecursos();
      if (name === 'fleet') renderTroops();
      if (name === 'creatures') renderCreatures();
      if (name === 'admin-users') loadAdminUsersPage();
      if (name === 'simulator') {
        setTimeout(function () { renderSimulator(); }, 50);
      }
      // Guardar pÃ¡gina activa en sessionStorage para restaurar tras F5
      try { sessionStorage.setItem('EW_lastPage', name); } catch (e) { }
      // Resync recursos â€” solo si han pasado mÃ¡s de 2 minutos desde el Ãºltimo sync
      var _nowSync = Date.now();
      if (_nowSync - (_lastResourceSync || 0) > 120000) {
        _lastResourceSync = _nowSync;
        syncResourcesFromDB();
      }
    }

    // Resync ligero â€” actualiza recursos desde DB sin recargar todo el estado
    async function syncResourcesFromDB() {
      if (!activeVillage || !currentUser) return;
      try {
        var { data: res, error } = await sbClient
          .from('resources')
          .select('madera,piedra,hierro,prov,esencia,last_update')
          .eq('village_id', activeVillage.id)
          .single();
        if (error || !res) return;
        var s = activeVillage.state;
        // Solo actualizar si el valor de DB es mÃ¡s reciente
        var dbTime = new Date(res.last_update || 0).getTime();
        var localTime = new Date(s.last_updated || 0).getTime();
        if (dbTime >= localTime) {
          s.resources.madera = Number(res.madera) || 0;
          s.resources.piedra = Number(res.piedra) || 0;
          s.resources.hierro = Number(res.hierro) || 0;
          s.resources.provisiones = Number(res.prov) || 0;
          s.resources.esencia = Number(res.esencia) || 0;
          s.last_updated = res.last_update;
          _elCache = {}; // limpiar cache DOM
          tick();
        }
      } catch (e) {
        console.warn('syncResourcesFromDB error:', e);
      }
    }

    // ============================================================
    // ALDEANOS â€” asignar / desasignar de granja
    // Guardado INMEDIATO al pulsar (no espera al timer)
    // ============================================================
    function updateGranjaPanel() {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      var res = calcRes(vs);
      var assigned = vs.aldeanos_assigned || defaultAssignments();
      if (assigned.esencia === undefined) assigned.esencia = 0;

      var totalAssigned = (assigned.madera || 0) + (assigned.piedra || 0) + (assigned.hierro || 0)
        + (assigned.provisiones || 0) + (assigned.esencia || 0);

      var aldTotal = (vs.troops && vs.troops.aldeano !== undefined) ? vs.troops.aldeano : 0;
      var aldLibres = Math.max(0, aldTotal - totalAssigned);

      var el = document.getElementById('aldLibresDisplay');
      if (el) el.textContent = aldLibres + ' / ' + aldTotal;

      // Inputs para asignar
      ['madera', 'piedra', 'hierro', 'provisiones', 'esencia'].forEach(function (key) {
        var input = document.getElementById('aldInput_' + key);
        if (input) {
          input.value = assigned[key] || 0;
          input.max = aldLibres + (assigned[key] || 0); // Puede reasignar los que ya tiene + libres
        }
      });
    }

    function renderRecursos() {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      var res = calcRes(vs);
      var w = vs.aldeanos_assigned || defaultAssignments();
      if (w.esencia === undefined) w.esencia = 0;
      var base = getBaseProd(vs.buildings);
      var bon = getBonusPerWorker(vs.buildings);
      var p = getProd(vs.buildings, 0, w);
      var totalW = (w.madera || 0) + (w.piedra || 0) + (w.hierro || 0) + (w.provisiones || 0) + (w.esencia || 0);
      var barrCap = getBarracksCapacity(vs.buildings);
      var cap = getCapacity(vs.buildings);
      var stored = res.madera + res.piedra + res.hierro + res.provisiones;
      var almPct = cap > 0 ? Math.min(100, Math.round(stored / cap * 100)) : 0;

      var elFree = document.getElementById('recAldLibres'); if (elFree) elFree.textContent = (res.aldeanos_libres !== undefined ? res.aldeanos_libres : res.aldeanos);
      var elWork = document.getElementById('recAldWorking'); if (elWork) elWork.textContent = totalW;

      // v1.17: Mostrar capacidad de barracas con porcentaje y uso
      var used = getBarracksUsed(vs);
      var barrPct = barrCap > 0 ? Math.round(used / barrCap * 100) : 0;
      var elCap = document.getElementById('recAldCap'); if (elCap) elCap.textContent = used + ' / ' + barrCap + ' (' + barrPct + '%)';

      var elAlm = document.getElementById('recAlmPct'); if (elAlm) elAlm.textContent = almPct + '%';

      var RES_DEFS = [
        { key: 'madera', icon: 'ğŸŒ²', name: 'Madera', color: 'var(--madera)', base: base.madera, bon: bon.madera, prod: p.madera, inAlm: true },
        { key: 'piedra', icon: 'â›°ï¸', name: 'Piedra', color: 'var(--piedra)', base: base.piedra, bon: bon.piedra, prod: p.piedra, inAlm: true },
        { key: 'hierro', icon: 'âš™ï¸', name: 'Hierro', color: 'var(--hierro)', base: base.hierro, bon: bon.hierro, prod: p.hierro, inAlm: true },
        { key: 'provisiones', icon: 'ğŸŒ¾', name: 'Provisiones', color: 'var(--prov)', base: base.provisiones, bon: bon.provisiones, prod: p.provisiones, inAlm: true },
        { key: 'esencia', icon: 'âœ¨', name: 'Esencia', color: 'var(--esencia)', base: base.esencia, bon: bon.esencia, prod: p.esencia, inAlm: false },
      ];

      var grid = document.getElementById('recursosGrid');
      if (!grid) return;

      var KEYS = ['madera', 'piedra', 'hierro', 'provisiones', 'esencia'];
      var totalLibres = res.aldeanos_libres !== undefined ? res.aldeanos_libres : res.aldeanos;

      grid.innerHTML = RES_DEFS.map(function (d) {
        var wk = w[d.key] || 0;
        var avl = totalLibres + wk; // disponibles = libres + ya asignados a este recurso
        return '<div class="card">'
          + '<div style="display:flex;align-items:baseline;gap:8px;margin-bottom:8px;">'
          + '<div class="h2" style="color:' + d.color + '">' + d.icon + ' ' + d.name + '</div>'
          + '<span style="font-size:.65rem;color:var(--dim);">' + (d.inAlm ? 'almacÃ©n' : 'sin lÃ­mite') + '</span>'
          + '</div>'
          + '<div style="display:flex;gap:12px;flex-wrap:wrap;margin-bottom:10px;font-size:.78rem;">'
          + '<span>ğŸ“Š <b id="rw_p_' + d.key + '" style="color:' + d.color + '">' + fmt(d.prod) + '</b>/h</span>'
          + '<span style="color:var(--dim)">base ' + d.base + ' Â· +<b>' + d.bon + '</b>/aldÂ·h</span>'
          + '</div>'
          + '<div style="display:flex;align-items:center;gap:8px;margin-bottom:4px;">'
          + '<input type="range" min="0" max="' + avl + '" value="' + wk + '" id="rw_s_' + d.key + '"'
          + ' style="flex:1;accent-color:' + d.color + ';"'
          + ' oninput="syncWorkerInput(\'' + d.key + '\',this.value)">'
          + '<input type="number" min="0" max="' + avl + '" value="' + wk + '" id="rw_n_' + d.key + '"'
          + ' style="width:52px;background:rgba(255,255,255,.04);border:1px solid var(--border);border-radius:4px;padding:4px 6px;color:var(--text);font-family:VT323,monospace;font-size:.82rem;text-align:center;"'
          + ' oninput="syncWorkerSlider(\'' + d.key + '\',this.value,' + avl + ')">'
          + '</div>'
          + '<div id="rw_i_' + d.key + '" style="font-size:.68rem;color:var(--dim);">' + wk + ' asignados / ' + avl + ' disponibles</div>'
          + '</div>';
      }).join('')
        + '<div style="grid-column:1/-1;display:flex;justify-content:center;padding:10px 0 4px;">'
        + '<button onclick="applyAllWorkers()" style="'
        + 'padding:10px 32px;background:rgba(240,192,64,.12);border:1px solid var(--accent);'
        + 'border-radius:6px;color:var(--accent);font-family:VT323,monospace;font-size:1rem;'
        + 'letter-spacing:.08em;cursor:pointer;transition:background .2s;"'
        + ' onmouseover="this.style.background=\'rgba(240,192,64,.22)\'"'
        + ' onmouseout="this.style.background=\'rgba(240,192,64,.12)\'">'
        + 'âœ“ Aplicar asignaciÃ³n'
        + '</button>'
        + '</div>';
    }

    // ============================================================
    // WORKER ASSIGNMENT â€” con reajuste reactivo de todas las barras
    // ============================================================
    function snapshotResources(vs) {
      var res = calcRes(vs);
      vs.resources.madera = res.madera;
      vs.resources.piedra = res.piedra;
      vs.resources.hierro = res.hierro;
      vs.resources.provisiones = res.provisiones;
      vs.resources.esencia = res.esencia;
      // Sincronizar resources.aldeanos desde troops.aldeano (fuente de verdad)
      vs.resources.aldeanos = res.aldeanos_total;
      vs.last_updated = new Date().toISOString();
      return res;
    }

    function debouncedSave() {
      scheduleSave();
    }


    function assignWorker(resource, amount) {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      if (!vs.aldeanos_assigned) vs.aldeanos_assigned = defaultAssignments();
      var res = calcRes(vs);
      amount = Math.max(0, Math.min(amount, res.aldeanos));
      if (amount <= 0) { showNotif('No hay aldeanos libres.', 'err'); return; }
      // Snapshot recursos materiales; aldeanos NO se toca (calcRes lo recalcula desde total)
      vs.resources.madera = res.madera; vs.resources.piedra = res.piedra;
      vs.resources.hierro = res.hierro; vs.resources.provisiones = res.provisiones;
      vs.resources.esencia = res.esencia;
      // aldeanos sigue siendo el TOTAL (no cambiar)
      vs.aldeanos_assigned[resource] = (vs.aldeanos_assigned[resource] || 0) + amount;
      vs.aldeanos_granja = vs.aldeanos_assigned.provisiones || 0;
      vs.last_updated = new Date().toISOString();
      debouncedSave(); tick(); updateRecursosSliders();
    }

    function unassignWorker(resource, amount) {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      if (!vs.aldeanos_assigned) vs.aldeanos_assigned = defaultAssignments();

      amount = Math.max(0, Math.min(amount, vs.aldeanos_assigned[resource] || 0));
      if (amount <= 0) return;

      // Ponemos el estado al dÃ­a (incluye aldeanos TOTAL)
      snapshotResources(vs);

      vs.aldeanos_assigned[resource] = Math.max(0, (vs.aldeanos_assigned[resource] || 0) - amount);
      vs.aldeanos_granja = vs.aldeanos_assigned.provisiones || 0;

      // last_updated ya lo fijÃ³ snapshotResources()
      debouncedSave(); tick(); updateRecursosSliders();
    }

    // ============================================================
    // APPLY ALL WORKERS â€” botÃ³n global que lee los 5 sliders/inputs
    // de una vez y los escribe todos en state en una sola operaciÃ³n
    // ============================================================
    function applyAllWorkers() {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      if (!vs.aldeanos_assigned) vs.aldeanos_assigned = defaultAssignments();
      var w = vs.aldeanos_assigned;

      // 1) Snapshot para tener recursos y aldeanos al dÃ­a
      var r = snapshotResources(vs);
      var totalLibres = r.aldeanos_libres !== undefined ? r.aldeanos_libres : r.aldeanos;
      var totalAld = r.aldeanos_total || (totalLibres + Object.values(w).reduce(function (a, b) { return a + (b || 0); }, 0));

      // 2) Leer los 5 valores del DOM tal como el usuario los ha dejado
      var KEYS = ['madera', 'piedra', 'hierro', 'provisiones', 'esencia'];
      var newVals = {};
      var sumNew = 0;
      KEYS.forEach(function (k) {
        var el = document.getElementById('rw_n_' + k);
        var v = Math.max(0, parseInt((el && el.value) || 0) || 0);
        newVals[k] = v;
        sumNew += v;
      });

      // 3) Validar: la suma no puede superar el total de aldeanos
      if (sumNew > totalAld) {
        showNotif('Solo tienes ' + totalAld + ' aldeanos. EstÃ¡s asignando ' + sumNew + '.', 'err');
        return;
      }

      // 4) Aplicar todos de golpe
      KEYS.forEach(function (k) { w[k] = newVals[k]; });
      vs.aldeanos_granja = w.provisiones || 0;
      // last_updated ya lo fijÃ³ snapshotResources()

      showNotif('âœ“ Aldeanos asignados correctamente', 'ok');
      debouncedSave(); tick(); updateRecursosSliders();
    }

    // Llamado al soltar la barra o confirmar nÃºmero â€” guarda y refresca todo
    function setWorker(resource, rawValue) {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      if (!vs.aldeanos_assigned) vs.aldeanos_assigned = defaultAssignments();
      var w = vs.aldeanos_assigned;

      // 1) Primero, aplicamos el offline-calc para que recursos/aldeanos estÃ©n al dÃ­a
      var r = snapshotResources(vs);

      // 2) Los disponibles para este recurso = libres + los ya asignados a ESTE recurso
      var available = (r.aldeanos_libres || 0) + (w[resource] || 0);
      var value = Math.max(0, Math.min(parseInt(rawValue) || 0, available));

      // 3) Guardamos la asignaciÃ³n
      w[resource] = value;
      vs.aldeanos_granja = w.provisiones || 0; // compatibilidad
      // last_updated ya lo fijÃ³ snapshotResources()

      debouncedSave(); tick(); updateRecursosSliders();
    }

    // Sync instantÃ¡neo mientras se arrastra (sin guardar) â€” actualiza nÃºmero + restricciones
    function syncWorkerInput(key, val) {
      var ni = document.getElementById('rw_n_' + key);
      if (ni) ni.value = val;
      _previewWorker(key, parseInt(val) || 0);
    }
    function syncWorkerSlider(key, val, available) {
      val = Math.max(0, Math.min(parseInt(val) || 0, available));
      var sl = document.getElementById('rw_s_' + key);
      if (sl) sl.value = val;
      _previewWorker(key, val);
    }

    // Vista previa: ajusta maxes de los demÃ¡s sin guardar
    // Lee los valores ACTUALES del DOM (no del state) para calcular libres correctamente.
    // Esto evita el bug donde mover la 3Âª barra calcula mal los aldeanos disponibles
    // porque el state aÃºn tiene los valores anteriores sin guardar.
    function _previewWorker(changedKey, newVal) {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      var res = calcRes(vs);
      var totalAld = res.aldeanos_total || (vs.troops && vs.troops.aldeano) || 0;
      var KEYS = ['madera', 'piedra', 'hierro', 'provisiones', 'esencia'];

      // Leer valores actuales del DOM (pueden diferir del state si no se ha guardado)
      var domVals = {};
      KEYS.forEach(function (k) {
        if (k === changedKey) {
          domVals[k] = parseInt(newVal) || 0;
        } else {
          var el = document.getElementById('rw_s_' + k);
          domVals[k] = el ? (parseInt(el.value) || 0) : ((vs.aldeanos_assigned || {})[k] || 0);
        }
      });

      // Total asignado segÃºn DOM actual
      var totalW = KEYS.reduce(function (sum, k) { return sum + domVals[k]; }, 0);
      var freeNow = Math.max(0, totalAld - totalW);

      // Actualizar maxes de los demÃ¡s sliders
      KEYS.forEach(function (key) {
        if (key === changedKey) return;
        var cur = domVals[key];
        var newMax = cur + freeNow;
        var sl = document.getElementById('rw_s_' + key); if (sl) sl.max = newMax;
        var ni = document.getElementById('rw_n_' + key); if (ni) ni.max = newMax;
        var info = document.getElementById('rw_i_' + key);
        if (info) info.textContent = cur + ' asignados / ' + newMax + ' disponibles';
      });
      var elFree = document.getElementById('recAldLibres'); if (elFree) elFree.textContent = freeNow;
      var elWork = document.getElementById('recAldWorking'); if (elWork) elWork.textContent = totalW;
    }

    // Refresca sliders + stats sin re-renderizar DOM
    function updateRecursosSliders() {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      var res = calcRes(vs);
      var w = vs.aldeanos_assigned || defaultAssignments();
      if (w.esencia === undefined) w.esencia = 0;
      var p = getProd(vs.buildings, 0, w);
      var cap = getCapacity(vs.buildings);
      var totalW = (w.madera || 0) + (w.piedra || 0) + (w.hierro || 0) + (w.provisiones || 0) + (w.esencia || 0);
      var barrCap = getBarracksCapacity(vs.buildings);
      var stored = res.madera + res.piedra + res.hierro + res.provisiones;
      var almPct = cap > 0 ? Math.min(100, Math.round(stored / cap * 100)) : 0;

      var elFree = document.getElementById('recAldLibres'); if (elFree) elFree.textContent = (res.aldeanos_libres !== undefined ? res.aldeanos_libres : res.aldeanos);
      var elWork = document.getElementById('recAldWorking'); if (elWork) elWork.textContent = totalW;

      // v1.17: Mostrar capacidad de barracas con porcentaje y uso
      var used = getBarracksUsed(vs);
      var barrPct = barrCap > 0 ? Math.round(used / barrCap * 100) : 0;
      var elCap = document.getElementById('recAldCap'); if (elCap) elCap.textContent = used + ' / ' + barrCap + ' (' + barrPct + '%)';

      var elAlm = document.getElementById('recAlmPct'); if (elAlm) elAlm.textContent = almPct + '%';

      var prodMap = { madera: p.madera, piedra: p.piedra, hierro: p.hierro, provisiones: p.provisiones, esencia: p.esencia };
      ['madera', 'piedra', 'hierro', 'provisiones', 'esencia'].forEach(function (key) {
        var workers = w[key] || 0, available = (res.aldeanos_libres !== undefined ? res.aldeanos_libres : res.aldeanos) + workers;
        var sl = document.getElementById('rw_s_' + key); if (sl) { sl.max = available; sl.value = workers; }
        var ni = document.getElementById('rw_n_' + key); if (ni) { ni.max = available; ni.value = workers; }
        var info = document.getElementById('rw_i_' + key); if (info) info.textContent = workers + ' asignados / ' + available + ' disponibles';
        var prod = document.getElementById('rw_p_' + key); if (prod) prod.textContent = fmt(prodMap[key]) + '/h';
      });
      var bcEl = document.getElementById('barrCapDisplay'); if (bcEl) bcEl.textContent = barrCap;
      var usedSlotsRS = getBarracksUsed(vs);
      var buEl = document.getElementById('barrUsedDisplay'); if (buEl) buEl.textContent = usedSlotsRS;
      var bfEl = document.getElementById('barrFreeDisplay'); if (bfEl) bfEl.textContent = Math.max(0, barrCap - usedSlotsRS);
      var bpEl = document.getElementById('barrProdDisplay'); if (bpEl) bpEl.textContent = getAldeanosProd(vs.buildings);
    }

    // Legacy aliases

    // ============================================================
    // RENAME VILLAGE
    // ============================================================
    function startRename() {
      if (!activeVillage) return;
      var f = document.getElementById('renameForm');
      var inp = document.getElementById('renameInput');
      f.style.display = 'flex';
      inp.value = activeVillage.name;
      inp.focus();
      inp.select();
    }
    function cancelRename() {
      document.getElementById('renameForm').style.display = 'none';
    }
    async function confirmRename() {
      var inp = document.getElementById('renameInput');
      var newName = inp.value.trim();
      if (!newName) { showNotif('El nombre no puede estar vacio.', 'err'); return; }
      if (newName.length > 30) { showNotif('Maximo 30 caracteres.', 'err'); return; }
      var r = await sbClient.from('villages').update({ name: newName }).eq('id', activeVillage.id);
      if (r.error) { showNotif('Error al renombrar: ' + r.error.message, 'err'); return; }
      activeVillage.name = newName;
      populateVillageSel();
      document.getElementById('villageSel').value = activeVillage.id;
      document.getElementById('renameForm').style.display = 'none';
      tick();
      showNotif('Aldea renombrada a: ' + newName, 'ok');
    }

    // ============================================================
    // NOTIFICATIONS
    // ============================================================
    function showNotif(msg, type) {
      type = type || '';
      var el = document.createElement('div');
      el.className = 'notif ' + type;
      el.textContent = msg;
      document.getElementById('notifWrap').appendChild(el);
      setTimeout(function () { el.remove(); }, 3000);
    }

    // ============================================================
    // FORMAT
    // ============================================================
    function fmt(n) {
      n = Math.floor(n);
      if (n >= 1000000) return (n / 1000000).toFixed(1) + 'M';
      if (n >= 1000) return (n / 1000).toFixed(1) + 'K';
      return '' + n;
    }


    // ============================================================
    // BUILDING DETAIL MODAL
    // Calculates levels up to 100, shows current up to current+10
    // ============================================================
    function fmtTime(secs) {
      if (secs < 60) return secs + 's';
      if (secs < 3600) return Math.floor(secs / 60) + 'm ' + (secs % 60) + 's';
      var h = Math.floor(secs / 3600), m = Math.floor((secs % 3600) / 60);
      return h + 'h ' + (m ? m + 'm' : '');
    }

    function openBuildingDetail(id) {
      if (!activeVillage) return;
      modalBuildingId = id;
      var vs = activeVillage.state;
      var def = BUILDINGS.find(function (b) { return b.id === id; });
      if (!def) return;
      var curLvl = (vs.buildings[id] && vs.buildings[id].level) || 0;
      var res = calcRes(vs);
      var icon = def.icon || 'ğŸ—ï¸';
      var inQueue = vs.build_queue && vs.build_queue.id === id;
      var anyQueue = !!vs.build_queue;
      var endShow = Math.min(curLvl + 10, 100);

      // â”€â”€ Cabeceras de tabla segÃºn el edificio â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      var isReclutamiento = (id === 'reclutamiento');
      var isAlmacen = (id === 'almacen');
      var isGranja = (id === 'granja');
      var isBarracas = (id === 'barracas');

      var isTorre = (id === 'torre');
      var isTorreInv = (id === 'torreinvocacion');
      var isMuralla = (id === 'muralla');
      var thExtra = isReclutamiento ? '<th>âš¡ Aldeanos/h</th>'
        : isBarracas ? '<th>ğŸ  Plazas barracas</th>'
          : isAlmacen ? '<th>ğŸ›ï¸ Capacidad</th>'
            : isGranja ? '<th>ğŸŒ¾ Prov./aldeano/h</th>'
              : isTorre ? '<th>ğŸ‘ï¸ Alcance</th>'
                : isTorreInv ? '<th>ğŸ”® ReducciÃ³n</th>'
                  : isMuralla ? '<th>ğŸ›¡ï¸ Defensa</th>'
                    : '<th>ProducciÃ³n</th>';

      var rowsHTML = '';
      for (var lvl = curLvl; lvl <= endShow; lvl++) {
        var isCur = (lvl === curLvl);
        var isNext = (lvl === curLvl + 1);
        var cost = def.cost(lvl);
        var prod = def.prod(lvl);
        var tsecs = def.time(lvl);

        var rowCls = isCur ? 'row-current' : (isNext ? 'row-next' : '');
        var badgeCls = isNext ? 'lvl-badge accent' : 'lvl-badge';
        var tagHTML = isCur ? '<span class="lvl-tag cur">actual</span>'
          : isNext ? '<span class="lvl-tag nxt">siguiente</span>' : '';

        // â”€â”€ Columna de "efecto" segÃºn edificio â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        var plines = '';

        if (isReclutamiento) {
          var prodAld = (lvl === 0) ? 0 : Math.max(2, Math.floor(2 + lvl * 2));
          var fakeBldRec = {};
          BUILDINGS.forEach(function (b) { fakeBldRec[b.id] = { level: (vs.buildings[b.id] && vs.buildings[b.id].level) || 1 }; });
          fakeBldRec['reclutamiento'] = { level: lvl };
          var intMs = lvl === 0 ? Infinity : getAldeanosIntervalMs(fakeBldRec);
          var intStr = '';
          if (lvl === 0) {
            intStr = '<div class="pl" style="color:var(--danger)">Sin producciÃ³n</div>';
          } else {
            var intSec = Math.round(intMs / 1000);
            var intLabel = intSec >= 60
              ? (intSec % 60 === 0 ? (intSec / 60) + ' min' : Math.floor(intSec / 60) + 'min ' + (intSec % 60) + 's')
              : intSec + 's';
            intStr = '<div class="pl" style="color:var(--accent2)">âš¡ 1 aldeano cada <b>' + intLabel + '</b></div>';
          }
          plines = intStr;

        } else if (isBarracas) {
          var fakeBldBar = {}; fakeBldBar['barracas'] = { level: lvl };
          var plazas = getBarracksCapacity(fakeBldBar);
          plines = '<div class="pl" style="color:var(--aldeanos)">ğŸ  ' + plazas + ' plazas</div>';

        } else if (isAlmacen) {
          var cap = Math.floor(almacenCapForLevel(lvl));
          plines = '<div class="pl" style="color:var(--accent)">ğŸ“¦ ' + fmt(cap) + ' unidades</div>'
            + '<div class="pl none" style="font-size:.58rem;opacity:.7">(madera+piedra+hierro+provisiones â€” la Esencia NO usa almacÃ©n)</div>';

        } else if (isGranja) {
          var provPerAld = 5 + lvl;
          plines = '<div class="pl" style="color:var(--prov)">ğŸŒ¾ ' + provPerAld + ' prov./aldeano/h</div>';

        } else {
          // Simular el edificio actual a este nivel concreto, manteniendo el resto igual
          var fakeBlds = {};
          BUILDINGS.forEach(function (b) { fakeBlds[b.id] = { level: (vs.buildings[b.id] && vs.buildings[b.id].level) || 1 }; });
          fakeBlds[id] = { level: lvl };
          var bProd = getBaseProd(fakeBlds);
          var bBonus = getBonusPerWorker(fakeBlds);
          // Clave de workers segÃºn edificio
          var workerKey = id === 'aserradero' ? 'madera'
            : id === 'cantera' ? 'piedra'
              : id === 'minehierro' ? 'hierro'
                : id === 'circulo' ? 'esencia' : null;
          var wk = workerKey ? ((vs.aldeanos_assigned && vs.aldeanos_assigned[workerKey]) || 0) : 0;
          // Mostrar SOLO el recurso que produce este edificio concreto
          if (id === 'aserradero') {
            var totM = bProd.madera + wk * bBonus.madera;
            plines = '<div class="pl" style="color:var(--madera)">ğŸŒ² ' + fmt(bProd.madera) + '/h base'
              + (wk ? ' <span style="color:var(--aldeanos)">+' + fmt(bBonus.madera) + '/ald Ã— ' + wk + ' = <b>' + fmt(totM) + '/h total</b></span>' : '') + '</div>';
          } else if (id === 'cantera') {
            var totP = bProd.piedra + wk * bBonus.piedra;
            plines = '<div class="pl" style="color:var(--piedra)">â›°ï¸ ' + fmt(bProd.piedra) + '/h base'
              + (wk ? ' <span style="color:var(--aldeanos)">+' + fmt(bBonus.piedra) + '/ald Ã— ' + wk + ' = <b>' + fmt(totP) + '/h total</b></span>' : '') + '</div>';
          } else if (id === 'minehierro') {
            var totH = bProd.hierro + wk * bBonus.hierro;
            plines = '<div class="pl" style="color:var(--hierro)">âš™ï¸ ' + fmt(bProd.hierro) + '/h base'
              + (wk ? ' <span style="color:var(--aldeanos)">+' + fmt(bBonus.hierro) + '/ald Ã— ' + wk + ' = <b>' + fmt(totH) + '/h total</b></span>' : '') + '</div>';
          } else if (id === 'circulo') {
            var totE = bProd.esencia + wk * bBonus.esencia;
            plines = '<div class="pl" style="color:var(--esencia)">âœ¨ ' + fmt(bProd.esencia) + '/h base'
              + (wk ? ' <span style="color:var(--aldeanos)">+' + fmt(bBonus.esencia) + '/ald Ã— ' + wk + ' = <b>' + fmt(totE) + '/h total</b></span>' : '') + '</div>';
          } else if (id === 'torre') {
            var range = lvl * 10;
            plines = lvl === 0
              ? '<div class="pl" style="color:var(--danger)">Sin alcance</div>'
              : '<div class="pl" style="color:var(--accent)">ğŸ‘ï¸ ' + range + ' casillas de alcance</div>';
          } else if (id === 'torreinvocacion') {
            var red = lvl * 5;
            plines = lvl === 0
              ? '<div class="pl" style="color:var(--danger)">Sin reducciÃ³n</div>'
              : '<div class="pl" style="color:var(--esencia)">ğŸ”® -' + red + '% tiempo invocaciÃ³n</div>';
          } else if (id === 'muralla') {
            var wallHPShow = lvl * 500;
            plines = lvl === 0
              ? '<div class="pl" style="color:var(--danger)">Sin muralla â€” tropas expuestas</div>'
              : '<div class="pl" style="color:var(--piedra)">ğŸ° ' + fmt(wallHPShow) + ' HP de escudo</div>'
              + '<div class="pl" style="color:var(--dim);font-size:.58rem;">Atacantes deben destruirlo antes de daÃ±ar tropas</div>';
          } else if (id === 'lab') {
            plines = lvl === 0
              ? '<div class="pl" style="color:var(--danger)">Sin nivel</div>'
              : '<div class="pl" style="color:var(--gold)">ğŸ“œ InvestigaciÃ³n activa<br><span style="font-size:.58rem;color:var(--dim)">PrÃ³ximamente disponible</span></div>';
          } else {
            plines = '<div class="pl none">â€”</div>';
          }
        }

        // â”€â”€ Coste para subir ESTE nivel al siguiente â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        var clines = '';
        if (lvl < 100) {
          var c = def.cost(lvl);
          if (c.madera) clines += '<div class="cl ' + (res.madera >= (c.madera || 0) ? 'can' : 'cant') + '">ğŸŒ² ' + fmt(c.madera) + '</div>';
          if (c.piedra) clines += '<div class="cl ' + (res.piedra >= (c.piedra || 0) ? 'can' : 'cant') + '">â›°ï¸ ' + fmt(c.piedra) + '</div>';
          if (c.hierro) clines += '<div class="cl ' + (res.hierro >= (c.hierro || 0) ? 'can' : 'cant') + '">âš™ï¸ ' + fmt(c.hierro) + '</div>';
          if (c.provisiones) clines += '<div class="cl ' + (res.provisiones >= (c.provisiones || 0) ? 'can' : 'cant') + '">ğŸŒ¾ ' + fmt(c.provisiones) + '</div>';
          if (c.esencia) clines += '<div class="cl ' + (res.esencia >= (c.esencia || 0) ? 'can' : 'cant') + '">âœ¨ ' + fmt(c.esencia) + '</div>';
          if (!clines) clines = '<div class="cl can">â€”</div>';
        } else {
          clines = '<div class="cl can" style="color:var(--gold)">MAX</div>';
        }

        var timeHTML = (lvl < 100 && tsecs > 0)
          ? '<span class="ttime">' + fmtTime(tsecs) + '</span>'
          : (lvl >= 100)
            ? '<span class="ttime" style="color:var(--dim)">â€”</span>'
            : '<span class="ttime" style="color:var(--ok)">InstantÃ¡neo</span>';

        rowsHTML += '<tr class="' + rowCls + '">'
          + '<td><span class="' + badgeCls + '">' + lvl + '</span>' + tagHTML + '</td>'
          + '<td><div class="prod-lines">' + plines + '</div></td>'
          + '<td><div class="cost-lines">' + clines + '</div></td>'
          + '<td>' + timeHTML + '</td>'
          + '</tr>';
      }

      // â”€â”€ SubtÃ­tulo contextual en la cabecera del modal â”€â”€â”€â”€â”€â”€â”€â”€â”€
      var curBaseProd = getBaseProd(vs.buildings);
      var curBonusProd = getBonusPerWorker(vs.buildings);
      var curWorkers = vs.aldeanos_assigned || defaultAssignments();
      var modalSub = 'Nivel actual: ' + curLvl + '&nbsp;&nbsp;|&nbsp;&nbsp;MÃ¡ximo: 100';
      if (isReclutamiento) {
        var curProd = (curLvl === 0) ? 0 : Math.max(2, Math.floor(2 + curLvl * 2));
        var curIntMs = getAldeanosIntervalMs(vs.buildings);
        var curIntSec = curIntMs === Infinity ? null : Math.round(curIntMs / 1000);
        var curIntLabel = curIntSec === null ? 'sin producciÃ³n'
          : curIntSec >= 60
            ? (curIntSec % 60 === 0 ? (curIntSec / 60) + ' min' : Math.floor(curIntSec / 60) + 'min ' + (curIntSec % 60) + 's')
            : curIntSec + 's';
        modalSub = 'Nivel ' + curLvl + '&nbsp;Â·&nbsp;âš¡ 1 aldeano cada ' + curIntLabel + ' (â‰ˆ ' + curProd + '/h)';
      } else if (isBarracas) {
        var fakeBldBarCur = {}; fakeBldBarCur['barracas'] = { level: curLvl };
        var curPlazas = getBarracksCapacity(fakeBldBarCur);
        modalSub = 'Nivel ' + curLvl + '&nbsp;Â·&nbsp;ğŸ  ' + curPlazas + ' plazas para tropas normales';
      } else if (isAlmacen) {
        var curCap = Math.floor(almacenCapForLevel(curLvl));
        modalSub = 'Nivel ' + curLvl + '&nbsp;Â·&nbsp;ğŸ“¦ Capacidad actual: ' + fmt(curCap) + ' unidades';
      } else if (isGranja) {
        modalSub = 'Nivel ' + curLvl + '&nbsp;Â·&nbsp;ğŸŒ¾ ' + (5 + curLvl) + ' provisiones/aldeano/h';
      } else if (id === 'aserradero') {
        var wk = curWorkers.madera || 0;
        var total = curBaseProd.madera + wk * curBonusProd.madera;
        modalSub = 'Nivel ' + curLvl + '&nbsp;Â·&nbsp;ğŸŒ² Base ' + fmt(curBaseProd.madera) + '/h' + (wk ? ' + ' + wk + ' ald. â†’ ' + fmt(total) + '/h total' : '');
      } else if (id === 'cantera') {
        var wk = curWorkers.piedra || 0;
        var total = curBaseProd.piedra + wk * curBonusProd.piedra;
        modalSub = 'Nivel ' + curLvl + '&nbsp;Â·&nbsp;â›°ï¸ Base ' + fmt(curBaseProd.piedra) + '/h' + (wk ? ' + ' + wk + ' ald. â†’ ' + fmt(total) + '/h total' : '');
      } else if (id === 'minehierro') {
        var wk = curWorkers.hierro || 0;
        var total = curBaseProd.hierro + wk * curBonusProd.hierro;
        modalSub = 'Nivel ' + curLvl + '&nbsp;Â·&nbsp;âš™ï¸ Base ' + fmt(curBaseProd.hierro) + '/h' + (wk ? ' + ' + wk + ' ald. â†’ ' + fmt(total) + '/h total' : '');
      } else if (id === 'circulo') {
        var wk = curWorkers.esencia || 0;
        var total = curBaseProd.esencia + wk * curBonusProd.esencia;
        modalSub = 'Nivel ' + curLvl + '&nbsp;Â·&nbsp;âœ¨ Base ' + fmt(curBaseProd.esencia) + '/h' + (wk ? ' + ' + wk + ' ald. â†’ ' + fmt(total) + '/h total' : '');
      } else if (id === 'torre') {
        var rng = curLvl * 10;
        modalSub = curLvl === 0
          ? 'Sin nivel â€” sin alcance. Necesitas la Torre para atacar y espiar.'
          : 'Nivel ' + curLvl + '&nbsp;Â·&nbsp;ğŸ‘ï¸ Alcance actual: <b>' + rng + ' casillas (radio circular)</b>';
      } else if (id === 'torreinvocacion') {
        var red = curLvl * 5;
        modalSub = curLvl === 0
          ? 'Sin nivel â€” sin reducciÃ³n de tiempo de invocaciÃ³n.'
          : 'Nivel ' + curLvl + '&nbsp;Â·&nbsp;ğŸ”® ReducciÃ³n actual: <b>-' + red + '%</b> tiempo de invocaciÃ³n';
      } else if (id === 'cuarteles') {
        var redCuar = Math.min(50, curLvl);
        modalSub = curLvl === 0
          ? 'Sin nivel â€” sin reducciÃ³n de tiempo de entrenamiento.'
          : 'Nivel ' + curLvl + '&nbsp;Â·&nbsp;ğŸ–ï¸ ReducciÃ³n actual: <b>-' + redCuar + '%</b> tiempo de entrenamiento (mÃ¡x. 50%)';
      } else if (id === 'muralla') {
        var wallHPCur = curLvl * 500;
        modalSub = curLvl === 0
          ? 'Sin nivel â€” tus tropas estÃ¡n expuestas desde el primer golpe.'
          : 'Nivel ' + curLvl + '&nbsp;Â·&nbsp;ğŸ° Escudo actual: <b>' + fmt(wallHPCur) + ' HP</b> â€” el atacante los destruye antes de llegar a tus tropas';
      } else if (id === 'lab') {
        modalSub = 'Nivel ' + curLvl + '&nbsp;Â·&nbsp;ğŸ“œ MÃ³dulo de InvestigaciÃ³n â€” <span style="color:var(--gold)">PrÃ³ximamente activo</span>';
      }

      // â”€â”€ BotÃ³n footer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      var btnCls, btnTxt;
      if (curLvl >= 100) {
        btnCls = 'maxlvl'; btnTxt = 'Nivel mÃ¡ximo alcanzado (100)';
      } else if (inQueue) {
        btnCls = 'busy'; btnTxt = 'Construyendo nivel ' + (curLvl + 1) + '...';
      } else if (anyQueue) {
        btnCls = 'insuf'; btnTxt = 'Cola ocupada â€” espera a que termine';
      } else if (!canAfford(def.cost(curLvl), res)) {
        btnCls = 'insuf'; btnTxt = 'Recursos insuficientes para nivel ' + (curLvl + 1);
      } else {
        btnCls = 'avail'; btnTxt = 'Mejorar a Nivel ' + (curLvl + 1);
      }

      var html = '<div class="bld-modal-overlay" id="bldOverlay" onclick="closeBldOverlay(event)">'
        + '<div class="bld-modal">'
        + '<div class="bld-modal-head">'
        + '<div class="bld-modal-icon">' + icon + '</div>'
        + '<div><div class="bld-modal-title">' + def.name + '</div>'
        + '<div class="bld-modal-sub">' + modalSub + '</div></div>'
        + '<button class="bld-modal-close" onclick="document.getElementById(\'bldModal\').style.display=\'none\';">&#x2715; Cerrar</button>'
        + '</div>'
        + '<div class="bld-modal-body">'
        + '<div style="background:rgba(255,255,255,.04);border-radius:6px;padding:8px 12px;margin-bottom:10px;font-size:.75rem;color:var(--dim);line-height:1.5;border-left:3px solid var(--accent);">'
        + def.desc
        + '</div>'
        + '<div class="bld-modal-note">Costes en <span style="color:var(--danger)">rojo</span> = no puedes pagarlos ahora. Cada fila muestra el coste de subir ese nivel al siguiente.</div>'
        + '<table class="bld-lvl-table">'
        + '<thead><tr><th>Nivel</th>' + thExtra + '<th>Coste (subir)</th><th>Tiempo</th></tr></thead>'
        + '<tbody>' + rowsHTML + '</tbody>'
        + '</table>'
        + '</div>'
        + '<div class="bld-modal-footer">'
        + '<button class="bld-footer-btn ' + btnCls + '" onclick="startBuildCurrentModal()">' + btnTxt + '</button>'
        + '</div>'
        + '</div></div>';

      var wrap = document.getElementById('bldModal');
      wrap.innerHTML = html;
      wrap.style.display = 'block';
    }

    function closeBldOverlay(event) {
      if (event.target.id === 'bldOverlay') {
        document.getElementById('bldModal').style.display = 'none';
      }
    }

    function startBuildCurrentModal() {
      document.getElementById('bldModal').style.display = 'none';
      if (modalBuildingId) startBuild(modalBuildingId);
    }

    // ============================================================
    // STARS
    // ============================================================
    function createStars() {
      var c = document.getElementById('stars');
      for (var i = 0; i < 120; i++) {
        var s = document.createElement('div');
        s.className = 'star';
        var sz = Math.random() * 2 + .5;
        s.style.cssText = 'width:' + sz + 'px;height:' + sz + 'px;left:' + (Math.random() * 100) + '%;top:' + (Math.random() * 100) + '%;animation-duration:' + (Math.random() * 4 + 2) + 's;animation-delay:' + (Math.random() * 4) + 's;';
        c.appendChild(s);
      }
    }

    createStars();

    // Guardado "mejor esfuerzo" al ocultar la pestaÃ±a (no bloqueante).
    // Nota: ningÃºn navegador garantiza 100% el guardado al cerrar, pero esto evita el XHR sÃ­ncrono y la auth incorrecta.
    document.addEventListener('visibilitychange', function () {
      if (document.hidden) {
        try { flushVillage(); } catch (e) { }
      }
    });


    // ============================================================
    // EPIC WARRIOS V2 â€” SOCIAL + RANKING + TROOPS SYNC (v2)
    // ============================================================
    let currentThreadId = null;
    let currentThreadType = null;
    var _selectedReportIds = new Set(); // v1.30: multi-select para informes de sistema

    async function ensureLogged() {
      if (!currentUser) { showNotif('Inicia sesiÃ³n primero.', 'err'); return false; }
      return true;
    }

    function escapeHtml(str) {
      return String(str ?? '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;').replace(/'/g, '&#39;');
    }

    function escapeJs(str) {
      // Escapa string para uso en atributos onclick/JavaScript inline
      // Reemplaza backslash primero, luego comillas simples
      return String(str ?? '').replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '');
    }

    function formatNumber(n) {
      if (n === null || n === undefined) return '0';
      const num = Number(n);
      if (isNaN(num)) return '0';
      if (num >= 1000000) return (num / 1000000).toFixed(1).replace(/\.0$/, '') + 'M';
      if (num >= 1000) return (num / 1000).toFixed(1).replace(/\.0$/, '') + 'K';
      return num.toLocaleString('es-ES');
    }

    // ============================================================
    // RANKING â€” 1 tropa = 1 punto, cachÃ© 6h, suma todas las tropas del jugador
    // ============================================================
    let rankingCache = null;       // {data, fetchedAt}
    const RANKING_TTL_MS = 6 * 60 * 60 * 1000; // 6 horas

    async function renderRanking() {
      if (!(await ensureLogged())) return;
      const box = document.getElementById('rankingBox');

      // Muestra datos cacheados si son recientes
      const now = Date.now();
      if (rankingCache && (now - rankingCache.fetchedAt) < RANKING_TTL_MS) {
        renderRankingRows(box, rankingCache.data, rankingCache.fetchedAt);
        return;
      }

      box.innerHTML = '<div class="muted">Actualizando rankingâ€¦</div>';

      // Suma de tropas por jugador: cada fila en 'troops' tiene (village_id, troop_type, quantity)
      // Necesitamos agrupar por user_id a travÃ©s de villages
      let rows = null;

      // Intenta la vista ranking primero (mÃ¡s eficiente si existe en Supabase)
      const v = await sbClient.from('ranking')
        .select('username, military_score, alliance_tag')
        .order('military_score', { ascending: false })
        .limit(200);

      if (!v.error && v.data && v.data.length > 0) {
        rows = v.data;
      } else {
        // Fallback: calcula desde profiles + troops + villages
        const p = await sbClient.from('profiles')
          .select('id, username')
          .limit(500);
        if (p.error || !p.data) {
          box.innerHTML = '<div class="muted">Error cargando ranking.</div>';
          return;
        }

        // Carga todas las tropas con su aldea (user_id viene de villages)
        // v0.19: Usamos * para obtener todas las columnas de tipos de tropa nuevas
        const t = await sbClient.from('troops')
          .select('*, villages(owner_id)')  // owner_id es la columna correcta en villages
          .limit(5000);

        // Agrupa tropas por owner_id
        const scoreMap = {};
        if (!t.error && t.data) {
          t.data.forEach(tr => {
            const uid = tr.villages && tr.villages.owner_id; // era user_id â€” bug corregido
            if (!uid) return;

            // Sumamos todas las clases de tropas definidas en el juego
            let playerTotalTroops = 0;
            Object.keys(TROOP_TYPES).forEach(k => {
              playerTotalTroops += (Number(tr[k]) || 0);
            });

            scoreMap[uid] = (scoreMap[uid] || 0) + playerTotalTroops;
          });
        }

        // Busca alianzas activas
        const am = await sbClient.from('alliance_members')
          .select('user_id, status, alliances(tag)')
          .eq('status', 'active')
          .limit(500);
        const allianceTagMap = {};
        if (!am.error && am.data) {
          am.data.forEach(r => {
            allianceTagMap[r.user_id] = r.alliances ? r.alliances.tag : null;
          });
        }

        rows = p.data.map(u => ({
          username: u.username,
          military_score: scoreMap[u.id] || 0,
          alliance_tag: allianceTagMap[u.id] || null
        })).sort((a, b) => b.military_score - a.military_score);
      }

      rankingCache = { data: rows, fetchedAt: Date.now() };
      renderRankingRows(box, rows, rankingCache.fetchedAt);
    }

    function renderRankingRows(box, rows, fetchedAt) {
      if (!rows || rows.length === 0) { box.innerHTML = '<div class="muted">AÃºn no hay datos.</div>'; return; }

      const myUsername = document.getElementById('ovUser') ? document.getElementById('ovUser').textContent : '';
      const nextUpdate = new Date(fetchedAt + RANKING_TTL_MS);
      const nextStr = nextUpdate.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });

      let html = '<div style="font-size:.6rem;color:var(--dim);margin-bottom:8px;">â± PrÃ³xima actualizaciÃ³n: ~' + nextStr + ' (cada 6h) &nbsp;Â·&nbsp; 1 tropa = 1 punto militar</div>';
      html += '<div class="table"><div class="trow thead"><div>#</div><div>Usuario</div><div>Alianza</div><div>âš”ï¸ Militar</div></div>';

      rows.forEach((r, i) => {
        const isMe = r.username === myUsername;
        const medal = i === 0 ? 'ğŸ¥‡' : i === 1 ? 'ğŸ¥ˆ' : i === 2 ? 'ğŸ¥‰' : '' + (i + 1);
        const rowStyle = isMe ? 'background:rgba(240,192,64,.08);border-color:rgba(240,192,64,.3);' : '';
        html += '<div class="trow" style="' + rowStyle + '">'
          + '<div>' + medal + '</div>'
          + '<div style="' + (isMe ? 'color:var(--gold);font-weight:bold;' : '') + '">' + escapeHtml(r.username || '-') + (isMe ? ' â—€' : '') + '</div>'
          + '<div>' + escapeHtml(r.alliance_tag || 'â€”') + '</div>'
          + '<div style="color:var(--accent)">' + fmt(Number(r.military_score || 0)) + '</div>'
          + '</div>';
      });
      html += '</div>';
      box.innerHTML = html;
    }

    // BotÃ³n para forzar refresh del ranking (ignora cachÃ©)
    function forceRefreshRanking() {
      rankingCache = null;
      renderRanking();
    }

    // ================================================================
    // CENTRO DE INVESTIGACIÃ“N â€” sistema de niveles de tropa (v1.35)
    // ================================================================

    // Tabla de coste XP por nivel (nivel 1â†’2 cuesta 10000, lineal hasta 30M)
    // FÃ³rmula: coste(n) = round(10000 + (n-1) * (30000000-10000)/28, -3) aprox
    function xpCostForLevel(currentLvl) {
      if (currentLvl < 1 || currentLvl >= 30) return Infinity;
      var base = 10000;
      var step = Math.round((30000000 - 10000) / 28);
      var raw = base + (currentLvl - 1) * step;
      // Redondear a cifra limpia
      if (raw >= 1000000) return Math.round(raw / 100000) * 100000;
      if (raw >= 100000) return Math.round(raw / 10000) * 10000;
      return Math.round(raw / 1000) * 1000;
    }

    // Stats por nivel para una tropa (interpolaciÃ³n lineal entre nivel 1 y nivel 30)
    // Usamos multiplicadores sobre stats base. Los spikes cada 5 niveles aÃ±aden +10% extra.
    function getTroopStatsAtLevel(troopKey, lvl) {
      var base = TROOP_TYPES[troopKey];
      if (!base) return null;
      // Multiplicador base: +8% por nivel sobre stats base (lvl 1 = Ã—1.0)
      var mult = 1 + (lvl - 1) * 0.08;
      // Spike en mÃºltiplos de 5: +10% adicional acumulado
      var spikes = Math.floor(lvl / 5);
      mult += spikes * 0.10;
      return {
        hp:      Math.round(base.hp * mult),
        damage:  Math.round(base.damage * mult),
        defense: Math.round(base.defense * mult),
        attackChance: Math.min(95, base.attackChance + Math.floor((lvl-1)*0.5))
      };
    }

    // Cache de datos de investigaciÃ³n del jugador
    var _researchData = null; // { experience, troop_levels, ... }

    async function loadResearchData(forceReload) {
      if (_researchData && !forceReload) return _researchData;
      try {
        var { data, error } = await sbClient
          .from('profiles')
          .select('experience, troop_levels, weapon_levels, armor_levels')
          .eq('id', currentUser.id)
          .single();
        if (error) throw error;
        _researchData = {
          experience:   data.experience || 0,
          troop_levels: data.troop_levels || {},
          weapon_levels: data.weapon_levels || {},
          armor_levels:  data.armor_levels || {}
        };
      } catch(e) {
        console.warn('loadResearchData error:', e);
        _researchData = { experience: 0, troop_levels: {}, weapon_levels: {}, armor_levels: {} };
      }
      return _researchData;
    }

    async function renderResearch() {
      var rd = await loadResearchData(true);
      // Actualizar display XP
      var xpEl = document.getElementById('researchXPDisplay');
      if (xpEl) xpEl.textContent = formatNumber(rd.experience) + ' XP';

      var grid = document.getElementById('researchTroopGrid');
      if (!grid) return;

      // Tropas que tienen sistema de niveles (excluye invocador)
      var troopKeys = ['aldeano','soldado','mago','druida','explorador','asesino','paladin','chaman'];
      var html = '';

      troopKeys.forEach(function(key) {
        var tDef = TROOP_TYPES[key];
        if (!tDef) return;
        var curLvl = rd.troop_levels[key] || 1;
        var isMax = curLvl >= 30;
        var cost = xpCostForLevel(curLvl);
        var canAfford = !isMax && rd.experience >= cost;
        var stats = getTroopStatsAtLevel(key, curLvl);
        var statsNext = isMax ? null : getTroopStatsAtLevel(key, curLvl + 1);

        html += '<div style="display:flex;align-items:center;gap:12px;padding:10px;background:var(--bg2);border-radius:8px;flex-wrap:wrap;">';

        // Icono + nombre
        html += '<div style="min-width:80px;text-align:center;">';
        html += '<div style="font-size:1.8rem;">' + tDef.icon + '</div>';
        html += '<div style="font-size:.7rem;font-weight:700;color:var(--text);">' + tDef.name + '</div>';
        html += '</div>';

        // Nivel actual
        html += '<div style="min-width:70px;">';
        html += '<div class="muted" style="font-size:.65rem;">NIVEL</div>';
        html += '<div style="font-size:1.5rem;font-weight:700;color:' + (isMax ? 'var(--gold)' : 'var(--accent)') + ';">' + curLvl + '</div>';
        if (isMax) html += '<div style="font-size:.6rem;color:var(--gold);">MÃXIMO</div>';
        html += '</div>';

        // Stats actuales
        html += '<div style="flex:1;min-width:130px;">';
        html += '<div class="muted" style="font-size:.65rem;margin-bottom:4px;">STATS (nv.' + curLvl + ')</div>';
        html += '<div style="font-size:.72rem;line-height:1.7;">';
        html += 'â¤ï¸ HP: <strong>' + stats.hp + '</strong>';
        if (statsNext) html += ' â†’ <span style="color:var(--green)">' + statsNext.hp + '</span>';
        html += '<br>';
        html += 'âš”ï¸ DaÃ±o: <strong>' + stats.damage + '</strong>';
        if (statsNext) html += ' â†’ <span style="color:var(--green)">' + statsNext.damage + '</span>';
        html += '<br>';
        html += 'ğŸ›¡ï¸ Def: <strong>' + stats.defense + '</strong>';
        if (statsNext) html += ' â†’ <span style="color:var(--green)">' + statsNext.defense + '</span>';
        html += '</div>';
        html += '</div>';

        // Coste y botÃ³n
        html += '<div style="text-align:right;min-width:110px;">';
        if (!isMax) {
          html += '<div class="muted" style="font-size:.65rem;">COSTE SUBIDA</div>';
          html += '<div style="font-size:.85rem;color:' + (canAfford ? 'var(--gold)' : 'var(--dim)') + ';margin-bottom:6px;">' + formatNumber(cost) + ' XP</div>';
          html += '<button class="btn btn-sm" style="' + (!canAfford ? 'opacity:.45;cursor:not-allowed;' : '') + '"'
                + (canAfford ? ' onclick="upgradeTroopLevel(\'' + key + '\')"' : '')
                + '>' + (canAfford ? 'â¬† Subir nivel' : 'âŒ XP insuf.') + '</button>';
        } else {
          html += '<div style="font-size:.8rem;color:var(--gold);margin-top:8px;">âœ¨ MaestrÃ­a</div>';
        }
        html += '</div>';

        html += '</div>';
      });

      grid.innerHTML = html;
    }

    async function upgradeTroopLevel(troopKey) {
      if (!currentUser) return;
      var rd = await loadResearchData(false);
      var curLvl = rd.troop_levels[troopKey] || 1;
      if (curLvl >= 30) return;
      var cost = xpCostForLevel(curLvl);
      if (rd.experience < cost) {
        alert('No tienes suficiente XP.');
        return;
      }

      var newLvl = curLvl + 1;
      var newXP = rd.experience - cost;
      var newTroopLevels = Object.assign({}, rd.troop_levels);
      newTroopLevels[troopKey] = newLvl;

      try {
        var { error } = await sbClient
          .from('profiles')
          .update({ experience: newXP, troop_levels: newTroopLevels })
          .eq('id', currentUser.id);
        if (error) throw error;

        // Actualizar cache local
        _researchData.experience = newXP;
        _researchData.troop_levels = newTroopLevels;

        // Actualizar display XP global si existe
        var xpEl = document.getElementById('ovExperience');
        if (xpEl) xpEl.textContent = formatNumber(newXP);

        // Re-renderizar
        await renderResearch();

        // Feedback visual
        var tDef = TROOP_TYPES[troopKey];
        var msg = 'âœ… ' + (tDef ? tDef.icon + ' ' + tDef.name : troopKey) + ' subido a nivel ' + newLvl + '!';
        console.log(msg);
        // PequeÃ±o toast
        _showToast(msg);
      } catch(e) {
        console.error('upgradeTroopLevel error:', e);
        alert('Error al subir nivel: ' + e.message);
      }
    }

    // Toast simple (reutilizable)
    function _showToast(msg) {
      var t = document.createElement('div');
      t.textContent = msg;
      t.style.cssText = 'position:fixed;bottom:70px;left:50%;transform:translateX(-50%);background:#222;color:#fff;padding:10px 20px;border-radius:8px;z-index:9999;font-size:.85rem;box-shadow:0 2px 12px #0008;pointer-events:none;';
      document.body.appendChild(t);
      setTimeout(function(){ t.style.opacity='0'; t.style.transition='opacity .5s'; setTimeout(function(){ t.remove(); }, 500); }, 2500);
    }

    // ================================================================
    // ALIANZAS â€” sistema completo
    // ================================================================

    // Estado local de alianza del jugador actual
    var _myAllianceId = null;
    var _myAllianceRole = null; // 'leader' | 'member'
    var _myAllianceStatus = null; // 'active' | 'pending' | 'invited'

    // Oculta todos los sub-paneles de alianza
    function _alHideAll() {
      ['alNoAlliancePanel', 'alMemberPanel', 'alLeaderPanel', 'alPendingPanel'].forEach(function (id) {
        var el = document.getElementById(id);
        if (el) el.style.display = 'none';
      });
    }

    // Actualiza el tag en el overview
    function _alUpdateOverview(tag, name) {
      window._playerAllianceTag = tag || null;
      window._playerAllianceName = name || null;
      var el = document.getElementById('ovAlliance');
      if (el) {
        el.textContent = tag ? '[' + tag + '] ' + (name || '') : '';
      }
    }

    async function refreshMyAlliance() {
      if (!(await ensureLogged())) return;
      const box = document.getElementById('myAllianceBox');
      if (box) box.innerHTML = '<span class="muted">Cargandoâ€¦</span>';

      // Paso 1: obtener fila de alliance_members SIN join (el join falla si no hay FK registrada)
      const r = await sbClient.from('alliance_members')
        .select('status,role,alliance_id')
        .eq('user_id', currentUser.id)
        .order('created_at', { ascending: false })
        .limit(5);

      if (r.error) {
        // 500 = error de servidor/RLS â€” no bloquear el juego, mostrar sin alianza
        console.warn('alliance_members error:', r.error.message, 'â€” comprueba las polÃ­ticas RLS de la tabla');
        if (box) box.innerHTML = '<span class="muted">No se pudo cargar alianza. <a href="#" onclick="refreshMyAlliance();return false;">Reintentar</a></span>';
        _alHideAll();
        var p = document.getElementById('alNoAlliancePanel');
        if (p) p.style.display = '';
        return;
      }

      const row = (r.data || []).find(x => x.status === 'active' || x.status === 'invited' || x.status === 'pending');

      _alHideAll();
      _myAllianceId = null;
      _myAllianceRole = null;
      _myAllianceStatus = null;

      if (!row) {
        if (box) box.innerHTML = '<span class="muted">No perteneces a ninguna alianza.</span>';
        _alUpdateOverview(null, null);
        var p = document.getElementById('alNoAlliancePanel');
        if (p) { p.style.display = ''; _loadAllianceList(); }
        return;
      }

      _myAllianceId = row.alliance_id;
      _myAllianceRole = row.role;
      _myAllianceStatus = row.status;

      // Paso 2: obtener datos de la alianza por separado
      const ar = await sbClient.from('alliances')
        .select('id,name,tag')
        .eq('id', row.alliance_id)
        .maybeSingle();

      var al = (ar.data) || { id: row.alliance_id, name: 'Alianza', tag: '???' };

      if (box) {
        box.innerHTML = '<b style="color:var(--accent)">[' + escapeHtml(al.tag || '') + '] ' + escapeHtml(al.name || '') + '</b>'
          + ' <span class="muted">&nbsp;&middot; Estado: ' + escapeHtml(row.status) + ' &middot; Rol: ' + escapeHtml(row.role) + '</span>';
      }

      if (row.status === 'pending' || row.status === 'invited') {
        _alUpdateOverview(null, null);
        var pp = document.getElementById('alPendingPanel');
        if (pp) pp.style.display = '';
        var sb = document.getElementById('alPendingStatusBox');
        var acts = document.getElementById('alPendingActions');
        if (sb) {
          sb.innerHTML = row.status === 'invited'
            ? '&#x1F4E8; Has sido <b>invitado</b> a <b>[' + escapeHtml(al.tag) + '] ' + escapeHtml(al.name) + '</b>. Â¿Aceptas?'
            : '&#x23F3; Tu solicitud para unirte a <b>[' + escapeHtml(al.tag) + '] ' + escapeHtml(al.name) + '</b> estÃ¡ <b>pendiente de aprobaciÃ³n</b>.';
        }
        if (acts) {
          acts.innerHTML = row.status === 'invited'
            ? '<button class="btn" onclick="acceptInvite()">&#x2714; Aceptar invitaciÃ³n</button>'
            + '<button class="btn" style="background:rgba(224,64,64,.1);border-color:var(--danger);color:var(--danger);" onclick="declineOrCancel()">&#x2715; Rechazar</button>'
            : '<button class="btn" style="background:rgba(224,64,64,.1);border-color:var(--danger);color:var(--danger);" onclick="declineOrCancel()">&#x2715; Cancelar solicitud</button>';
        }
        return;
      }

      // status === 'active'
      _alUpdateOverview(al.tag, al.name);
      loadAllyUserIds(); // Actualizar set de aliados para el mapa

      if (row.role === 'leader') {
        var lp = document.getElementById('alLeaderPanel');
        if (lp) lp.style.display = '';
        _loadLeaderData(row.alliance_id);
      } else {
        var mp = document.getElementById('alMemberPanel');
        if (mp) mp.style.display = '';
        _loadMembersList(row.alliance_id, false);
        _loadAllianceAnnouncement(row.alliance_id);
      }
    }

    async function _loadAllianceList() {
      const box = document.getElementById('alliancesBox');
      if (!box) return;
      box.innerHTML = '<span class="muted">Cargandoâ€¦</span>';
      const r = await sbClient.from('alliances').select('id,name,tag,created_at').order('created_at', { ascending: false }).limit(100);
      if (r.error) { box.innerHTML = '<span class="muted">Error: ' + escapeHtml(r.error.message) + '</span>'; return; }
      if (!r.data || r.data.length === 0) { box.innerHTML = '<span class="muted">No hay alianzas aÃºn.</span>'; return; }
      let html = '<div class="table"><div class="trow thead"><div>TAG</div><div>Nombre</div><div></div></div>';
      r.data.forEach(al => {
        html += '<div class="trow"><div><b>[' + escapeHtml(al.tag) + ']</b></div><div>' + escapeHtml(al.name) + '</div>'
          + '<div><button class="btn btn-sm" onclick="requestJoinAlliance(' + al.id + ', \'' + escapeHtml(al.name) + '\')">Solicitar</button></div></div>';
      });
      html += '</div>';
      box.innerHTML = html;
    }

    async function _loadMembersList(allianceId, isLeader) {
      var boxId = isLeader ? 'alLeaderMembersList' : 'alMembersList';
      const box = document.getElementById(boxId);
      if (!box) return;
      box.innerHTML = '<span class="muted">Cargandoâ€¦</span>';
      const r = await sbClient.from('alliance_members')
        .select('user_id,role,status,profiles(username)')
        .eq('alliance_id', allianceId)
        .eq('status', 'active');
      if (r.error) { box.innerHTML = '<span class="muted">Error.</span>'; return; }
      if (!r.data || r.data.length === 0) { box.innerHTML = '<span class="muted">Sin miembros activos.</span>'; return; }
      let html = '<div class="table"><div class="trow thead"><div>Jugador</div><div>Rol</div>' + (isLeader ? '<div></div>' : '') + '</div>';
      r.data.forEach(m => {
        var uname = (m.profiles && m.profiles.username) ? escapeHtml(m.profiles.username) : m.user_id.slice(0, 8);
        var isMe = m.user_id === currentUser.id;
        html += '<div class="trow"><div>' + uname + (isMe ? ' <span style="color:var(--dim);font-size:.7rem;">(tÃº)</span>' : '') + '</div><div>' + escapeHtml(m.role) + '</div>';
        if (isLeader && !isMe) {
          html += '<div><button class="btn btn-sm" style="background:rgba(224,64,64,.1);border-color:var(--danger);color:var(--danger);" onclick="kickMember(\'' + m.user_id + '\', \'' + uname + '\')">Expulsar</button></div>';
        } else if (isLeader) {
          html += '<div></div>';
        }
        html += '</div>';
      });
      html += '</div>';
      box.innerHTML = html;
    }

    async function _loadPendingRequests(allianceId) {
      const box = document.getElementById('alPendingList');
      if (!box) return;
      box.innerHTML = '<span class="muted">Cargandoâ€¦</span>';
      const r = await sbClient.from('alliance_members')
        .select('user_id,status,profiles(username)')
        .eq('alliance_id', allianceId)
        .in('status', ['pending', 'invited']);
      if (r.error) { box.innerHTML = '<span class="muted">Error.</span>'; return; }
      if (!r.data || r.data.length === 0) { box.innerHTML = '<span class="muted">Sin solicitudes pendientes.</span>'; return; }
      let html = '<div class="table"><div class="trow thead"><div>Jugador</div><div>Estado</div><div></div></div>';
      r.data.forEach(m => {
        var uname = (m.profiles && m.profiles.username) ? escapeHtml(m.profiles.username) : m.user_id.slice(0, 8);
        var isPending = m.status === 'pending';
        html += '<div class="trow"><div>' + uname + '</div><div style="color:var(--accent);">' + escapeHtml(m.status) + '</div><div style="display:flex;gap:4px;">';
        if (isPending) {
          html += '<button class="btn btn-sm" onclick="acceptMember(\'' + m.user_id + '\', \'' + uname + '\')">&#x2714; Aceptar</button>'
            + '<button class="btn btn-sm" style="background:rgba(224,64,64,.1);border-color:var(--danger);color:var(--danger);" onclick="rejectMember(\'' + m.user_id + '\', \'' + uname + '\')">&#x2715; Rechazar</button>';
        } else {
          // invited â€” cancelar invitaciÃ³n
          html += '<button class="btn btn-sm" style="background:rgba(224,64,64,.1);border-color:var(--danger);color:var(--danger);" onclick="rejectMember(\'' + m.user_id + '\', \'' + uname + '\')">&#x2715; Cancelar</button>';
        }
        html += '</div></div>';
      });
      html += '</div>';
      box.innerHTML = html;
    }

    async function _loadLeaderData(allianceId) {
      await Promise.all([
        _loadMembersList(allianceId, true),
        _loadPendingRequests(allianceId),
        _loadAllianceAnnouncement(allianceId)
      ]);
    }


    // v1.22: Ranking colectivo de alianzas
    async function renderAllianceRanking() {
      var box = document.getElementById('allianceRankingBox');
      if (!box) return;
      box.innerHTML = '<span class="muted">Cargandoâ€¦</span>';

      // Reutilizar cachÃ© del ranking individual si existe
      var rows = rankingCache ? rankingCache.data : null;
      if (!rows) {
        var v = await sbClient.from('ranking')
          .select('username, military_score, alliance_tag')
          .order('military_score', { ascending: false })
          .limit(500);
        rows = (!v.error && v.data && v.data.length > 0) ? v.data : [];
      }

      // Agrupar por alliance_tag
      var alMap = {};
      rows.forEach(function (r) {
        if (!r.alliance_tag) return;
        if (!alMap[r.alliance_tag]) alMap[r.alliance_tag] = { tag: r.alliance_tag, score: 0, members: 0 };
        alMap[r.alliance_tag].score += (r.military_score || 0);
        alMap[r.alliance_tag].members++;
      });

      var sorted = Object.values(alMap).sort(function (a, b) { return b.score - a.score; });

      if (sorted.length === 0) {
        box.innerHTML = '<span class="muted">Sin alianzas con puntuaciÃ³n aÃºn.</span>';
        return;
      }

      var html = '<div class="table"><div class="trow thead"><div>#</div><div>TAG</div><div>Miembros</div><div>PuntuaciÃ³n total</div></div>';
      sorted.forEach(function (al, i) {
        var isMyAl = window._playerAllianceTag && window._playerAllianceTag === al.tag;
        html += '<div class="trow" style="' + (isMyAl ? 'background:rgba(0,212,255,.06);' : '') + '">'
          + '<div style="color:var(--dim);">' + (i + 1) + '</div>'
          + '<div><b style="color:' + (isMyAl ? 'var(--accent)' : 'var(--text)') + ';">[' + escapeHtml(al.tag) + ']</b></div>'
          + '<div style="color:var(--dim);">' + al.members + '</div>'
          + '<div style="color:var(--ok);font-weight:bold;">' + fmt(al.score) + '</div>'
          + '</div>';
      });
      html += '</div>';
      box.innerHTML = html;
    }

    async function renderAlliances() {
      await refreshMyAlliance();
      renderAllianceRanking();
    }


    // v1.22: TablÃ³n de anuncios de alianza
    async function saveAllianceAnnouncement() {
      if (_myAllianceRole !== 'leader') { showNotif('Solo el lÃ­der puede editar el anuncio.', 'err'); return; }
      var msg = document.getElementById('alAnnouncementMsg');
      var text = (document.getElementById('alAnnouncementInput').value || '').trim().slice(0, 500);
      msg.textContent = '';
      var r = await sbClient.from('alliances').update({ announcement: text }).eq('id', _myAllianceId);
      if (r.error) {
        // Si la columna no existe, avisar con instrucciÃ³n SQL
        if (r.error.message && r.error.message.includes('announcement')) {
          msg.style.color = 'var(--danger)';
          msg.textContent = 'Ejecuta en Supabase SQL: ALTER TABLE alliances ADD COLUMN announcement text DEFAULT \'\';';
        } else {
          msg.style.color = 'var(--danger)';
          msg.textContent = 'Error: ' + r.error.message;
        }
        return;
      }
      msg.style.color = 'var(--ok)';
      msg.textContent = 'âœ… Anuncio guardado';
      // Actualizar el display del miembro tambiÃ©n
      var display = document.getElementById('alAnnouncementDisplay');
      if (display) display.textContent = text || 'Sin anuncios.';
    }

    async function _loadAllianceAnnouncement(allianceId) {
      var r = await sbClient.from('alliances').select('announcement').eq('id', allianceId).maybeSingle();
      var text = (r.data && r.data.announcement) ? r.data.announcement : '';
      var display = document.getElementById('alAnnouncementDisplay');
      var input = document.getElementById('alAnnouncementInput');
      if (display) display.textContent = text || 'Sin anuncios.';
      if (input) input.value = text;
    }

    async function createAlliance() {
      if (!(await ensureLogged())) return;
      const msg = document.getElementById('createAllianceMsg');
      msg.textContent = '';
      msg.style.color = 'var(--danger)';

      // Validaciones
      const name = (document.getElementById('alName').value || '').trim();
      const tag = (document.getElementById('alTag').value || '').trim().toUpperCase();
      if (name.length < 3) { msg.textContent = 'Nombre demasiado corto (mÃ­n. 3 caracteres).'; return; }
      if (tag.length < 2 || tag.length > 6 || !/^[A-Z0-9]+$/.test(tag)) { msg.textContent = 'TAG invÃ¡lido (2-6 letras/nÃºmeros sin espacios).'; return; }

      // Â¿Ya estÃ¡ en una alianza?
      const chk = await sbClient.from('alliance_members').select('status').eq('user_id', currentUser.id).in('status', ['active', 'pending', 'invited']);
      if (chk.data && chk.data.length > 0) { msg.textContent = 'Ya perteneces o tienes solicitud en una alianza.'; return; }

      // Â¿Tag ya existe?
      const tagChk = await sbClient.from('alliances').select('id').eq('tag', tag).maybeSingle();
      if (tagChk.data) { msg.textContent = 'Ese TAG ya estÃ¡ en uso.'; return; }

      let id = null;
      const rpc = await sbClient.rpc('create_alliance', { p_name: name, p_tag: tag });
      if (!rpc.error && rpc.data) {
        id = rpc.data;
      } else {
        const ins = await sbClient.from('alliances').insert({ name, tag, owner_id: currentUser.id }).select('id').single();
        if (ins.error) { msg.textContent = 'Error: ' + ins.error.message; return; }
        id = ins.data.id;
        const mem = await sbClient.from('alliance_members').insert({ alliance_id: id, user_id: currentUser.id, role: 'leader', status: 'active' });
        if (mem.error) { msg.textContent = 'Error al unirse: ' + mem.error.message; return; }
      }

      msg.style.color = 'var(--ok)';
      msg.textContent = 'Â¡Alianza [' + tag + '] creada! âœ…';
      document.getElementById('alName').value = '';
      document.getElementById('alTag').value = '';
      await refreshMyAlliance();
    }

    async function requestJoinAlliance(allianceId, allianceName) {
      if (!(await ensureLogged())) return;

      // Â¿Ya tiene solicitud / estÃ¡ activo?
      const chk = await sbClient.from('alliance_members').select('status').eq('user_id', currentUser.id);
      if (chk.data && chk.data.length > 0) {
        var existing = chk.data.find(x => x.status === 'active' || x.status === 'pending' || x.status === 'invited');
        if (existing) { showNotif('Ya tienes una solicitud activa o perteneces a una alianza.', 'err'); return; }
      }

      const ins = await sbClient.from('alliance_members').insert({
        alliance_id: allianceId, user_id: currentUser.id, role: 'member', status: 'pending'
      });
      if (ins.error) { showNotif('Error: ' + ins.error.message, 'err'); return; }

      showNotif('Solicitud enviada a ' + (allianceName || 'la alianza') + ' âœ…', 'ok');
      var pmsg = document.getElementById('alPendingMsg');
      if (pmsg) pmsg.textContent = 'Solicitud enviada. Espera a que el lÃ­der la acepte.';
      await refreshMyAlliance();
    }

    async function acceptInvite() {
      if (!(await ensureLogged())) return;
      if (!_myAllianceId) { showNotif('No tienes invitaciÃ³n pendiente.', 'err'); return; }
      const up = await sbClient.from('alliance_members')
        .update({ status: 'active' })
        .eq('alliance_id', _myAllianceId)
        .eq('user_id', currentUser.id);
      if (up.error) { showNotif('Error: ' + up.error.message, 'err'); return; }
      showNotif('Â¡InvitaciÃ³n aceptada! Bienvenido a la alianza âœ…', 'ok');
      await refreshMyAlliance();
    }

    async function declineOrCancel() {
      if (!(await ensureLogged())) return;
      if (!_myAllianceId) return;
      const del = await sbClient.from('alliance_members')
        .delete()
        .eq('alliance_id', _myAllianceId)
        .eq('user_id', currentUser.id);
      if (del.error) { showNotif('Error: ' + del.error.message, 'err'); return; }
      showNotif('Solicitud/invitaciÃ³n cancelada.', 'ok');
      await refreshMyAlliance();
    }

    async function leaveAlliance() {
      if (!(await ensureLogged())) return;
      if (!_myAllianceId) { showNotif('No estÃ¡s en ninguna alianza.', 'err'); return; }
      if (_myAllianceRole === 'leader') {
        showNotif('Eres el lÃ­der. Usa "Disolver alianza" o transfiere el liderazgo primero.', 'err');
        return;
      }
      if (!confirm('Â¿Seguro que quieres salir de la alianza?')) return;
      const del = await sbClient.from('alliance_members')
        .delete()
        .eq('alliance_id', _myAllianceId)
        .eq('user_id', currentUser.id);
      if (del.error) { showNotif('Error: ' + del.error.message, 'err'); return; }
      showNotif('Has salido de la alianza.', 'ok');
      _alUpdateOverview(null, null);
      await refreshMyAlliance();
    }

    async function dissolveAlliance() {
      if (!(await ensureLogged())) return;
      if (_myAllianceRole !== 'leader') { showNotif('Solo el lÃ­der puede disolver la alianza.', 'err'); return; }
      if (!confirm('Â¿Seguro? Esto eliminarÃ¡ la alianza y expulsarÃ¡ a todos sus miembros. Esta acciÃ³n es IRREVERSIBLE.')) return;
      await sbClient.from('alliance_members').delete().eq('alliance_id', _myAllianceId);
      const del = await sbClient.from('alliances').delete().eq('id', _myAllianceId);
      if (del.error) { showNotif('Error: ' + del.error.message, 'err'); return; }
      showNotif('Alianza disuelta.', 'ok');
      _alUpdateOverview(null, null);
      await refreshMyAlliance();
    }

    async function inviteToAlliance() {
      if (!(await ensureLogged())) return;
      if (_myAllianceRole !== 'leader') { showNotif('Solo el lÃ­der puede invitar.', 'err'); return; }
      const msg = document.getElementById('alInviteMsg');
      msg.textContent = '';
      msg.style.color = 'var(--danger)';
      const username = (document.getElementById('alInviteUser').value || '').trim();
      if (!username) { msg.textContent = 'Escribe un nombre de usuario.'; return; }

      // Buscar el usuario por username
      const pu = await sbClient.from('profiles').select('id,username').ilike('username', username).maybeSingle();
      if (pu.error || !pu.data) { msg.textContent = 'Jugador "' + escapeHtml(username) + '" no encontrado.'; return; }
      const targetId = pu.data.id;
      if (targetId === currentUser.id) { msg.textContent = 'No puedes invitarte a ti mismo.'; return; }

      // Â¿Ya tiene estado en alguna alianza?
      const chk = await sbClient.from('alliance_members').select('status,alliance_id').eq('user_id', targetId);
      if (chk.data && chk.data.length > 0) {
        var conflict = chk.data.find(x => x.status === 'active' || x.status === 'invited');
        if (conflict) { msg.textContent = 'Ese jugador ya pertenece a una alianza o tiene una invitaciÃ³n pendiente.'; return; }
        // Si tiene una pending en OTRA alianza, se puede invitar igualmente (queda a su elecciÃ³n)
        var pendingHere = chk.data.find(x => x.alliance_id === _myAllianceId);
        if (pendingHere) { msg.textContent = 'Ese jugador ya tiene una solicitud en tu alianza.'; return; }
      }

      const ins = await sbClient.from('alliance_members').insert({
        alliance_id: _myAllianceId, user_id: targetId, role: 'member', status: 'invited'
      });
      if (ins.error) { msg.textContent = 'Error: ' + ins.error.message; return; }

      msg.style.color = 'var(--ok)';
      msg.textContent = 'InvitaciÃ³n enviada a ' + escapeHtml(pu.data.username) + ' âœ…';
      document.getElementById('alInviteUser').value = '';
      _loadPendingRequests(_myAllianceId);
    }

    async function acceptMember(userId, username) {
      if (!(await ensureLogged())) return;
      const up = await sbClient.from('alliance_members')
        .update({ status: 'active' })
        .eq('alliance_id', _myAllianceId)
        .eq('user_id', userId);
      if (up.error) { showNotif('Error: ' + up.error.message, 'err'); return; }
      showNotif(username + ' aceptado en la alianza âœ…', 'ok');
      _loadLeaderData(_myAllianceId);
    }

    async function rejectMember(userId, username) {
      if (!(await ensureLogged())) return;
      const del = await sbClient.from('alliance_members')
        .delete()
        .eq('alliance_id', _myAllianceId)
        .eq('user_id', userId);
      if (del.error) { showNotif('Error: ' + del.error.message, 'err'); return; }
      showNotif(username + ' rechazado/expulsado.', 'ok');
      _loadLeaderData(_myAllianceId);
    }

    async function kickMember(userId, username) {
      if (!(await ensureLogged())) return;
      if (!confirm('Â¿Expulsar a ' + username + ' de la alianza?')) return;
      const del = await sbClient.from('alliance_members')
        .delete()
        .eq('alliance_id', _myAllianceId)
        .eq('user_id', userId);
      if (del.error) { showNotif('Error: ' + del.error.message, 'err'); return; }
      showNotif(username + ' expulsado de la alianza.', 'ok');
      _loadLeaderData(_myAllianceId);
    }

    // ---------------- MESSAGES ----------------

    // Cache de perfiles: userId -> {username, allianceTag}
    const profileCache = {};

    async function getProfileInfo(userId) {
      if (!userId) return { username: 'Sistema', allianceTag: null };
      if (profileCache[userId]) return profileCache[userId];
      try {
        const p = await sbClient.from('profiles').select('username').eq('id', userId).maybeSingle();
        const username = (p.data && p.data.username) ? p.data.username : 'Jugador';
        let allianceTag = null;
        const am = await sbClient.from('alliance_members')
          .select('status,alliances(tag)')
          .eq('user_id', userId).eq('status', 'active').maybeSingle();
        if (am.data && am.data.alliances) allianceTag = am.data.alliances.tag;
        const info = { username, allianceTag };
        profileCache[userId] = info;
        return info;
      } catch (e) {
        return { username: 'Jugador', allianceTag: null };
      }
    }

    // Detecta el subtipo de mensaje de sistema por el cuerpo del mensaje
    function getSystemMsgStyle(body) {
      if (!body) return { icon: 'ğŸ””', color: 'var(--esencia)', label: 'Sistema' };
      var b = body.toUpperCase();
      if (b.includes('ESPIONAJE') || b.includes('SPY') || b.includes('ğŸ”'))
        return { icon: 'ğŸ”', color: 'var(--aldeanos)', label: 'Espionaje' };
      if (b.includes('BATALLA') || b.includes('ATTACK') || b.includes('âš”') || b.includes('ğŸ†') || b.includes('ğŸ’€'))
        return { icon: 'âš”ï¸', color: 'var(--danger)', label: 'Batalla' };
      return { icon: 'ğŸ””', color: 'var(--esencia)', label: 'Informe' };
    }

    // Tipo de hilo â†’ icono + color + etiqueta
    function threadMeta(type) {
      if (type === 'system') return { icon: 'ğŸ””', color: 'var(--esencia)', label: 'Sistema' };
      if (type === 'alliance') return { icon: 'âš”ï¸', color: 'var(--accent2)', label: 'Alianza' };
      return { icon: 'âœ‰ï¸', color: 'var(--accent)', label: 'DM' };
    }

    // Actualiza la cabecera del chat con el tipo de hilo y nombre
    function renderMessagesHeader(type, title) {
      const h = document.getElementById('chatHeader');
      const area = document.getElementById('chatInputArea');
      if (!type) {
        h.innerHTML = '<span style="color:var(--dim);font-size:.78rem;">Selecciona una conversaciÃ³nâ€¦</span>';
        if (area) area.style.display = 'none';
        return;
      }
      var m = threadMeta(type);
      var isSystem = (type === 'system');

      // Diferentes estilos segÃºn el tipo
      if (type === 'system') {
        h.innerHTML = '<span style="font-size:1.1rem;">' + m.icon + '</span>'
          + '<div style="flex:1;">'
          + '<div style="font-size:.85rem;color:' + m.color + ';font-weight:600;">' + escapeHtml(title) + '</div>'
          + '<div style="font-size:.65rem;color:var(--dim);">Reportes de batallas y espionajes</div>'
          + '</div>';
      } else if (type === 'dm') {
        h.innerHTML = '<span style="font-size:1.1rem;">' + m.icon + '</span>'
          + '<div style="flex:1;">'
          + '<div style="font-size:.95rem;color:var(--text);font-weight:600;">' + escapeHtml(title) + '</div>'
          + '<div style="font-size:.65rem;color:var(--dim);letter-spacing:.08em;">MENSAJE DIRECTO</div>'
          + '</div>';
      } else {
        h.innerHTML = '<span style="font-size:1.1rem;">' + m.icon + '</span>'
          + '<div style="flex:1;">'
          + '<div style="font-size:.8rem;color:' + m.color + ';letter-spacing:.08em;">' + m.label + '</div>'
          + '<div style="font-size:.72rem;color:var(--dim);">' + escapeHtml(title || '') + '</div>'
          + '</div>';
      }

      // Los mensajes de sistema son de solo lectura
      if (area) area.style.display = isSystem ? 'none' : 'flex';
    }

    async function renderThreads() {
      if (!(await ensureLogged())) return;
      const box = document.getElementById('threadsBox');
      box.innerHTML = '<div style="padding:10px 14px;font-size:.72rem;color:var(--dim);">Cargandoâ€¦</div>';

      const r = await sbClient.from('thread_members')
        .select('thread_id,last_read_at,message_threads(thread_type,created_at)')
        .eq('user_id', currentUser.id)
        .order('thread_id', { ascending: false })
        .limit(100);

      if (r.error) {
        box.innerHTML = '<div style="padding:10px 14px;font-size:.7rem;color:var(--danger);">Error: ' + escapeHtml(r.error.message) + '</div>';
        return;
      }

      const rows = r.data || [];
      if (rows.length === 0) {
        box.innerHTML = '<div style="padding:14px;font-size:.75rem;color:var(--dim);text-align:center;">Sin conversaciones aÃºn.<br>EspÃ­a a alguien o envÃ­a un DM.</div>';
        return;
      }

      var html = '';
      rows.forEach(function (x) {
        var t = (x.message_threads && x.message_threads.thread_type) || 'dm';
        var m = threadMeta(t);
        var isActive = (x.thread_id == currentThreadId);
        html += '<div onclick="openThread(\'' + x.thread_id + '\',\'' + t + '\')" style="'
          + 'display:flex;align-items:center;gap:10px;padding:9px 14px;cursor:pointer;'
          + 'border-left:3px solid ' + (isActive ? m.color : 'transparent') + ';'
          + 'background:' + (isActive ? 'rgba(255,255,255,.04)' : 'transparent') + ';'
          + 'transition:background .15s;"'
          + ' onmouseover="if(!this.classList.contains(\'active-thread\')) this.style.background=\'rgba(255,255,255,.03)\'"'
          + ' onmouseout="if(!this.classList.contains(\'active-thread\')) this.style.background=\'' + (isActive ? 'rgba(255,255,255,.04)' : 'transparent') + '\'">'
          + '<span style="font-size:1.1rem;flex-shrink:0;">' + m.icon + '</span>'
          + '<div style="flex:1;min-width:0;">'
          + '<div style="font-size:.75rem;color:' + m.color + ';white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">' + m.label + '</div>'
          + '<div style="font-size:.62rem;color:var(--dim);">#' + x.thread_id.toString().slice(-8) + '</div>'
          + '</div>'
          + '</div>';
      });
      box.innerHTML = html;
    }

    // Abre un hilo de sistema (el primero que encuentre de tipo system, o lo crea)
    async function openSystemThread() {
      if (!(await ensureLogged())) return;
      const r = await sbClient.from('thread_members')
        .select('thread_id,message_threads(thread_type)')
        .eq('user_id', currentUser.id)
        .limit(100);
      if (r.error) { showNotif('Error: ' + r.error.message, 'err'); return; }
      const sysRow = (r.data || []).find(x => x.message_threads && x.message_threads.thread_type === 'system');
      if (sysRow) {
        await openThread(sysRow.thread_id, 'system');
      } else {
        showNotif('No tienes informes de sistema aÃºn. EspÃ­a a alguien.', 'err');
      }
    }

    async function openThread(id, type) {
      if (!(await ensureLogged())) return;
      currentThreadId = id;
      currentThreadType = type || 'dm';

      // Ocultar/mostrar paneles segÃºn el tipo
      const reportsList = document.getElementById('reportsList');
      const chatBox = document.getElementById('chatBox');

      if (type === 'system') {
        reportsList.style.display = 'flex';
        chatBox.innerHTML = '<div style="display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;color:var(--dim);text-align:center;"><div style="font-size:2rem;margin-bottom:10px;">ğŸ“‹</div><div style="font-size:.85rem;">Selecciona un informe<br>de la lista</div></div>';
        await loadSystemReports();
        renderMessagesHeader('system', 'Informes del Sistema');
      } else {
        reportsList.style.display = 'none';

        var headerTitle = type === 'alliance' ? 'Chat de alianza' : 'Mensaje directo';

        if (type === 'dm') {
          try {
            var { data: members } = await sbClient
              .from('thread_members')
              .select('user_id,profiles(username)')
              .eq('thread_id', id);

            if (members && members.length > 0) {
              var otherUser = members.find(function (m) { return m.user_id !== currentUser.id; });
              if (otherUser && otherUser.profiles) {
                headerTitle = otherUser.profiles.username;
              }
            }
          } catch (e) {
            console.warn('openThread: error getting DM partner name', e);
          }
        }

        renderMessagesHeader(type, headerTitle);
        await loadThreadMessages(type);
      }

      subscribeToThread(id);
      await renderThreads();
      await updateUnreadCount(); // Actualizar badge
    }

    function parseMessageBody(rawBody) {
      if (!rawBody) return { title: 'Informe del sistema', body: '' };

      // Try to parse as JSON {title, body} â€” new format
      if (rawBody.trim().startsWith('{')) {
        try {
          var parsed = JSON.parse(rawBody);
          if (parsed.title !== undefined && parsed.body !== undefined) {
            return {
              title: parsed.title || 'Informe del sistema',
              body: parsed.body || ''
            };
          }
        } catch (e) {
          console.warn('parseMessageBody: JSON parse failed', e);
        }
      }

      // Legacy format: first line is title, rest is body
      var lines = rawBody.split('\n');
      var title = lines[0] || 'Informe del sistema';

      // Si la primera lÃ­nea parece ser una fecha/timestamp, usar la segunda
      if (title.match(/^\d{1,2}\/\d{1,2}\/\d{4}/)) {
        title = lines[1] || lines[0] || 'Informe del sistema';
      }

      return {
        title: title.trim() || 'Informe del sistema',
        body: rawBody
      };
    }

    function toggleMsgExpand(id) {
      var el = document.getElementById('msgBody_' + id);
      var btn = document.getElementById('msgToggle_' + id);
      if (!el) return;
      var expanded = el.style.display !== 'none';
      el.style.display = expanded ? 'none' : 'block';
      if (btn) btn.textContent = expanded ? 'â–¼' : 'â–²';
    }

    // v1.17: Marcar mensaje como leÃ­do y eliminar
    async function markMsgAsReadAndDelete(msgId) {
      try {
        // Marcar como leÃ­do en BD - sin filtro recipient_id (no existe en tabla)
        await sbClient.from('messages')
          .update({ read: true })
          .eq('id', msgId);

        // Eliminar de la vista inmediatamente
        var row = document.getElementById('msgRow_' + msgId);
        if (row) {
          row.style.transition = 'opacity .3s';
          row.style.opacity = '0';
          setTimeout(() => row.remove(), 300);
        }

        showNotif('Marcado como leÃ­do', 'ok');
        updateUnreadCount();
      } catch (e) {
        console.error('Error marking as read:', e);
        showNotif('Error al marcar como leÃ­do', 'err');
      }
    }

    // v1.17: Eliminar mensaje (lo borra de BD y de la vista)
    async function deleteMessage(msgId) {
      if (!confirm('Â¿Eliminar este mensaje?')) return;

      try {
        await sbClient.from('messages')
          .delete()
          .eq('id', msgId);

        // Eliminar de la vista inmediatamente
        var row = document.getElementById('msgRow_' + msgId);
        if (row) {
          row.style.transition = 'opacity .3s';
          row.style.opacity = '0';
          setTimeout(() => row.remove(), 300);
        }

        showNotif('Mensaje eliminado', 'ok');
      } catch (e) {
        console.error('Error deleting message:', e);
        showNotif('Error al eliminar', 'err');
      }
    }

    async function loadThreadMessages(threadType) {
      const box = document.getElementById('chatBox');
      if (!currentThreadId) { box.innerHTML = ''; return; }
      box.innerHTML = '<div style="color:var(--dim);font-size:.75rem;text-align:center;padding:20px;">Cargandoâ€¦</div>';

      const r = await sbClient.from('messages')
        .select('id,body,created_at,sender_id')
        .eq('thread_id', currentThreadId)
        .order('created_at', { ascending: false })
        .limit(80);

      if (r.error) {
        box.innerHTML = '<div style="color:var(--danger);font-size:.72rem;padding:10px;">Error: ' + escapeHtml(r.error.message) + '</div>';
        return;
      }

      const rows = (r.data || []).reverse();
      if (rows.length === 0) {
        box.innerHTML = '<div style="color:var(--dim);font-size:.75rem;text-align:center;padding:30px;">Sin mensajes aÃºn.</div>';
        return;
      }

      const uniqueSenders = [...new Set(rows.map(function (m) { return m.sender_id; }))];
      await Promise.all(uniqueSenders.map(function (id) { return getProfileInfo(id); }));

      var isSystem = (threadType === 'system');
      // Build DOM directly for system messages (Gmail inbox style)
      box.innerHTML = '';

      for (const m of rows) {
        const mine = (m.sender_id === currentUser.id);
        const isSystemMsg = !m.sender_id || isSystem;
        const info = profileCache[m.sender_id] || { username: 'Sistema', allianceTag: null };
        const displayName = isSystemMsg ? 'Sistema'
          : mine ? 'TÃº'
            : (info.username + (info.allianceTag ? ' [' + info.allianceTag + ']' : ''));

        if (isSystemMsg || isSystem) {
          // Parse title + body
          var parsed = parseMessageBody(m.body);
          var sStyle = getSystemMsgStyle(parsed.title + ' ' + (parsed.body || ''));
          var date = new Date(m.created_at);
          var timeStr = date.toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit' })
            + ' ' + date.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });

          // Render body: HTML if starts with <, else plain text
          var bodyHtml = '';
          if (parsed.body) {
            var b = parsed.body.trim();
            if (b) {
              bodyHtml = b.startsWith('<') ? b : '<pre style="white-space:pre-wrap;font-family:inherit;font-size:.78rem;">' + escapeHtml(b) + '</pre>';
            } else {
              bodyHtml = '<div style="color:var(--dim);font-size:.75rem;padding:8px;">Sin detalles adicionales.</div>';
            }
          } else {
            bodyHtml = '<div style="color:var(--dim);font-size:.75rem;padding:8px;">Sin detalles adicionales.</div>';
          }

          var row = document.createElement('div');
          row.style.cssText = 'border:1px solid ' + sStyle.color + '33;border-radius:8px;overflow:hidden;cursor:pointer;transition:background .15s;';
          row.onclick = function () { toggleMsgExpand(m.id); };
          row.onmouseover = function () { this.style.background = 'rgba(255,255,255,.03)'; };
          row.onmouseout = function () { this.style.background = ''; };

          // Header row (always visible)
          row.innerHTML = '<div style="display:flex;align-items:center;gap:8px;padding:9px 12px;background:' + sStyle.color + '0d;">'
            + '<span style="font-size:1rem;flex-shrink:0;">' + sStyle.icon + '</span>'
            + '<span style="font-size:.68rem;color:' + sStyle.color + ';letter-spacing:.06em;flex-shrink:0;min-width:60px;">' + sStyle.label.toUpperCase() + '</span>'
            + '<span style="flex:1;font-size:.78rem;color:var(--text);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">' + escapeHtml(parsed.title) + '</span>'
            + '<span style="font-size:.6rem;color:var(--dim);flex-shrink:0;margin-left:8px;">' + timeStr + '</span>'
            + '<span id="msgToggle_' + m.id + '" style="font-size:.6rem;color:var(--dim);margin-left:6px;">â–¼</span>'
            + '</div>'
            // Body (hidden by default, expands on click)
            + '<div id="msgBody_' + m.id + '" style="display:none;padding:12px 14px;border-top:1px solid ' + sStyle.color + '22;background:var(--bg);">'
            + bodyHtml
            + '</div>';

          box.appendChild(row);

        } else {
          // Mensajes DM / alianza: estilo Gmail colapsable igual que sistema
          var date2 = new Date(m.created_at);
          var timeStr2 = date2.toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit' })
            + ' ' + date2.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
          var senderColor = mine ? 'rgba(240,192,64,.9)' : 'rgba(0,212,255,.9)';
          var senderBg = mine ? 'rgba(240,192,64,.1)' : 'rgba(0,212,255,.08)';
          var bodyContent = '<div style="padding:12px 14px;border-top:1px solid rgba(255,255,255,.06);background:var(--bg);font-size:.82rem;color:var(--text);line-height:1.5;white-space:pre-wrap;word-break:break-word;">' + escapeHtml(m.body) + '</div>';
          var preview = (m.body || '').slice(0, 80) + ((m.body || '').length > 80 ? 'â€¦' : '');

          var row = document.createElement('div');
          row.style.cssText = 'border:1px solid rgba(255,255,255,.07);border-radius:8px;overflow:hidden;cursor:pointer;transition:background .15s;margin-bottom:4px;';
          row.onclick = function () { toggleMsgExpand(m.id); };
          row.onmouseover = function () { this.style.background = 'rgba(255,255,255,.03)'; };
          row.onmouseout = function () { this.style.background = ''; };
          row.innerHTML = '<div style="display:flex;align-items:center;gap:8px;padding:9px 12px;background:' + senderBg + ';">'
            + '<span style="font-size:.85rem;flex-shrink:0;">' + (mine ? 'ğŸ‘¤' : 'ğŸ’¬') + '</span>'
            + '<span style="font-size:.75rem;color:' + senderColor + ';font-weight:bold;flex-shrink:0;min-width:70px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">' + escapeHtml(displayName) + '</span>'
            + '<span style="flex:1;font-size:.75rem;color:var(--dim);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">' + escapeHtml(preview) + '</span>'
            + '<span style="font-size:.6rem;color:var(--dim);flex-shrink:0;margin-left:8px;">' + timeStr2 + '</span>'
            + '<button onclick="event.stopPropagation(); markMsgAsReadAndDelete(' + m.id + ')" style="padding:3px 8px;background:rgba(96,208,96,.15);border:1px solid var(--accent2);border-radius:3px;color:var(--accent2);font-size:.6rem;cursor:pointer;margin:0 4px;flex-shrink:0;">âœ“</button>'
            + '<button onclick="event.stopPropagation(); deleteMessage(' + m.id + ')" style="padding:3px 8px;background:rgba(255,61,90,.15);border:1px solid rgba(255,61,90,.4);border-radius:3px;color:rgba(255,61,90,.8);font-size:.6rem;cursor:pointer;margin:0 4px;flex-shrink:0;">ğŸ—‘</button>'
            + '<span id="msgToggle_' + m.id + '" style="font-size:.6rem;color:var(--dim);margin-left:6px;">â–¼</span>'
            + '</div>'
            + '<div id="msgBody_' + m.id + '" style="display:none;">' + bodyContent + '</div>';
          row.id = 'msgRow_' + m.id;
          box.appendChild(row);
        }
      }

      box.scrollTop = box.scrollHeight;
    }

    // ============================================================
    // SISTEMA DE REPORTES (v1.11)
    // ============================================================

    var currentReportId = null;

    async function loadSystemReports() {
      // v1.30: reset selection state on every reload
      _selectedReportIds = new Set();
      var selChk = document.getElementById('selectAllReportsChk');
      if (selChk) { selChk.checked = false; selChk.indeterminate = false; }
      _updateReportsToolbar();

      const box = document.getElementById('reportsListBox');
      if (!currentThreadId) {
        box.innerHTML = '<div style="padding:14px;color:var(--dim);font-size:.75rem;text-align:center;">Sin informes</div>';
        return;
      }

      box.innerHTML = '<div style="padding:14px;color:var(--dim);font-size:.75rem;text-align:center;">Cargandoâ€¦</div>';

      const r = await sbClient.from('messages')
        .select('id,body,created_at,read')
        .eq('thread_id', currentThreadId)
        .order('created_at', { ascending: false })
        .limit(100);

      if (r.error) {
        box.innerHTML = '<div style="padding:14px;color:var(--danger);font-size:.72rem;">Error: ' + escapeHtml(r.error.message) + '</div>';
        return;
      }

      const reports = r.data || [];
      if (reports.length === 0) {
        box.innerHTML = '<div style="padding:14px;color:var(--dim);font-size:.75rem;text-align:center;">Sin informes aÃºn.<br>Realiza espionajes o batallas.</div>';
        return;
      }

      box.innerHTML = '';

      reports.forEach(function (msg) {
        var parsed = parseMessageBody(msg.body);
        var sStyle = getSystemMsgStyle(parsed.title + ' ' + (parsed.body || ''));
        var date = new Date(msg.created_at);
        var timeStr = date.toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit', year: '2-digit' })
          + ' ' + date.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });

        var isActive = (currentReportId === msg.id);
        var isUnread = !msg.read;

        var item = document.createElement('div');
        item.style.cssText = 'padding:10px 12px;margin-bottom:6px;border-radius:6px;cursor:pointer;'
          + 'border:1px solid ' + (isActive ? sStyle.color : 'var(--border)') + ';'
          + 'background:' + (isActive ? sStyle.color + '15' : isUnread ? 'rgba(255,255,255,.03)' : 'transparent') + ';'
          + 'transition:all .15s;';

        item.onmouseover = function () {
          if (!isActive) this.style.background = 'rgba(255,255,255,.05)';
        };
        item.onmouseout = function () {
          if (!isActive) this.style.background = isUnread ? 'rgba(255,255,255,.03)' : 'transparent';
        };

        item.id = 'reportItem_' + msg.id;
        item.onclick = function (e) {
          if (e.target.type === 'checkbox') return;
          openReport(msg.id, msg.body, msg.read);
        };

        item.innerHTML = '<div style="display:flex;align-items:center;gap:6px;">'
          + '<input type="checkbox" id="chk_' + msg.id + '" onclick="event.stopPropagation();toggleReportSelect(\'' + msg.id + '\')" style="width:14px;height:14px;cursor:pointer;flex-shrink:0;accent-color:var(--danger);">'
          + '<span style="font-size:1rem;flex-shrink:0;">' + sStyle.icon + '</span>'
          + '<div style="flex:1;min-width:0;">'
          + '<div style="font-size:.75rem;color:' + sStyle.color + ';font-weight:' + (isUnread ? 'bold' : 'normal') + ';white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">' + escapeHtml(parsed.title) + '</div>'
          + '<div style="font-size:.6rem;color:var(--dim);margin-top:2px;">' + timeStr + '</div>'
          + '</div>'
          + (isUnread ? '<div style="width:8px;height:8px;background:var(--danger);border-radius:50%;flex-shrink:0;"></div>' : '')
          + '</div>';

        box.appendChild(item);
      });
    }

    async function openReport(msgId, body, isRead) {
      currentReportId = msgId;
      const chatBox = document.getElementById('chatBox');

      // Marcar como leÃ­do si no lo estÃ¡
      if (!isRead) {
        try {
          const r = await sbClient.from('messages')
            .update({ read: true })
            .eq('id', msgId);

          if (r.error) {
            console.warn('Error marking as read:', r.error);
          }

          // Esperar un poquito para que la BD se actualice
          await new Promise(resolve => setTimeout(resolve, 100));

          await updateUnreadCount();
          await loadSystemReports(); // Refrescar lista
        } catch (e) {
          console.warn('Error in openReport read update:', e);
        }
      }

      var parsed = parseMessageBody(body);
      var sStyle = getSystemMsgStyle(parsed.title + ' ' + (parsed.body || ''));
      var date = new Date();

      // Renderizar el reporte completo con botones de acciÃ³n
      var html = '<div style="padding:0;">';

      // Header del reporte
      html += '<div style="padding:14px 16px;border-bottom:1px solid var(--border);background:' + sStyle.color + '0d;display:flex;align-items:center;gap:10px;">';
      html += '<span style="font-size:1.4rem;">' + sStyle.icon + '</span>';
      html += '<div style="flex:1;">';
      html += '<div style="font-size:.9rem;color:' + sStyle.color + ';font-weight:bold;">' + escapeHtml(parsed.title) + '</div>';
      html += '<div style="font-size:.65rem;color:var(--dim);margin-top:2px;">' + sStyle.label.toUpperCase() + '</div>';
      html += '</div>';
      // BotÃ³n eliminar
      html += '<button onclick="deleteReport(\'' + msgId + '\')" style="padding:5px 10px;background:rgba(224,64,64,.1);border:1px solid var(--danger);border-radius:4px;color:var(--danger);font-family:VT323,monospace;font-size:.7rem;cursor:pointer;">ğŸ—‘ Eliminar</button>';
      html += '</div>';

      // Cuerpo del reporte (el HTML completo del informe)
      html += '<div style="padding:16px;overflow-y:auto;">';
      if (parsed.body) {
        var b = parsed.body.trim();
        if (b.startsWith('<')) {
          // Es HTML - renderizar directamente
          html += b;
        } else {
          // Es texto plano
          html += '<pre style="white-space:pre-wrap;font-family:inherit;font-size:.82rem;color:var(--text);line-height:1.6;">' + escapeHtml(b) + '</pre>';
        }
      } else {
        html += '<div style="color:var(--dim);font-size:.75rem;padding:20px;text-align:center;">Sin detalles adicionales.</div>';
      }
      html += '</div>';

      html += '</div>';

      chatBox.innerHTML = html;
    }

    // v1.22: Multi-select helpers para informes de sistema
    function toggleReportSelect(msgId) {
      var chk = document.getElementById('chk_' + msgId);
      if (!chk) return;
      if (chk.checked) {
        _selectedReportIds.add(msgId);
      } else {
        _selectedReportIds.delete(msgId);
      }
      _updateReportsToolbar();
    }

    function selectAllReports(selectAll) {
      var allChks = document.querySelectorAll('#reportsListBox input[type=checkbox]');
      allChks.forEach(function (chk) {
        chk.checked = selectAll;
        var id = chk.id.replace('chk_', '');
        if (selectAll) _selectedReportIds.add(id);
        else _selectedReportIds.delete(id);
      });
      _updateReportsToolbar();
    }

    function _updateReportsToolbar() {
      var count = _selectedReportIds.size;
      var countEl = document.getElementById('reportsSelCount');
      var btnEl = document.getElementById('reportsDeleteSelBtn');
      var chkAll = document.getElementById('selectAllReportsChk');
      var total = document.querySelectorAll('#reportsListBox input[type=checkbox]').length;

      if (countEl) countEl.textContent = count > 0 ? count + ' seleccionado' + (count !== 1 ? 's' : '') : '';
      if (btnEl) btnEl.style.display = count > 0 ? 'block' : 'none';
      if (chkAll) {
        chkAll.indeterminate = count > 0 && count < total;
        chkAll.checked = total > 0 && count === total;
      }
    }

    async function deleteSelectedReports() {
      var ids = Array.from(_selectedReportIds);
      if (ids.length === 0) return;
      if (!confirm('Â¿Eliminar ' + ids.length + ' informe(s) seleccionado(s)?')) return;

      var r = await sbClient.from('messages').delete().in('id', ids);
      if (r.error) { showNotif('Error al eliminar: ' + r.error.message, 'err'); return; }

      showNotif(ids.length + ' informe(s) eliminado(s)', 'ok');
      _selectedReportIds = new Set();
      currentReportId = null;
      var chatBox = document.getElementById('chatBox');
      if (chatBox) chatBox.innerHTML = '<div style="display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;color:var(--dim);text-align:center;"><div style="font-size:2rem;margin-bottom:10px;">ğŸ“‹</div><div style="font-size:.85rem;">Selecciona un informe<br>de la lista</div></div>';
      await loadSystemReports();
      await updateUnreadCount();
    }

    async function deleteReport(msgId) {
      if (!confirm('Â¿Eliminar este informe?')) return;

      const r = await sbClient.from('messages')
        .delete()
        .eq('id', msgId);

      if (r.error) {
        showNotif('Error al eliminar: ' + r.error.message, 'err');
        return;
      }

      showNotif('Informe eliminado', 'ok');
      currentReportId = null;

      const chatBox = document.getElementById('chatBox');
      chatBox.innerHTML = '<div style="display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;color:var(--dim);text-align:center;"><div style="font-size:2rem;margin-bottom:10px;">ğŸ“‹</div><div style="font-size:.85rem;">Selecciona un informe<br>de la lista</div></div>';

      await loadSystemReports();
      await updateUnreadCount();
    }

    async function markAllSystemAsRead() {
      if (!currentThreadId) return;

      try {
        const r = await sbClient.from('messages')
          .update({ read: true })
          .eq('thread_id', currentThreadId)
          .eq('read', false);

        if (r.error) {
          showNotif('Error: ' + r.error.message, 'err');
          return;
        }

        // Esperar a que se propague el cambio
        await new Promise(resolve => setTimeout(resolve, 100));

        showNotif('Todos los informes marcados como leÃ­dos', 'ok');
        await updateUnreadCount();
        await loadSystemReports();
      } catch (e) {
        console.error('Error in markAllSystemAsRead:', e);
        showNotif('Error al marcar como leÃ­dos', 'err');
      }
    }

    async function updateUnreadCount() {
      if (!(await ensureLogged())) return;

      // Contar mensajes no leÃ­dos del sistema
      const r = await sbClient.from('thread_members')
        .select('thread_id,message_threads(thread_type)')
        .eq('user_id', currentUser.id);

      if (r.error) return;

      var systemThreads = (r.data || [])
        .filter(x => x.message_threads && x.message_threads.thread_type === 'system')
        .map(x => x.thread_id);

      if (systemThreads.length === 0) {
        hideBadge();
        return;
      }

      // Contar mensajes no leÃ­dos en todos los hilos del sistema
      const m = await sbClient.from('messages')
        .select('id', { count: 'exact', head: true })
        .in('thread_id', systemThreads)
        .eq('read', false);

      if (m.error) return;

      var count = m.count || 0;

      if (count > 0) {
        showBadge(count);
      } else {
        hideBadge();
      }
    }

    function showBadge(count) {
      const badge = document.getElementById('msgBadge');
      if (badge) {
        badge.textContent = count > 99 ? '99+' : count;
        badge.style.display = 'inline-block';
      }
    }

    function hideBadge() {
      const badge = document.getElementById('msgBadge');
      if (badge) {
        badge.style.display = 'none';
      }
    }

    // ---- REALTIME ----
    let realtimeChannel = null;

    function subscribeToThread(threadId) {
      if (realtimeChannel) { sbClient.removeChannel(realtimeChannel); realtimeChannel = null; }
      if (!threadId) return;
      realtimeChannel = sbClient.channel('thread-' + threadId)
        .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'messages', filter: 'thread_id=eq.' + threadId },
          async function (payload) {
            const m = payload.new;
            if (!m) return;

            // Si es un mensaje del sistema, recargar lista de reportes
            if (currentThreadType === 'system') {
              await loadSystemReports();
            } else {
              await getProfileInfo(m.sender_id);
              await loadThreadMessages(currentThreadType || 'dm');
            }

            // Actualizar badge
            await updateUnreadCount();
          })
        .subscribe();
    }

    async function sendChatMsg() {
      if (!(await ensureLogged())) return;
      if (!currentThreadId) { showNotif('Elige una conversaciÃ³n primero.', 'err'); return; }
      const inp = document.getElementById('chatMsg');
      const body = (inp.value || '').trim();
      if (!body) return;
      const ins = await sbClient.from('messages').insert({ thread_id: currentThreadId, sender_id: currentUser.id, body });
      if (ins.error) { showNotif('No se pudo enviar: ' + ins.error.message, 'err'); return; }
      inp.value = '';
      await loadThreadMessages(currentThreadType || 'dm');
    }

    async function startDM() {
      if (!(await ensureLogged())) return;
      const uname = (document.getElementById('dmUser').value || '').trim();
      if (!uname) { showNotif('Escribe un username.', 'err'); return; }
      const u = await sbClient.from('profiles').select('id,username').eq('username', uname).maybeSingle();
      if (u.error || !u.data) { showNotif('Usuario no encontrado.', 'err'); return; }
      if (u.data.id === currentUser.id) { showNotif('No puedes enviarte un DM a ti mismo ğŸ˜„', 'err'); return; }
      const r = await sbClient.rpc('create_dm_thread', { p_other: u.data.id });
      if (r.error) { showNotif('No se pudo abrir DM: ' + r.error.message, 'err'); return; }
      currentThreadId = r.data;
      currentThreadType = 'dm';
      renderMessagesHeader('dm', 'DM con ' + u.data.username);
      subscribeToThread(r.data);
      await renderThreads();
      await loadThreadMessages('dm');
    }

    async function openAllianceChat() {
      if (!(await ensureLogged())) return;
      const r = await sbClient.from('alliance_members').select('alliance_id,status').eq('user_id', currentUser.id);
      if (r.error) { showNotif(r.error.message, 'err'); return; }
      const a = (r.data || []).find(function (x) { return x.status === 'active'; });
      if (!a) { showNotif('No estÃ¡s en una alianza activa.', 'err'); return; }
      const t = await sbClient.rpc('get_or_create_alliance_chat', { p_alliance_id: a.alliance_id });
      if (t.error) { showNotif('No se pudo abrir chat: ' + t.error.message, 'err'); return; }
      currentThreadId = t.data;
      currentThreadType = 'alliance';
      renderMessagesHeader('alliance', 'Chat de alianza');
      subscribeToThread(t.data);
      await renderThreads();
      await loadThreadMessages('alliance');
    }

    // ============================================================
    // ADMIN â€” rol leÃ­do desde Supabase profiles.role
    // ============================================================
    let currentUserRole = 'player';
    let _usernameChanged = false;

    async function loadUserRole() {
      if (!currentUser) return;
      try {
        // Usamos maybeSingle para no crashear si RLS bloquea o no existe fila
        const r = await sbClient
          .from('profiles')
          .select('role, username_changed')
          .eq('id', currentUser.id)
          .maybeSingle();
        if (r.data) {
          currentUserRole = r.data.role || 'player';
          _usernameChanged = r.data.username_changed || false;
        } else {
          // Columna role puede no existir en instancias antiguas â€” fallback a player
          currentUserRole = 'player';
        }
      } catch (e) {
        console.warn('loadUserRole error:', e);
        currentUserRole = 'player';
      }
      checkAdminButton();
    }

    // ADMIN - ACCESO EXCLUSIVO: sementalac@gmail.com
    // Triple verificaciÃ³n: email del objeto currentUser + email del JWT de Supabase + no nulo
    // Cualquier intento de falsificaciÃ³n desde consola fallarÃ¡ porque currentUser
    // viene directamente de sbClient.auth.getUser() y se sobreescribe en cada login.

    // ============================================================
    // v1.30: MOTD â€” Mensaje del dÃ­a del administrador
    // Guardado en tabla 'config' (clave 'motd') en Supabase
    // ============================================================
    async function saveMOTD() {
      if (!isAdmin()) return;
      var text = (document.getElementById('motdInput').value || '').trim().slice(0, 1000);
      var msg = document.getElementById('motdSaveMsg');
      msg.textContent = '';
      var r = await sbClient.from('config').upsert({ key: 'motd', value: text }, { onConflict: 'key' });
      if (r.error) {
        msg.style.color = 'var(--danger)';
        msg.textContent = 'Error: ' + r.error.message;
        return;
      }
      msg.style.color = 'var(--ok)';
      msg.textContent = 'âœ… Guardado';
      setTimeout(function () { msg.textContent = ''; }, 3000);
    }

    async function clearMOTD() {
      if (!isAdmin()) return;
      if (!confirm('Â¿Borrar el mensaje del dÃ­a?')) return;
      await sbClient.from('config').upsert({ key: 'motd', value: '' }, { onConflict: 'key' });
      document.getElementById('motdInput').value = '';
      var msg = document.getElementById('motdSaveMsg');
      msg.style.color = 'var(--ok)';
      msg.textContent = 'âœ… Borrado';
      setTimeout(function () { msg.textContent = ''; }, 2000);
    }

    // Admin cargado desde game-admin.js
    // ============================================================
    // PERFIL DE USUARIO â€” cambio de nombre (1 vez) + eliminar cuenta
    // ============================================================
    function openProfile() {
      if (!currentUser) return;
      var myUser = document.getElementById('ovUser') ? document.getElementById('ovUser').textContent : currentUser.email;
      document.getElementById('profUsername').textContent = myUser;
      document.getElementById('profEmail').textContent = currentUser.email;
      document.getElementById('profRole').textContent = currentUserRole;
      document.getElementById('profNewName').value = '';
      document.getElementById('profMsg').textContent = '';
      document.getElementById('profMsg').className = 'profile-msg';
      // Mostrar nombre de la aldea activa en el botÃ³n de borrar
      var pvn = document.getElementById('profVillageName');
      if (pvn && activeVillage) pvn.textContent = '("' + activeVillage.name + '")';      // Deshabilitar borrar aldea si solo tienen 1
      var dvBtn = document.querySelector('button[onclick="doDeleteVillage()"]');
      if (dvBtn) {
        var canDel = myVillages && myVillages.length > 1;
        dvBtn.disabled = !canDel;
        dvBtn.title = canDel ? 'Borra la aldea activa permanentemente' : 'No puedes borrar tu Ãºnica aldea';
      }
      // BotÃ³n cambiar nombre: solo si no lo ha cambiado aÃºn
      var changBtn = document.getElementById('profChangeNameBtn');
      if (changBtn) {
        changBtn.disabled = _usernameChanged;
        changBtn.title = _usernameChanged ? 'Ya has usado tu cambio de nombre' : 'Cambiar nombre (1 vez)';
      }
      document.getElementById('profileOverlay').classList.remove('hidden');
    }
    function closeProfile() { document.getElementById('profileOverlay').classList.add('hidden'); }

    async function doChangeUsername() {
      if (_usernameChanged) { showNotif('Ya usaste tu cambio de nombre.', 'err'); return; }
      var raw = (document.getElementById('profNewName').value || '').trim();
      var msg = document.getElementById('profMsg');
      msg.className = 'profile-msg';

      var shape = isUsernameShapeValid(raw);
      if (!shape.ok) { msg.textContent = shape.msg; msg.className = 'profile-msg err'; return; }
      var normalized = normUsername(raw);
      if (await isUsernameBanned(normalized)) { msg.textContent = 'Nombre no permitido.'; msg.className = 'profile-msg err'; return; }
      var av = await isUsernameAvailable(normalized);
      if (!av.ok) { msg.textContent = av.msg || 'No disponible.'; msg.className = 'profile-msg err'; return; }

      const r = await sbClient.from('profiles').update({
        username: raw,
        normalized_username: normalized,
        username_changed: true
      }).eq('id', currentUser.id);

      if (r.error) { msg.textContent = 'Error: ' + r.error.message; msg.className = 'profile-msg err'; return; }

      _usernameChanged = true;
      document.getElementById('profUsername').textContent = raw;
      document.getElementById('ovUser').textContent = raw;
      var tu = document.getElementById('topbarUsername');
      if (tu) tu.textContent = raw;
      document.getElementById('profChangeNameBtn').disabled = true;
      msg.textContent = 'âœ“ Nombre cambiado a ' + raw + '. No podrÃ¡s volver a cambiarlo.';
      msg.className = 'profile-msg ok';
      showNotif('Nombre actualizado: ' + raw, 'ok');
    }

    async function doDeleteVillage() {
      if (!activeVillage || !currentUser) return;
      // Solo se puede borrar si tienes mÃ¡s de 1 aldea
      if (myVillages.length <= 1) {
        showNotif('No puedes borrar tu Ãºnica aldea.', 'err');
        return;
      }
      var vilName = activeVillage.name;
      var input = (document.getElementById('profNewName').value || '').trim();
      var msg = document.getElementById('profMsg');
      // Pedir que escriban el nombre de la aldea exacto
      if (input !== vilName) {
        msg.textContent = 'Escribe exactamente el nombre de tu aldea activa ("' + vilName + '") para confirmar.';
        msg.className = 'profile-msg err';
        document.getElementById('profNewName').placeholder = 'Escribe: ' + vilName;
        return;
      }
      if (!confirm('Â¿Borrar la aldea "' + vilName + '" y todo su contenido?\nTropas, edificios y recursos se perderÃ¡n.\nEsta acciÃ³n no se puede deshacer.')) return;

      try {
        await sbClient.from('buildings').delete().eq('village_id', activeVillage.id);
        await sbClient.from('troops').delete().eq('village_id', activeVillage.id);
        await sbClient.from('creatures').delete().eq('village_id', activeVillage.id);
        await sbClient.from('villages').delete().eq('id', activeVillage.id);

        // Recargar localmente
        myVillages = myVillages.filter(function (v) { return v.id !== activeVillage.id; });
        activeVillage = myVillages[0];
        activeVillageId = activeVillage.id;
        populateVillageSel();
        closeProfile();
        showNotif('Aldea "' + vilName + '" eliminada.', 'ok');
        switchVillage(activeVillage.id);
      } catch (e) {
        showNotif('Error al borrar la aldea: ' + (e.message || e), 'err');
      }
    }

    async function doDeleteAccount() {
      var raw = (document.getElementById('profNewName').value || '').trim();
      var myName = document.getElementById('profUsername').textContent;
      var msg = document.getElementById('profMsg');
      if (raw !== myName) {
        msg.textContent = 'Escribe exactamente tu nombre de usuario para confirmar.';
        msg.className = 'profile-msg err';
        document.getElementById('profNewName').placeholder = 'Escribe: ' + myName;
        return;
      }
      if (!confirm('Â¿EstÃ¡s SEGURO de que quieres eliminar tu cuenta? Todos tus datos se perderÃ¡n.')) return;
      await sbClient.from('villages').delete().eq('user_id', currentUser.id);
      await sbClient.from('profiles').delete().eq('id', currentUser.id);
      // Cerrar sesiÃ³n (el usuario de auth.users queda; si quieres borrarlo del todo necesitas el trigger)
      await sbClient.auth.signOut();
      location.reload();
    }

    // Guardar inmediatamente antes de cerrar/recargar â€” protege misiones en curso
    window.addEventListener('beforeunload', function () {
      if (activeVillage && currentUser) {
        // Sync save (no await â€” beforeunload no permite async)
        try {
          var s = activeVillage.state;
          sbClient.from('villages').update({
            build_queue: s.build_queue,
            mission_queue: s.mission_queue || [],
            last_aldeano_at: s.last_aldeano_at || null
          }).eq('id', activeVillage.id);
        } catch (e) { }
      }
    });

    (async function () {
      var r = await sbClient.auth.getSession();
      if (r.data && r.data.session) {
        currentUser = r.data.session.user;
        document.getElementById('authScreen').style.display = 'none';
        document.getElementById('gameWrapper').classList.add('visible');
        await initGame();
      }
    })();

    // â”€â”€ Visibilitychange: guardar al ocultar, nada al volver â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // No hacemos query a Supabase al volver a la pestaÃ±a â€” los recursos se
    // calculan localmente con calcRes() desde last_updated + producciÃ³n.
    // Esto evita queries cada vez que el usuario enfoca la pestaÃ±a o devtools.
    document.addEventListener('visibilitychange', function () {
      if (document.hidden) {
        // Al ocultar: guardar estado actual (mejor esfuerzo)
        try { flushVillage(); } catch (e) { }
      }
      // Al volver: no hacemos nada â€” el tick sigue corriendo con cÃ¡lculo local
    });

    /* --- TRANSPORTE UI â€” helpers llamados desde HTML inline --- */
    function updateTransportUI() {
      let totalCap = 0;
      let totalTroops = 0;
      Object.keys(TROOP_TYPES).forEach(id => {
        const input = document.getElementById('mUnits_' + id);
        if (input) {
          const val = parseInt(input.value) || 0;
          totalCap += val * (TROOP_TYPES[id].capacity || 0);
          totalTroops += val;
        }
      });
      const capSpan = document.getElementById('displayCap');
      const costSpan = document.getElementById('displayCost');
      if (capSpan) capSpan.innerText = totalCap;
      if (costSpan) costSpan.innerText = totalTroops;
      validateTransportRes();
    }

    function validateTransportRes() {
      const cap = parseInt(document.getElementById('displayCap')?.innerText) || 0;
      const w = parseInt(document.getElementById('mWood')?.value) || 0;
      const s = parseInt(document.getElementById('mStone')?.value) || 0;
      const i = parseInt(document.getElementById('mIron')?.value) || 0;
      const btn = document.getElementById('btnSendMission');
      if (btn) {
        if ((w + s + i) > cap) {
          btn.innerText = "Â¡EXCESO CARGA!";
          btn.disabled = true;
        } else {
          btn.innerText = "Â¡Enviar!";
          btn.disabled = false;
        }
      }
    }
    // processMissions eliminado: resolveMissions (tick cada segundo) gestiona todos los tipos de misiÃ³n incluyendo transport.


  </script>


  <div id="bldModal" style="display:none"></div>

  <!-- PERFIL MODAL -->
  <div class="profile-overlay hidden" id="profileOverlay">
    <div class="profile-box">
      <div class="profile-title">ğŸ‘¤ MI PERFIL</div>
      <div class="profile-row"><span class="profile-label">Usuario</span><span class="profile-val"
          id="profUsername">â€”</span></div>
      <div class="profile-row"><span class="profile-label">Email</span><span class="profile-val" id="profEmail"
          style="color:var(--dim)">â€”</span></div>
      <div class="profile-row"><span class="profile-label">Rol</span><span class="profile-val"
          id="profRole">player</span></div>
      <hr class="profile-sep">
      <div class="profile-section">Cambiar nombre de usuario (solo 1 vez)</div>
      <div class="profile-row">
        <input class="profile-input" id="profNewName" placeholder="Nuevo nombre..." maxlength="15">
      </div>
      <div style="font-size:.62rem;color:var(--dim);margin-bottom:10px;">4-15 caracteres, letras/nÃºmeros/_/-. Solo
        puedes cambiarlo una vez.</div>
      <div class="profile-actions">
        <button class="profile-btn save" id="profChangeNameBtn" onclick="doChangeUsername()">âœ“ Cambiar nombre</button>
      </div>
      <hr class="profile-sep">
      <div class="profile-section" style="color:var(--danger);">âš  Zona de peligro</div>
      <div style="font-size:.62rem;color:var(--dim);margin-bottom:10px;">Escribe el nombre exacto de tu aldea activa o
        tu usuario segÃºn la acciÃ³n que vayas a realizar. Estas acciones son irreversibles.</div>
      <div class="profile-actions" style="flex-direction:column;gap:8px;">
        <button class="profile-btn danger" onclick="doDeleteVillage()" style="font-size:.75rem;">ğŸš Borrar aldea activa
          <span id="profVillageName" style="opacity:.7;font-size:.7rem;"></span></button>
        <button class="profile-btn danger" onclick="doDeleteAccount()">ğŸ—‘ Eliminar mi cuenta</button>
        <button class="profile-btn cancel" onclick="closeProfile()">Cerrar</button>
      </div>
      <div class="profile-msg" id="profMsg"></div>
    </div>
  </div>

  <!-- ADMIN RECURSOS PANEL (v0.19) -->
  <div class="admin-overlay hidden" id="adminOverlay">
    <div class="admin-box">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;">
        <div class="admin-title" style="margin:0;">âš™ PANEL DE CONTROL SUPREMO</div>
        <button class="admin-btn cancel" style="padding:6px 12px;font-size:0.85rem;" onclick="closeAdmin()">âœ•
          Cerrar</button>
      </div>

      <!-- Buscador de jugadores -->
      <div style="margin-bottom: 10px; font-size: 0.7rem; color: var(--dim);">BUSCAR JUGADOR (EMAIL O USERNAME)</div>
      <div class="admin-search-wrap">
        <input class="admin-input-search" id="adSearchInp" placeholder="Ej: jesus_33..."
          onkeypress="if(event.key==='Enter') searchAdminPlayer()">
        <button class="admin-btn search" onclick="searchAdminPlayer()">Buscar</button>
        <!-- v1.17: BotÃ³n Ver todos usuarios (solo para sementalac@gmail.com) -->
        <button class="admin-btn search" id="adminViewAllBtn" onclick="openAdminUsersPage()"
          style="background:rgba(0,212,255,.15);display:none;">ğŸ‘¥ Ver todos</button>
      </div>

      <div id="adSearchResults" class="admin-results-box">
        <div style="font-size: 0.8rem; margin-bottom: 8px; color: var(--accent);">Resultados:</div>
        <div id="adPlayersList"></div>
      </div>

      <div id="adVillagesBox" class="admin-results-box" style="border-color: var(--danger);">
        <div style="font-size: 0.8rem; margin-bottom: 8px; color: var(--danger);">Aldeas del jugador:</div>
        <div id="adVillagesList"></div>
      </div>

      <div id="adEditBox" style="display:none; border-top: 1px solid var(--border); padding-top: 20px;">
        <div style="font-size: 0.8rem; margin-bottom: 15px; color: var(--text); text-align:center;">
          Editando aldea: <b id="adEditingName" style="color:var(--accent2)">-</b>
        </div>

        <div class="admin-row"><span class="admin-label">ğŸŒ² Madera</span><input class="admin-input" id="adMadera"
            type="number"></div>
        <div class="admin-row"><span class="admin-label">â›°ï¸ Piedra</span><input class="admin-input" id="adPiedra"
            type="number"></div>
        <div class="admin-row"><span class="admin-label">âš™ï¸ Hierro</span><input class="admin-input" id="adHierro"
            type="number"></div>
        <div class="admin-row"><span class="admin-label">ğŸŒ¾ Prov.</span><input class="admin-input" id="adProv"
            type="number"></div>
        <div class="admin-row"><span class="admin-label">âœ¨ Esencia</span><input class="admin-input" id="adEsencia"
            type="number"></div>
        <div class="admin-row"><span class="admin-label">ğŸ‘¤ Aldeanos</span><input class="admin-input" id="adAldeanos"
            type="number"></div>
        <div class="admin-row"><span class="admin-label">â­ Experiencia</span><input class="admin-input"
            id="adExperience" type="number"></div>

        <div class="admin-actions" style="display:flex; gap:10px; margin-top:20px;">
          <button class="admin-btn apply" style="flex:1" onclick="adminApplyUniversal()">âœ“ Guardar Cambios</button>
          <button class="admin-btn cancel" onclick="closeAdmin()">Cerrar</button>
        </div>
      </div>

      <div id="adminMsg" style="font-size:.7rem; margin-top:15px; min-height:16px; text-align:center; color:var(--ok);">
      </div>

      <!-- â”€â”€ ReparaciÃ³n Global â”€â”€ -->
      <div style="border-top:1px solid var(--border);margin-top:20px;padding-top:16px;">
      <!-- â”€â”€ Aldeas Fantasma â”€â”€ -->
      <div style="border-top:1px solid var(--border);margin-top:20px;padding-top:16px;">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
          <div style="font-size:.7rem;color:var(--dim);letter-spacing:.1em;">ğŸšï¸ ALDEAS FANTASMA (TEST PvP)</div>
          <button class="admin-btn search" onclick="ghostToggleForm()" style="font-size:.68rem;padding:4px 10px;">+ Nueva</button>
        </div>
        <div id="ghostForm" style="display:none;background:var(--bg);border:1px solid var(--border);border-radius:4px;padding:12px;margin-bottom:10px;">
          <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px;">
            <div><div style="font-size:.62rem;color:var(--dim);margin-bottom:3px;">NOMBRE</div>
              <input id="ghostName" placeholder="Aldea Oscura" style="width:100%;background:var(--panel2);border:1px solid var(--border);color:var(--text);border-radius:3px;padding:5px 8px;font-family:VT323,monospace;font-size:.85rem;"></div>
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;">
              <div><div style="font-size:.62rem;color:var(--dim);margin-bottom:3px;">X</div>
                <input id="ghostX" type="number" value="100" style="width:100%;background:var(--panel2);border:1px solid var(--border);color:var(--text);border-radius:3px;padding:5px 8px;font-family:VT323,monospace;font-size:.85rem;"></div>
              <div><div style="font-size:.62rem;color:var(--dim);margin-bottom:3px;">Y</div>
                <input id="ghostY" type="number" value="100" style="width:100%;background:var(--panel2);border:1px solid var(--border);color:var(--text);border-radius:3px;padding:5px 8px;font-family:VT323,monospace;font-size:.85rem;"></div>
            </div>
          </div>
          <div style="font-size:.62rem;color:var(--dim);margin-bottom:6px;">TROPAS (deja en 0 las que no quieras)</div>
          <div id="ghostTroopInputs" style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px;margin-bottom:10px;"></div>
          <div style="font-size:.62rem;color:var(--dim);margin-bottom:6px;">NIVEL MURALLA</div>
          <input id="ghostWall" type="number" value="0" min="0" max="20" style="width:80px;background:var(--panel2);border:1px solid var(--border);color:var(--text);border-radius:3px;padding:4px 6px;font-family:VT323,monospace;font-size:.85rem;margin-bottom:10px;">
          <div style="display:flex;gap:8px;">
            <button class="admin-btn apply" style="flex:1;" onclick="ghostCreate()">âœ“ Crear Aldea Fantasma</button>
            <button class="admin-btn cancel" onclick="ghostToggleForm()">Cancelar</button>
          </div>
        </div>
        <div id="ghostList" style="font-size:.72rem;"></div>
      </div>

        <div style="font-size:.7rem;color:var(--dim);margin-bottom:8px;letter-spacing:.1em;">MANTENIMIENTO GLOBAL</div>
        <div style="font-size:.68rem;color:var(--dim);margin-bottom:10px;">
          Fase 1: escanea todas las aldeas y muestra un informe de problemas sin tocar nada.
          Fase 2: confirmas tÃº manualmente antes de que se aplique cualquier cambio.
        </div>
        <button id="repairBtn" class="admin-btn"
          style="width:100%;background:rgba(0,212,255,.1);border-color:var(--accent);color:var(--accent);"
          onclick="adminRepairAll()">
          ğŸ” Escanear Todo (Solo lectura)
        </button>
        <div id="repairLog"
          style="display:none;margin-top:12px;background:var(--bg);border:1px solid var(--border);border-radius:6px;padding:10px;font-size:.65rem;max-height:220px;overflow-y:auto;font-family:monospace;line-height:1.5;">
        </div>
        <div id="repairConfirmBox"
          style="display:none;margin-top:10px;border:1px solid var(--danger);border-radius:6px;padding:12px;background:rgba(255,61,90,.05);">
          <div style="font-size:.7rem;color:var(--danger);margin-bottom:8px;">
            âš ï¸ Se han detectado <b id="repairConfirmCount">0</b> aldea(s) con problemas.<br>
            Revisa el informe arriba antes de continuar.
          </div>
          <div style="display:flex;gap:8px;">
            <button id="repairConfirmBtn" class="admin-btn apply" style="flex:1;" onclick="adminRepairConfirm()">âœ“
              Aplicar Reparaciones</button>
            <button class="admin-btn cancel"
              onclick="document.getElementById('repairConfirmBox').style.display='none'">Cancelar</button>
          </div>
        </div>
      </div>

      <!-- v1.30: Mensaje del dÃ­a (MOTD) -->
      <div style="border-top:1px solid var(--border);padding-top:16px;margin-top:16px;">
        <div style="font-size:.7rem;color:var(--dim);letter-spacing:.08em;margin-bottom:8px;">ğŸ“¢ MENSAJE DEL DÃA
          (visible para todos al entrar)</div>
        <textarea id="motdInput" rows="3" placeholder="Escribe un mensaje para todos los jugadoresâ€¦"
          style="width:100%;background:rgba(255,255,255,.03);border:1px solid var(--border);border-radius:4px;color:var(--text);font-family:VT323,monospace;font-size:.85rem;padding:8px;resize:vertical;box-sizing:border-box;"></textarea>
        <div style="display:flex;gap:8px;margin-top:8px;align-items:center;">
          <button class="admin-btn search" onclick="saveMOTD()" style="background:rgba(0,212,255,.15);">ğŸ’¾ Guardar
            mensaje</button>
          <button class="admin-btn cancel" onclick="clearMOTD()" style="font-size:.7rem;">ğŸ—‘ Borrar mensaje</button>
          <span id="motdSaveMsg" style="font-size:.7rem;color:var(--ok);"></span>
        </div>
      </div>
    </div>
  </div>

  <!-- v1.30: Modal MOTD para jugadores -->
  <div id="motdModal"
    style="display:none;position:fixed;inset:0;z-index:99999;background:rgba(0,0,0,.75);display:none;align-items:center;justify-content:center;">
    <div
      style="background:var(--panel);border:1px solid var(--accent);border-radius:10px;padding:24px;max-width:480px;width:90%;font-family:VT323,monospace;box-shadow:0 0 40px rgba(0,212,255,.2);">
      <div style="display:flex;align-items:center;gap:10px;margin-bottom:16px;">
        <span style="font-size:1.6rem;">ğŸ“¢</span>
        <div style="font-size:1.1rem;color:var(--accent);letter-spacing:.06em;">MENSAJE DEL ADMINISTRADOR</div>
      </div>
      <div id="motdModalText"
        style="font-size:.9rem;color:var(--text);line-height:1.6;white-space:pre-wrap;padding:12px;background:rgba(0,212,255,.05);border:1px solid rgba(0,212,255,.2);border-radius:6px;margin-bottom:16px;">
      </div>
      <button onclick="closeMOTD()"
        style="width:100%;padding:10px;background:rgba(0,212,255,.15);border:1px solid var(--accent);border-radius:4px;color:var(--accent);font-family:VT323,monospace;font-size:1rem;cursor:pointer;letter-spacing:.06em;">âœ“
        ENTENDIDO</button>
    </div>
  </div>

  <div class="version-footer" id="versionFooter">EPIC WARRIORS v1.38</div>
</body>

</html>