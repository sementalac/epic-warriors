<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Epic Warriors Online v0.87</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323:wght@400&family=MedievalSharp&display=swap"
    rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <!-- Datos estáticos del juego (NPC_CASTLES) — debe cargarse antes del script principal -->
  <script src="game-data.js"></script>
  <style>
    :root {
      --madera: #d4923a;
      --piedra: #a0a8b0;
      --hierro: #c0c8d8;
      --prov: #6fcf7a;
      --esencia: #c060ff;
      --metal: var(--hierro);
      --crystal: var(--esencia);
      --deut: var(--prov);
      --energy: var(--accent2);
      --aldeanos: #ffdd60;
      --bg: #0a0805;
      --panel: #1a1208;
      --panel2: #221a0e;
      --border: #4a3520;
      --accent: #f0c040;
      --accent2: #60d060;
      --text: #e8d5a0;
      --dim: #7a6040;
      --danger: #e04040;
      --ok: #60d060;
      --gold: #f0c040;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: var(--bg);
      color: var(--text);
      font-family: 'VT323', monospace;
      min-height: 100vh;
      overflow-x: hidden;
    }

    .stars {
      position: fixed;
      inset: 0;
      z-index: 0;
      pointer-events: none;
    }

    .star {
      position: absolute;
      background: white;
      border-radius: 50%;
      animation: twinkle linear infinite;
    }

    @keyframes twinkle {

      0%,
      100% {
        opacity: .2
      }

      50% {
        opacity: 1
      }
    }

    /* AUTH */
    .auth-screen {
      position: fixed;
      inset: 0;
      z-index: 200;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(5, 10, 20, .97);
    }

    .auth-box {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 40px;
      width: 380px;
      z-index: 1;
      box-shadow: 0 0 60px rgba(0, 212, 255, .08);
    }

    .auth-logo {
      font-family: 'Press Start 2P', cursive;
      font-size: 1.3rem;
      font-weight: 900;
      color: var(--accent);
      text-shadow: 0 0 20px rgba(0, 212, 255, .5);
      text-align: center;
      margin-bottom: 6px;
      letter-spacing: .2em;
    }

    .auth-tagline {
      text-align: center;
      font-size: .7rem;
      color: var(--dim);
      margin-bottom: 28px;
      letter-spacing: .1em;
    }

    .auth-tabs {
      display: flex;
      border: 1px solid var(--border);
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 20px;
    }

    .auth-tab {
      flex: 1;
      padding: 10px;
      text-align: center;
      cursor: pointer;
      font-size: .78rem;
      color: var(--dim);
      transition: all .2s;
      background: transparent;
      border: none;
      font-family: 'VT323', monospace;
    }

    .auth-tab.active {
      background: rgba(0, 212, 255, .1);
      color: var(--accent);
    }

    .auth-field {
      margin-bottom: 14px;
    }

    .auth-label {
      font-size: .65rem;
      color: var(--dim);
      letter-spacing: .1em;
      text-transform: uppercase;
      margin-bottom: 5px;
      display: block;
    }

    .auth-input {
      width: 100%;
      background: rgba(255, 255, 255, .03);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 10px 14px;
      color: var(--text);
      font-family: 'VT323', monospace;
      font-size: .85rem;
      outline: none;
      transition: border-color .2s;
    }

    .auth-input:focus {
      border-color: var(--accent);
    }

    .auth-btn {
      width: 100%;
      padding: 12px;
      background: rgba(0, 212, 255, .1);
      border: 1px solid var(--accent);
      border-radius: 4px;
      color: var(--accent);
      font-family: 'VT323', monospace;
      font-size: .85rem;
      letter-spacing: .1em;
      text-transform: uppercase;
      cursor: pointer;
      transition: all .2s;
      margin-top: 6px;
    }

    .auth-btn:hover {
      background: rgba(0, 212, 255, .2);
    }

    .auth-btn:disabled {
      opacity: .4;
      cursor: not-allowed;
    }

    .auth-msg {
      font-size: .72rem;
      margin-top: 10px;
      text-align: center;
      min-height: 18px;
    }

    .auth-msg.err {
      color: var(--danger);
    }

    .auth-msg.ok {
      color: var(--ok);
    }

    /* GAME */
    .game-wrapper {
      position: relative;
      z-index: 1;
      display: none;
    }
    .game-wrapper.visible {
      display: block !important;
    }

    .topbar {
      background: linear-gradient(180deg, #0d1f3c 0%, #050a14 100%);
      border-bottom: 1px solid var(--border);
      padding: 0 20px;
      display: flex;
      align-items: center;
      height: 62px;
      position: sticky;
      top: 0;
      z-index: 100;
      box-shadow: 0 4px 24px rgba(0, 212, 255, .08);
      gap: 8px;
    }

    .logo {
      font-family: 'Press Start 2P', cursive;
      font-weight: 900;
      font-size: .95rem;
      letter-spacing: .2em;
      color: var(--accent);
      text-shadow: 0 0 20px rgba(0, 212, 255, .5);
      margin-right: 16px;
      white-space: nowrap;
    }

    .res-bar {
      display: flex;
      gap: 4px;
      flex: 1;
      overflow-x: auto;
      scrollbar-width: thin;
      scrollbar-color: var(--border) transparent;
      padding-bottom: 2px;
    }

    .res-chip {
      display: flex;
      flex-direction: column;
      gap: 4px;
      background: rgba(255, 255, 255, .03);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 6px 10px;
      white-space: nowrap;
      min-width: 90px;
      flex-shrink: 0;
    }

    .res-chip-top {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .res-icon {
      font-size: 1.4rem;
    }

    .res-info {
      display: flex;
      flex-direction: column;
    }

    .res-name {
      font-size: .66rem;
      color: var(--dim);
      letter-spacing: .1em;
      text-transform: uppercase;
    }

    .res-val {
      font-size: 1.1rem;
      font-weight: bold;
      font-family: 'MedievalSharp', 'VT323', monospace;
      letter-spacing: 0.05em;
    }

    .res-rate {
      font-size: .95rem;
      color: var(--dim);
      font-family: 'MedievalSharp', 'VT323', monospace;
      letter-spacing: 0.05em;
    }

    .res-chip.ma .res-val {
      color: var(--madera);
    }

    .res-chip.pi .res-val {
      color: var(--piedra);
    }

    .res-chip.hi .res-val {
      color: var(--hierro);
    }

    .res-chip.pr .res-val {
      color: var(--prov);
    }

    .res-chip.es .res-val {
      color: var(--esencia);
    }

    .cap-bar-wrap {
      width: 100%;
      height: 3px;
      background: rgba(255, 255, 255, .08);
      border-radius: 2px;
      margin-top: 3px;
    }

    .cap-bar {
      height: 100%;
      border-radius: 2px;
      transition: width .5s;
    }

    .cap-bar.ok {
      background: var(--ok);
    }

    .cap-bar.warn {
      background: var(--gold);
    }

    .cap-bar.full {
      background: var(--danger);
    }

    .res-cap {
      font-size: .5rem;
      color: var(--dim);
    }

    .topbar-right {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-left: auto;
    }

    .save-dot {
      width: 7px;
      height: 7px;
      border-radius: 50%;
      background: var(--dim);
      transition: all .3s;
    }

    .save-dot.saving {
      background: var(--gold);
      animation: pdot 1s ease-in-out infinite;
    }

    .save-dot.saved {
      background: var(--ok);
    }

    @keyframes pdot {

      0%,
      100% {
        opacity: .4
      }

      50% {
        opacity: 1
      }
    }

    .save-txt {
      font-size: .6rem;
      color: var(--dim);
    }

    .village-sel {
      background: rgba(255, 107, 53, .1);
      border: 1px solid rgba(255, 107, 53, .3);
      border-radius: 4px;
      padding: 5px 10px;
      font-size: .72rem;
      color: var(--accent2);
      font-family: 'VT323', monospace;
      cursor: pointer;
      outline: none;
      color: var(--accent2);
    }

    #alertsBtn {
      position: relative;
      background: rgba(255,221,96,.08);
      border: 1px solid rgba(255,221,96,.25);
      border-radius: 4px;
      color: var(--gold);
      padding: 5px 10px;
      font-size: .68rem;
      cursor: pointer;
      font-family: 'VT323', monospace;
      letter-spacing: .06em;
      transition: all .2s;
    }
    #alertsBtn.has-alerts {
      background: rgba(255,61,90,.15);
      border-color: rgba(255,61,90,.6);
      color: var(--danger);
      animation: alertPulse 1.5s ease-in-out infinite;
    }
    @keyframes alertPulse {
      0%, 100% { box-shadow: 0 0 0 0 rgba(255,61,90,.4); }
      50% { box-shadow: 0 0 0 5px rgba(255,61,90,0); }
    }
    #alertsBadge {
      position: absolute;
      top: -6px; right: -6px;
      background: var(--danger);
      color: #fff;
      font-size: .55rem;
      font-family: sans-serif;
      width: 16px; height: 16px;
      border-radius: 50%;
      display: none;
      align-items: center;
      justify-content: center;
      font-weight: bold;
    }
    .alerts-modal {
      position: fixed; inset: 0; z-index: 9999;
      background: rgba(0,0,0,.7);
      display: flex; align-items: flex-start; justify-content: flex-end;
      padding: 70px 16px 0;
    }
    .alerts-panel {
      background: var(--panel);
      border: 1px solid rgba(255,61,90,.4);
      border-radius: 8px;
      width: 340px;
      max-height: 70vh;
      overflow-y: auto;
      box-shadow: 0 8px 32px rgba(0,0,0,.6);
    }
    .alerts-header {
      padding: 12px 16px;
      border-bottom: 1px solid rgba(255,61,90,.2);
      display: flex; align-items: center; justify-content: space-between;
      position: sticky; top: 0; background: var(--panel);
    }
    .alerts-header h3 { margin: 0; font-size: .9rem; color: var(--danger); }
    .alert-item {
      padding: 10px 16px;
      border-bottom: 1px solid rgba(255,255,255,.05);
      font-size: .75rem;
    }
    .alert-item:last-child { border-bottom: none; }
    .alert-item .alert-title { font-weight: bold; color: var(--danger); margin-bottom: 3px; }
    .alert-item .alert-sub { color: var(--dim); }
    .alert-item .alert-time { color: var(--gold); font-size: .68rem; margin-top: 3px; }
    .alerts-empty { padding: 24px 16px; text-align: center; color: var(--dim); font-size: .8rem; }
    .logout-btn {
      background: rgba(255, 61, 90, .08);
      border: 1px solid rgba(255, 61, 90, .25);
      border-radius: 4px;
      color: rgba(255, 61, 90, .7);
      padding: 5px 10px;
      font-size: .68rem;
      cursor: pointer;
      font-family: 'VT323', monospace;
      letter-spacing: .08em;
      transition: all .2s;
    }

    .logout-btn:hover {
      border-color: var(--danger);
      color: var(--danger);
    }

    /* LAYOUT */
    .main-layout {
      display: grid;
      grid-template-columns: 190px 1fr;
      min-height: calc(100vh - 52px);
    }

    .sidebar {
      background: var(--panel);
      border-right: 1px solid var(--border);
      padding: 12px 0;
    }

    .nav-section {
      margin-bottom: 6px;
    }

    .nav-label {
      font-size: .56rem;
      letter-spacing: .15em;
      color: var(--dim);
      padding: 8px 14px 4px;
      text-transform: uppercase;
    }

    .nav-item {
      display: flex;
      align-items: center;
      gap: 9px;
      padding: 9px 14px;
      cursor: pointer;
      transition: all .2s;
      border-left: 3px solid transparent;
      font-size: .78rem;
    }

    .nav-item:hover {
      background: rgba(0, 212, 255, .05);
      color: var(--accent);
      border-left-color: var(--accent);
    }

    .nav-item.active {
      background: rgba(0, 212, 255, .08);
      color: var(--accent);
      border-left-color: var(--accent);
    }

    .nav-icon {
      font-size: .95rem;
      width: 18px;
      text-align: center;
    }

    .content {
      padding: 20px;
      overflow-y: auto;
    }

    .page {
      display: none;
    }

    .page.active {
      display: block;
    }

    .page-title {
      font-family: 'Press Start 2P', cursive;
      font-size: 1rem;
      font-weight: 700;
      color: var(--accent);
      letter-spacing: .1em;
      margin-bottom: 4px;
    }

    .page-sub {
      font-size: .7rem;
      color: var(--dim);
      margin-bottom: 20px;
    }

    /* QUEUE */
    .queue-panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 14px;
      margin-bottom: 20px;
    }

    .queue-title {
      font-family: 'Press Start 2P', cursive;
      font-size: .68rem;
      color: var(--accent);
      letter-spacing: .1em;
      margin-bottom: 10px;
    }

    .queue-empty {
      font-size: .7rem;
      color: var(--dim);
    }

    .queue-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 9px;
      background: rgba(79, 255, 176, .04);
      border: 1px solid rgba(79, 255, 176, .15);
      border-radius: 4px;
      margin-bottom: 6px;
    }

    .queue-icon {
      font-size: 1.1rem;
    }

    .queue-info {
      flex: 1;
    }

    .queue-name {
      font-size: .76rem;
      margin-bottom: 3px;
    }

    .queue-time {
      font-size: .66rem;
      color: var(--ok);
    }

    .qbar {
      width: 100%;
      height: 3px;
      background: rgba(255, 255, 255, .05);
      border-radius: 2px;
      margin-top: 5px;
    }

    .qbar-fill {
      height: 100%;
      background: var(--ok);
      border-radius: 2px;
      transition: width .5s;
    }

    /* BUILDINGS */
    .bld-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(265px, 1fr));
      gap: 14px;
    }

    .bld-card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 6px;
      overflow: hidden;
      transition: all .3s;
    }

    .bld-card:hover {
      border-color: rgba(0, 212, 255, .4);
      box-shadow: 0 0 16px rgba(0, 212, 255, .07);
      transform: translateY(-2px);
    }

    .bld-head {
      background: linear-gradient(135deg, #0d1f3c, #091525);
      padding: 12px 14px;
      display: flex;
      align-items: center;
      gap: 10px;
      border-bottom: 1px solid var(--border);
    }

    .bld-ico {
      font-size: 1.6rem;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 212, 255, .08);
      border-radius: 6px;
      border: 1px solid rgba(0, 212, 255, .15);
    }

    .bld-name {
      font-family: 'Press Start 2P', cursive;
      font-size: .68rem;
      font-weight: 700;
      letter-spacing: .05em;
      margin-bottom: 2px;
    }

    .bld-lvl {
      font-size: .65rem;
      color: var(--dim);
    }

    .lvl-n {
      color: var(--gold);
      font-weight: bold;
    }

    .bld-body {
      padding: 12px 14px;
    }

    .bld-desc {
      font-size: .68rem;
      color: var(--dim);
      line-height: 1.5;
      margin-bottom: 9px;
    }

    .prod-row {
      display: flex;
      gap: 5px;
      margin-bottom: 9px;
      flex-wrap: wrap;
    }

    .pbadge {
      font-size: .6rem;
      padding: 2px 6px;
      border-radius: 3px;
      border: 1px solid;
      display: flex;
      align-items: center;
      gap: 3px;
    }

    .pbadge.m {
      color: var(--metal);
      border-color: rgba(160, 180, 200, .3);
      background: rgba(160, 180, 200, .05);
    }

    .pbadge.c {
      color: var(--crystal);
      border-color: rgba(126, 232, 250, .3);
      background: rgba(126, 232, 250, .05);
    }

    .pbadge.d {
      color: var(--deut);
      border-color: rgba(247, 201, 72, .3);
      background: rgba(247, 201, 72, .05);
    }

    .pbadge.e {
      color: var(--energy);
      border-color: rgba(79, 255, 176, .3);
      background: rgba(79, 255, 176, .05);
    }

    .cost-row {
      display: flex;
      gap: 7px;
      margin-bottom: 9px;
      flex-wrap: wrap;
    }

    .cost-i {
      font-size: .65rem;
      display: flex;
      align-items: center;
      gap: 3px;
    }

    .cost-i.ok {
      color: var(--text);
    }

    .cost-i.no {
      color: var(--danger);
    }

    .pbar-wrap {
      height: 3px;
      background: rgba(255, 255, 255, .05);
      border-radius: 2px;
      margin-bottom: 9px;
      overflow: hidden;
    }

    .pbar-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--ok));
      border-radius: 2px;
      transition: width .5s;
    }

    .bld-btn {
      width: 100%;
      padding: 8px;
      border: 1px solid;
      border-radius: 4px;
      cursor: pointer;
      font-family: 'VT323', monospace;
      font-size: .72rem;
      letter-spacing: .08em;
      text-transform: uppercase;
      transition: all .2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
    }

    .bld-btn.avail {
      background: rgba(0, 212, 255, .08);
      border-color: var(--accent);
      color: var(--accent);
    }

    .bld-btn.avail:hover {
      background: rgba(0, 212, 255, .2);
    }

    .bld-btn.busy {
      background: rgba(79, 255, 176, .05);
      border-color: var(--ok);
      color: var(--ok);
      cursor: not-allowed;
      animation: pb 1.5s ease-in-out infinite;
    }

    .bld-btn.insuf {
      background: rgba(255, 61, 90, .05);
      border-color: rgba(255, 61, 90, .3);
      color: rgba(255, 61, 90, .5);
      cursor: not-allowed;
    }

    @keyframes pb {

      0%,
      100% {
        box-shadow: 0 0 0 rgba(79, 255, 176, .2)
      }

      50% {
        box-shadow: 0 0 10px rgba(79, 255, 176, .4)
      }
    }

    /* OVERVIEW */
    .ov-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 14px;
      margin-bottom: 20px;
    }

    .stat-card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 18px;
      text-align: center;
      transition: all .3s;
    }

    .stat-card:hover {
      border-color: rgba(0, 212, 255, .3);
    }

    .stat-ico {
      font-size: 1.8rem;
      margin-bottom: 6px;
    }

    .stat-val {
      font-family: 'Press Start 2P', cursive;
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--accent);
      margin-bottom: 3px;
      word-break: break-all;
    }

    .stat-lbl {
      font-size: .65rem;
      color: var(--dim);
      letter-spacing: .1em;
      text-transform: uppercase;
    }

    .ov-planet {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 18px;
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
    }

    .planet-vis {
      width: 72px;
      height: 72px;
      border-radius: 50%;
      background: radial-gradient(circle at 35% 35%, #2a6496, #0d2d4a, #050a14);
      box-shadow: 0 0 28px rgba(0, 100, 180, .4), inset -8px -8px 18px rgba(0, 0, 0, .5);
      flex-shrink: 0;
    }

    .planet-name-big {
      font-family: 'Press Start 2P', cursive;
      font-size: .9rem;
      color: var(--accent2);
      margin-bottom: 5px;
    }

    .planet-coords {
      font-size: .7rem;
      color: var(--dim);
      margin-bottom: 8px;
    }

    .planet-stats {
      display: flex;
      gap: 14px;
      flex-wrap: wrap;
    }

    .pstat {
      font-size: .68rem;
    }

    .pstat span {
      color: var(--accent);
    }

    /* MAP */
    .map-container {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 16px;
    }

    .map-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
    }

    .map-legend {
      display: flex;
      gap: 14px;
      font-size: .65rem;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 2px;
    }

    .map-coords-display {
      font-size: .65rem;
      color: var(--dim);
      margin-bottom: 10px;
      text-align: center;
    }

    .map-grid-wrap {
      overflow: auto;
      max-height: 540px;
    }

    .map-grid {
      display: grid;
      gap: 2px;
      width: fit-content;
    }

    .map-cell {
      width: 28px;
      height: 28px;
      border-radius: 3px;
      cursor: pointer;
      transition: all .15s;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: .7rem;
      border: 1px solid transparent;
    }

    .map-cell.empty {
      background: rgba(255, 255, 255, .02);
      border-color: rgba(255, 255, 255, .04);
    }

    .map-cell.empty:hover {
      background: rgba(0, 212, 255, .06);
      border-color: rgba(0, 212, 255, .15);
    }

    .map-cell.own {
      background: rgba(0, 212, 255, .18);
      border-color: rgba(0, 212, 255, .5);
    }

    .map-cell.own:hover {
      background: rgba(0, 212, 255, .28);
      box-shadow: 0 0 8px rgba(0, 212, 255, .3);
    }

    .map-cell.enemy {
      background: rgba(255, 61, 90, .18);
      border-color: rgba(255, 61, 90, .5);
    }

    .map-cell.enemy:hover {
      background: rgba(255, 61, 90, .28);
      box-shadow: 0 0 8px rgba(255, 61, 90, .3);
    }

    .map-cell.ally {
      background: rgba(96, 208, 96, .18);
      border-color: rgba(96, 208, 96, .5);
    }

    .map-cell.ally:hover {
      background: rgba(96, 208, 96, .28);
      box-shadow: 0 0 8px rgba(96, 208, 96, .3);
    }

    .map-cell.npc {
      background: rgba(255, 230, 0, .2);
      border-color: rgba(255, 230, 0, .5);
    }

    .map-cell.npc:hover {
      background: rgba(255, 230, 0, .35);
      box-shadow: 0 0 10px rgba(255, 230, 0, .4);
    }

    .map-cell.center-marker {
      box-shadow: 0 0 0 2px var(--accent);
    }

    .map-cell.out-of-bounds {
      background: rgba(0, 0, 0, .3);
      cursor: default;
      border-color: transparent;
    }

    .map-panel {
      margin-top: 14px;
      background: rgba(0, 0, 0, .3);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 14px;
      display: none;
    }

    .map-panel.show {
      display: block;
    }

    .map-panel-title {
      font-family: 'Press Start 2P', cursive;
      font-size: .75rem;
      color: var(--accent);
      margin-bottom: 6px;
    }

    .map-panel-sub {
      font-size: .68rem;
      color: var(--dim);
      margin-bottom: 10px;
    }

    .map-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .map-action-btn {
      padding: 7px 14px;
      border-radius: 4px;
      border: 1px solid;
      font-family: 'VT323', monospace;
      font-size: .7rem;
      cursor: pointer;
      transition: all .2s;
      letter-spacing: .06em;
    }

    .map-action-btn.move {
      background: rgba(79, 255, 176, .08);
      border-color: var(--ok);
      color: var(--ok);
    }

    .map-action-btn.move:hover {
      background: rgba(79, 255, 176, .2);
    }

    .map-action-btn.atk {
      background: rgba(255, 61, 90, .08);
      border-color: var(--danger);
      color: var(--danger);
    }

    .map-action-btn.atk:hover {
      background: rgba(255, 61, 90, .2);
    }

    .map-action-btn.spy {
      background: rgba(247, 201, 72, .08);
      border-color: var(--gold);
      color: var(--gold);
    }

    .map-action-btn.spy:hover {
      background: rgba(247, 201, 72, .2);
    }

    /* NOTIF */
    .notif-wrap {
      position: fixed;
      top: 65px;
      right: 18px;
      z-index: 999;
      display: flex;
      flex-direction: column;
      gap: 7px;
      pointer-events: none;
    }

    .notif {
      background: var(--panel2);
      border: 1px solid var(--accent);
      border-radius: 4px;
      padding: 9px 14px;
      font-size: .73rem;
      color: var(--accent);
      box-shadow: 0 0 14px rgba(0, 212, 255, .2);
      animation: nin .3s ease, nout .4s ease 2.6s forwards;
      max-width: 280px;
    }

    .notif.ok {
      border-color: var(--ok);
      color: var(--ok);
    }

    .notif.err {
      border-color: var(--danger);
      color: var(--danger);
    }

    @keyframes nin {
      from {
        opacity: 0;
        transform: translateX(16px)
      }

      to {
        opacity: 1;
        transform: translateX(0)
      }
    }

    @keyframes nout {
      from {
        opacity: 1
      }

      to {
        opacity: 0;
        transform: translateX(16px)
      }
    }

    .coming-soon {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 40vh;
      gap: 14px;
      color: var(--dim);
    }

    .cs-icon {
      font-size: 2.8rem;
    }

    .cs-title {
      font-family: 'Press Start 2P', cursive;
      font-size: .95rem;
      letter-spacing: .1em;
    }

    /* BUILDING DETAIL MODAL */
    .bld-modal-overlay {
      position: fixed;
      inset: 0;
      z-index: 500;
      background: rgba(5, 10, 20, .88);
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(4px);
    }

    .bld-modal {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      width: min(680px, 95vw);
      max-height: 88vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 0 60px rgba(0, 212, 255, .15);
      animation: scalein .18s ease;
    }

    @keyframes scalein {
      from {
        transform: scale(.95);
        opacity: 0
      }

      to {
        transform: scale(1);
        opacity: 1
      }
    }

    .bld-modal-head {
      padding: 18px 20px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 14px;
      flex-shrink: 0;
    }

    .bld-modal-icon {
      font-size: 2rem;
      width: 52px;
      height: 62px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 212, 255, .08);
      border: 1px solid rgba(0, 212, 255, .2);
      border-radius: 8px;
    }

    .bld-modal-title {
      font-family: 'Press Start 2P', cursive;
      font-size: .9rem;
      font-weight: 700;
      color: var(--accent);
      letter-spacing: .08em;
      margin-bottom: 3px;
    }

    .bld-modal-sub {
      font-size: .68rem;
      color: var(--dim);
    }

    .bld-modal-close {
      margin-left: auto;
      background: rgba(255, 61, 90, .08);
      border: 1px solid rgba(255, 61, 90, .25);
      border-radius: 4px;
      color: rgba(255, 61, 90, .7);
      padding: 6px 12px;
      font-size: .72rem;
      cursor: pointer;
      font-family: 'VT323', monospace;
      transition: all .2s;
      white-space: nowrap;
    }

    .bld-modal-close:hover {
      background: rgba(255, 61, 90, .2);
      color: var(--danger);
    }

    .bld-modal-body {
      overflow-y: auto;
      padding: 16px 20px;
    }

    .bld-modal-note {
      font-size: .65rem;
      color: var(--dim);
      margin-bottom: 12px;
      padding: 8px 12px;
      background: rgba(0, 212, 255, .04);
      border: 1px solid rgba(0, 212, 255, .1);
      border-radius: 4px;
    }

    .bld-lvl-table {
      width: 100%;
      border-collapse: collapse;
      font-size: .72rem;
    }

    .bld-lvl-table th {
      padding: 8px 10px;
      text-align: left;
      font-size: .58rem;
      letter-spacing: .1em;
      text-transform: uppercase;
      color: var(--dim);
      border-bottom: 1px solid var(--border);
      background: rgba(0, 0, 0, .25);
      font-family: 'Press Start 2P', cursive;
    }

    .bld-lvl-table td {
      padding: 8px 10px;
      border-bottom: 1px solid rgba(255, 255, 255, .03);
      vertical-align: top;
    }

    .bld-lvl-table tr:hover td {
      background: rgba(0, 212, 255, .03);
    }

    .bld-lvl-table tr.row-current td {
      background: rgba(247, 201, 72, .06);
      border-left: 3px solid var(--gold);
    }

    .bld-lvl-table tr.row-next td {
      background: rgba(0, 212, 255, .06);
      border-left: 3px solid var(--accent);
    }

    .lvl-badge {
      font-family: 'Press Start 2P', cursive;
      font-weight: 700;
      font-size: .78rem;
      color: var(--gold);
    }

    .lvl-badge.accent {
      color: var(--accent);
    }

    .lvl-tag {
      font-size: .56rem;
      padding: 1px 5px;
      border-radius: 3px;
      vertical-align: middle;
      margin-left: 4px;
    }

    .lvl-tag.cur {
      background: rgba(247, 201, 72, .15);
      color: var(--gold);
      border: 1px solid rgba(247, 201, 72, .3);
    }

    .lvl-tag.nxt {
      background: rgba(0, 212, 255, .15);
      color: var(--accent);
      border: 1px solid rgba(0, 212, 255, .3);
    }

    .cost-lines,
    .prod-lines {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .cl {
      font-size: .65rem;
      display: flex;
      align-items: center;
      gap: 3px;
    }

    .cl.can {
      color: var(--text);
    }

    .cl.cant {
      color: var(--danger);
    }

    .pl {
      font-size: .65rem;
    }

    .pl.m {
      color: var(--metal);
    }

    .pl.c {
      color: var(--crystal);
    }

    .pl.d {
      color: var(--deut);
    }

    .pl.e {
      color: var(--energy);
    }

    .pl.none {
      color: var(--dim);
    }

    .ttime {
      font-size: .68rem;
      color: var(--text);
      white-space: nowrap;
    }

    .bld-modal-footer {
      padding: 14px 20px;
      border-top: 1px solid var(--border);
      flex-shrink: 0;
    }

    .bld-footer-btn {
      width: 100%;
      padding: 11px;
      border: 1px solid;
      border-radius: 4px;
      cursor: pointer;
      font-family: 'VT323', monospace;
      font-size: .78rem;
      letter-spacing: .1em;
      text-transform: uppercase;
      transition: all .2s;
    }

    .bld-footer-btn.avail {
      background: rgba(0, 212, 255, .1);
      border-color: var(--accent);
      color: var(--accent);
    }

    .bld-footer-btn.avail:hover {
      background: rgba(0, 212, 255, .25);
      box-shadow: 0 0 14px rgba(0, 212, 255, .2);
    }

    .bld-footer-btn.busy {
      background: rgba(79, 255, 176, .05);
      border-color: var(--ok);
      color: var(--ok);
      cursor: not-allowed;
    }

    .bld-footer-btn.insuf {
      background: rgba(255, 61, 90, .05);
      border-color: rgba(255, 61, 90, .3);
      color: rgba(255, 61, 90, .4);
      cursor: not-allowed;
    }

    .bld-footer-btn.maxlvl {
      background: rgba(247, 201, 72, .05);
      border-color: rgba(247, 201, 72, .3);
      color: var(--gold);
      cursor: not-allowed;
    }

    .detail-badge {
      margin-left: auto;
      font-size: .58rem;
      color: var(--dim);
      border: 1px solid rgba(0, 212, 255, .2);
      padding: 2px 8px;
      border-radius: 10px;
      pointer-events: none;
    }

    ::-webkit-scrollbar {
      width: 5px;
      height: 5px;
    }

    ::-webkit-scrollbar-track {
      background: var(--bg);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 3px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--accent);
    }

    /* BUILDING DETAIL MODAL */
    .modal-overlay {
      position: fixed;
      inset: 0;
      z-index: 500;
      background: rgba(3, 8, 18, .88);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
      backdrop-filter: blur(3px);
    }

    .modal-overlay.hidden {
      display: none;
    }

    .modal-box {
      background: var(--panel);
      border: 1px solid var(--accent);
      border-radius: 8px;
      width: 100%;
      max-width: 780px;
      max-height: 88vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 0 60px rgba(0, 212, 255, .12);
    }

    .modal-head {
      display: flex;
      align-items: center;
      gap: 14px;
      padding: 18px 20px;
      border-bottom: 1px solid var(--border);
    }

    .modal-ico {
      font-size: 2rem;
      width: 52px;
      height: 62px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 212, 255, .08);
      border-radius: 8px;
      border: 1px solid rgba(0, 212, 255, .18);
      flex-shrink: 0;
    }

    .modal-title {
      font-family: 'Press Start 2P', cursive;
      font-size: 1rem;
      font-weight: 700;
      color: var(--accent);
      letter-spacing: .08em;
    }

    .modal-subtitle {
      font-size: .68rem;
      color: var(--dim);
      margin-top: 3px;
    }

    .modal-close {
      margin-left: auto;
      background: rgba(255, 61, 90, .08);
      border: 1px solid rgba(255, 61, 90, .3);
      border-radius: 4px;
      color: var(--danger);
      padding: 7px 14px;
      cursor: pointer;
      font-family: 'VT323', monospace;
      font-size: .72rem;
      transition: all .2s;
      flex-shrink: 0;
    }

    .modal-close:hover {
      background: rgba(255, 61, 90, .2);
    }

    .modal-body {
      overflow-y: auto;
      padding: 20px;
    }

    .modal-cur-level {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: rgba(247, 201, 72, .08);
      border: 1px solid rgba(247, 201, 72, .25);
      border-radius: 4px;
      padding: 6px 14px;
      margin-bottom: 18px;
      font-size: .75rem;
      color: var(--gold);
    }

    .detail-table {
      width: 100%;
      border-collapse: collapse;
      font-size: .7rem;
    }

    .detail-table th {
      background: rgba(0, 212, 255, .06);
      color: var(--accent);
      font-family: 'Press Start 2P', cursive;
      font-size: .6rem;
      letter-spacing: .08em;
      text-transform: uppercase;
      padding: 9px 10px;
      text-align: left;
      border-bottom: 1px solid var(--border);
      white-space: nowrap;
    }

    .detail-table td {
      padding: 8px 10px;
      border-bottom: 1px solid rgba(255, 255, 255, .04);
      vertical-align: middle;
    }

    .detail-table tr.current-row td {
      background: rgba(0, 212, 255, .07);
      border-left: 2px solid var(--accent);
    }

    .detail-table tr:hover td {
      background: rgba(255, 255, 255, .03);
    }

    .lvl-badge {
      display: inline-block;
      font-family: 'Press Start 2P', cursive;
      font-size: .65rem;
      font-weight: 700;
      padding: 2px 7px;
      border-radius: 3px;
      background: rgba(255, 255, 255, .06);
      color: var(--text);
    }

    .lvl-badge.active {
      background: rgba(0, 212, 255, .2);
      color: var(--accent);
    }

    .cost-cell {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .cost-line {
      font-size: .63rem;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .cost-line.m {
      color: var(--metal);
    }

    .cost-line.c {
      color: var(--crystal);
    }

    .cost-line.d {
      color: var(--deut);
    }

    .prod-cell {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .prod-line {
      font-size: .63rem;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .prod-line.m {
      color: var(--metal);
    }

    .prod-line.c {
      color: var(--crystal);
    }

    .prod-line.d {
      color: var(--deut);
    }

    .prod-line.e {
      color: var(--energy);
    }

    .prod-none {
      color: var(--dim);
      font-size: .63rem;
    }

    .time-cell {
      color: var(--gold);
      font-size: .68rem;
      white-space: nowrap;
    }

    .modal-build-btn {
      display: block;
      width: 100%;
      margin-top: 18px;
      padding: 11px;
      background: rgba(0, 212, 255, .1);
      border: 1px solid var(--accent);
      border-radius: 4px;
      color: var(--accent);
      font-family: 'VT323', monospace;
      font-size: .8rem;
      letter-spacing: .1em;
      text-transform: uppercase;
      cursor: pointer;
      transition: all .2s;
    }

    .modal-build-btn:hover {
      background: rgba(0, 212, 255, .22);
      box-shadow: 0 0 14px rgba(0, 212, 255, .2);
    }

    .modal-build-btn:disabled {
      opacity: .35;
      cursor: not-allowed;
    }

    .modal-note {
      font-size: .65rem;
      color: var(--dim);
      text-align: center;
      margin-top: 10px;
    }

    /* VERSION FOOTER */
    .version-footer {
      position: fixed;
      bottom: 6px;
      right: 12px;
      z-index: 50;
      font-size: .52rem;
      color: var(--dim);
      letter-spacing: .08em;
      pointer-events: none;
      opacity: .6;
    }

    /* MAP ARROW CONTROLS */
    .map-nav-pad {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
      margin-top: 10px;
    }

    .map-nav-row {
      display: flex;
      gap: 4px;
    }

    .map-nav-btn {
      width: 32px;
      height: 32px;
      background: rgba(0, 212, 255, .08);
      border: 1px solid rgba(0, 212, 255, .25);
      border-radius: 4px;
      color: var(--accent);
      font-size: .9rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all .15s;
      font-family: 'VT323', monospace;
    }

    .map-nav-btn:hover {
      background: rgba(0, 212, 255, .2);
      border-color: var(--accent);
    }

    .map-nav-btn:active {
      transform: scale(.9);
    }

    /* SOCIAL TABLES */
    .table {
      width: 100%;
      margin-top: 8px;
    }

    .trow {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
      gap: 10px;
      align-items: center;
      padding: 8px 10px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: rgba(0, 0, 0, .12);
    }

    .trow.thead {
      font-weight: 700;
      opacity: .85;
      background: rgba(255, 255, 255, .06);
    }

    .btn.btn-sm {
      padding: 6px 10px;
      font-size: .8rem;
    }

    .grid2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }

    /* PROFILE MODAL */
    .profile-overlay {
      position: fixed;
      inset: 0;
      z-index: 600;
      background: rgba(5, 10, 20, .92);
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(4px);
    }

    .profile-overlay.hidden {
      display: none;
    }

    .profile-box {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      width: min(440px, 95vw);
      padding: 28px;
      box-shadow: 0 0 40px rgba(240, 192, 64, .1);
    }

    .profile-title {
      font-family: 'Press Start 2P', cursive;
      font-size: .85rem;
      color: var(--accent);
      letter-spacing: .1em;
      margin-bottom: 18px;
    }

    .profile-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 12px;
    }

    .profile-label {
      font-size: .65rem;
      color: var(--dim);
      width: 110px;
      flex-shrink: 0;
      text-transform: uppercase;
      letter-spacing: .08em;
    }

    .profile-val {
      font-size: .8rem;
      color: var(--text);
    }

    .profile-sep {
      border: none;
      border-top: 1px solid var(--border);
      margin: 16px 0;
    }

    .profile-section {
      font-size: .6rem;
      color: var(--dim);
      letter-spacing: .1em;
      text-transform: uppercase;
      margin-bottom: 10px;
    }

    .profile-input {
      flex: 1;
      background: rgba(255, 255, 255, .04);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 7px 10px;
      color: var(--text);
      font-family: 'VT323', monospace;
      font-size: .85rem;
      outline: none;
    }

    .profile-input:focus {
      border-color: var(--accent);
    }

    .profile-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 14px;
    }

    .profile-btn {
      padding: 8px 14px;
      border-radius: 4px;
      border: 1px solid;
      font-family: 'VT323', monospace;
      font-size: .75rem;
      cursor: pointer;
      letter-spacing: .06em;
      transition: all .2s;
    }

    .profile-btn.save {
      background: rgba(0, 212, 255, .1);
      border-color: var(--accent);
      color: var(--accent);
    }

    .profile-btn.save:hover {
      background: rgba(0, 212, 255, .22);
    }

    .profile-btn.danger {
      background: rgba(255, 61, 90, .08);
      border-color: var(--danger);
      color: var(--danger);
    }

    .profile-btn.danger:hover {
      background: rgba(255, 61, 90, .2);
    }

    .profile-btn.cancel {
      background: rgba(255, 255, 255, .04);
      border-color: var(--border);
      color: var(--dim);
    }

    .profile-btn.cancel:hover {
      border-color: var(--text);
      color: var(--text);
    }

    .profile-msg {
      font-size: .65rem;
      margin-top: 10px;
      min-height: 16px;
    }

    .profile-msg.ok {
      color: var(--ok);
    }

    .profile-msg.err {
      color: var(--danger);
    }

    .profile-btn:disabled {
      opacity: .35;
      cursor: not-allowed;
    }

    /* ADMIN USERS */
    .admin-users-table {
      width: 100%;
      border-collapse: collapse;
      font-size: .72rem;
      margin-top: 10px;
    }

    .admin-users-table th {
      padding: 7px 8px;
      text-align: left;
      font-size: .55rem;
      letter-spacing: .1em;
      text-transform: uppercase;
      color: var(--dim);
      border-bottom: 1px solid var(--border);
      background: rgba(0, 0, 0, .2);
    }

    .admin-users-table td {
      padding: 7px 8px;
      border-bottom: 1px solid rgba(255, 255, 255, .03);
      vertical-align: middle;
    }

    .admin-users-table tr:hover td {
      background: rgba(255, 255, 255, .02);
    }

    .admin-del-btn {
      padding: 3px 8px;
      background: rgba(255, 61, 90, .1);
      border: 1px solid rgba(255, 61, 90, .4);
      border-radius: 3px;
      color: var(--danger);
      font-family: 'VT323', monospace;
      font-size: .68rem;
      cursor: pointer;
      transition: all .2s;
    }

    .admin-del-btn:hover {
      background: rgba(255, 61, 90, .25);
    }

    /* RECURSOS PAGE */
    .recursos-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }

    @media(max-width:700px) {
      .recursos-grid {
        grid-template-columns: 1fr;
      }
    }

    .rec-assign-row {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 6px;
      flex-wrap: wrap;
    }

    .rec-btn {
      padding: 5px 10px;
      background: rgba(111, 207, 122, .1);
      border: 1px solid var(--ok);
      border-radius: 4px;
      color: var(--ok);
      font-family: 'VT323', monospace;
      font-size: .82rem;
      cursor: pointer;
      transition: all .2s;
    }

    .rec-btn:hover {
      background: rgba(111, 207, 122, .25);
    }

    .rec-btn.red {
      background: rgba(224, 64, 64, .08);
      border-color: var(--danger);
      color: var(--danger);
    }

    .rec-btn.red:hover {
      background: rgba(224, 64, 64, .2);
    }

    /* ============================================================ */
    /* MOBILE RESPONSIVE (v0.19) */
    /* ============================================================ */
    @media (max-width: 768px) {
      .main-layout {
        display: block;
        padding-bottom: 70px;
        /* Space for bottom nav */
      }

      .sidebar {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 65px;
        display: flex;
        flex-direction: row;
        justify-content: space-around;
        align-items: stretch;
        background: #0d1f3c;
        border-right: none;
        border-top: 2px solid var(--accent);
        z-index: 1000;
        padding: 0;
      }

      .nav-section {
        margin: 0;
        display: flex;
        flex: 1;
        justify-content: space-around;
      }

      .nav-label {
        display: none;
      }

      .nav-item {
        flex-direction: column;
        justify-content: center;
        gap: 2px;
        padding: 5px;
        font-size: 0.6rem;
        border-left: none;
        border-bottom: 3px solid transparent;
        flex: 1;
        text-align: center;
      }

      .nav-item.active {
        border-left-color: transparent;
        border-bottom-color: var(--accent);
        background: rgba(240, 192, 64, 0.1);
      }

      .nav-icon {
        font-size: 1.2rem;
        margin: 0;
      }

      .topbar {
        height: auto;
        flex-wrap: wrap;
        padding: 8px 10px;
        gap: 10px;
      }

      .res-bar {
        order: 2;
        width: 100%;
        gap: 5px;
        padding-bottom: 5px;
      }

      .topbar-right {
        order: 1;
        margin-left: auto;
      }

      .logo {
        order: 0;
        font-size: 0.8rem;
        margin-right: 0;
      }

      .ov-grid,
      .recursos-grid,
      .bld-grid,
      .grid2 {
        grid-template-columns: 1fr !important;
      }

      .content {
        padding: 15px 10px 80px;
      }

      .auth-box {
        width: 92%;
        padding: 25px 15px;
      }

      .bld-modal {
        width: 100vw;
        height: 100vh;
        max-height: 100vh;
        border-radius: 0;
      }

      .res-chip {
        padding: 4px 6px;
      }

      .version-footer {
        bottom: 75px;
        /* Above bottom nav */
      }
    }

    /* ADMIN DASHBOARD (v0.19) */
    .admin-overlay {
      position: fixed;
      inset: 0;
      z-index: 1000;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(5px);
    }

    .admin-overlay.hidden {
      display: none;
    }

    .admin-box {
      background: var(--panel);
      border: 2px solid var(--danger);
      border-radius: 12px;
      width: min(600px, 95vw);
      padding: 30px;
      box-shadow: 0 0 50px rgba(224, 64, 64, 0.2);
      max-height: 90vh;
      overflow-y: auto;
    }

    .admin-title {
      font-family: 'Press Start 2P', cursive;
      font-size: 1rem;
      color: var(--danger);
      margin-bottom: 20px;
      text-align: center;
    }

    .admin-search-wrap {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }

    .admin-input-search {
      flex: 1;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 10px;
      color: var(--text);
      font-family: 'VT323', monospace;
      font-size: 1rem;
    }

    .admin-results-box {
      background: rgba(0, 0, 0, 0.2);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 10px;
      margin-bottom: 20px;
      display: none;
    }

    .admin-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
      gap: 15px;
    }

    .admin-label {
      font-size: 0.8rem;
      color: var(--dim);
      min-width: 100px;
    }

    .admin-input {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 5px 10px;
      color: var(--text);
      font-family: 'VT323', monospace;
      width: 120px;
      text-align: right;
    }

    .admin-btn {
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-family: 'VT323', monospace;
      font-size: 0.9rem;
      text-transform: uppercase;
      border: 1px solid transparent;
      transition: all 0.2s;
    }

    .admin-btn.search {
      background: var(--accent);
      color: #000;
      border-color: var(--gold);
    }

    .admin-btn.apply {
      background: var(--danger);
      color: #fff;
      border-color: #ff4040;
    }

    .admin-btn.cancel {
      background: transparent;
      color: var(--dim);
      border-color: var(--border);
    }

    .admin-btn:hover {
      filter: brightness(1.2);
    }

    .admin-village-item {
      padding: 8px;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      font-size: 0.85rem;
    }

    .admin-village-item:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    .admin-village-item.active {
      border-left: 3px solid var(--danger);
      background: rgba(224, 64, 64, 0.1);
    }
  </style>
</head>

<body>
  <div class="stars" id="stars"></div>
  <div class="notif-wrap" id="notifWrap"></div>

  <!-- AUTH -->
  <div class="auth-screen" id="authScreen">
    <div class="auth-box">
      <div class="auth-logo">&#x2B21; EPIC WARRIORS</div>
      <div class="auth-tagline">CONQUISTA EL MUNDO</div>
      <div class="auth-tabs">
        <button class="auth-tab active" id="btnTL" onclick="switchTab('login')">Iniciar Sesion</button>
        <button class="auth-tab" id="btnTR" onclick="switchTab('register')">Registrarse</button>
      </div>
      <div id="tabL">
        <div class="auth-field"><label class="auth-label">Email</label><input class="auth-input" type="email"
            id="lEmail" placeholder="comandante@galaxia.com" onkeypress="if(event.key==='Enter')doLogin()"></div>
        <div class="auth-field"><label class="auth-label">Contrasena</label><input class="auth-input" type="password"
            id="lPass" placeholder="..." onkeypress="if(event.key==='Enter')doLogin()"></div>
        <button class="auth-btn" id="lBtn" onclick="doLogin()">Entrar</button>
      </div>
      <div id="tabR" style="display:none">
        <div class="auth-field"><label class="auth-label">Nombre de usuario</label><input class="auth-input" type="text"
            id="rUser" oninput="onUserInput()" placeholder="Ej: Jesus_33" maxlength="15" autocapitalize="off"
            autocomplete="nickname"></div>

        <div class="auth-field"><label class="auth-label">Email</label><input class="auth-input" type="email"
            id="rEmail" placeholder="comandante@galaxia.com" onkeypress="if(event.key==='Enter')doRegister()"></div>
        <div class="auth-field"><label class="auth-label">Contrasena</label><input class="auth-input" type="password"
            id="rPass" placeholder="Min. 6 caracteres" onkeypress="if(event.key==='Enter')doRegister()"></div>
        <div class="auth-msg" id="userMsg" style="text-align:left;margin:-6px 0 8px;min-height:18px;"></div>
        <button class="auth-btn" id="rBtn" onclick="doRegister()">Crear Cuenta</button>
      </div>
      <div class="auth-msg" id="authMsg"></div>
    </div>
  </div>

  <!-- GAME -->
  <div class="game-wrapper" id="gameWrapper">
    <header class="topbar">
      <div class="logo">&#x2B21; EPIC</div>
      <div class="res-bar">

        <div class="res-chip ma">
          <div class="res-chip-top"><span class="res-icon">🌲</span>
            <div class="res-info"><span class="res-name">Madera</span><span class="res-val" id="rMadera">0</span><span class="res-rate" id="rMaderaR">+0/h</span></div>
          </div>
          <div class="cap-bar-wrap"><div class="cap-bar ok" id="capBarMa" style="width:0%"></div></div>
        </div>

        <div class="res-chip pi">
          <div class="res-chip-top"><span class="res-icon">⛰️</span>
            <div class="res-info"><span class="res-name">Piedra</span><span class="res-val" id="rPiedra">0</span><span class="res-rate" id="rPiedraR">+0/h</span></div>
          </div>
          <div class="cap-bar-wrap"><div class="cap-bar ok" id="capBarPi" style="width:0%"></div></div>
        </div>

        <div class="res-chip hi">
          <div class="res-chip-top"><span class="res-icon">⚙️</span>
            <div class="res-info"><span class="res-name">Hierro</span><span class="res-val" id="rHierro">0</span><span class="res-rate" id="rHierroR">+0/h</span></div>
          </div>
          <div class="cap-bar-wrap"><div class="cap-bar ok" id="capBarHi" style="width:0%"></div></div>
        </div>

        <div class="res-chip pr">
          <div class="res-chip-top"><span class="res-icon">🌾</span>
            <div class="res-info"><span class="res-name">Provisiones</span><span class="res-val" id="rProv">0</span><span class="res-rate" id="rProvR">+0/h</span></div>
          </div>
          <div class="cap-bar-wrap"><div class="cap-bar ok" id="capBarPr" style="width:0%"></div></div>
        </div>

        <div class="res-chip es">
          <div class="res-chip-top"><span class="res-icon">✨</span>
            <div class="res-info"><span class="res-name">Esencia</span><span class="res-val" id="rEsencia">0</span><span class="res-rate" id="rEsenciaR">+0/h</span></div>
          </div>
          <div class="cap-bar-wrap" style="background:rgba(192,96,255,.12)"><div class="cap-bar" style="width:0%;background:var(--esencia);" id="capBarEs"></div></div>
        </div>

        <div class="res-chip" style="color:var(--aldeanos);border-color:rgba(255,221,96,.3)">
          <div class="res-chip-top"><span class="res-icon">👤</span>
            <div class="res-info">
              <span class="res-name" style="color:var(--dim)">Aldeanos</span>
              <span class="res-val" style="color:var(--aldeanos)" id="rAldeanos">0</span>
              <div style="display:flex;justify-content:space-between;align-items:center;gap:6px;">
                <span class="res-rate" id="rTropasBase" style="color:var(--dim);">0</span>
                <span class="res-rate" id="rBarrCap" style="color:var(--dim);">/ 0</span>
              </div>
            </div>
          </div>
          <div class="cap-bar-wrap"><div class="cap-bar ok" id="capBarAld" style="width:0%;background:var(--aldeanos);"></div></div>
        </div>

      </div>
      <div class="topbar-right">
        <div class="save-dot" id="saveDot"></div>
        <span class="save-txt" id="saveTxt">guardado</span>
        <span id="activePlayers" style="font-size:.65rem;color:var(--ok);letter-spacing:.05em;padding:2px 8px;background:rgba(79,255,176,.08);border:1px solid rgba(79,255,176,.2);border-radius:4px;">🟢 0 online</span>
        <select class="village-sel" id="villageSel" onchange="switchVillage(this.value)"></select>
        <button id="adminBtn" onclick="openAdmin()"
          style="display:none;background:rgba(255,61,90,.08);border:1px solid rgba(255,61,90,.3);border-radius:4px;color:rgba(255,61,90,.7);padding:5px 10px;font-size:.68rem;cursor:pointer;font-family:'VT323',monospace;letter-spacing:.06em;">⚙
          ADMIN</button>
        <button onclick="openProfile()"
          style="background:rgba(240,192,64,.08);border:1px solid rgba(240,192,64,.25);border-radius:4px;color:var(--gold);padding:5px 10px;font-size:.68rem;cursor:pointer;font-family:'VT323',monospace;letter-spacing:.06em;">👤
          <span id="topbarUsername">...</span></button>
        <button id="alertsBtn" onclick="toggleAlertsPanel()">
          🔔 <span id="alertsBtnLabel">Alertas</span>
          <span id="alertsBadge" style="display:none;position:absolute;top:-6px;right:-6px;background:var(--danger);color:#fff;font-size:.55rem;width:16px;height:16px;border-radius:50%;align-items:center;justify-content:center;font-weight:bold;">0</span>
        </button>
        <button class="logout-btn" onclick="doLogout()">Salir</button>
      </div>
    </header>
    <div class="main-layout">
      <nav class="sidebar">
        <div class="nav-section">
          <div class="nav-label">Colonia</div>
          <div class="nav-item active" onclick="showPage('overview',this)"><span class="nav-icon">&#x1F310;</span>
            Vision General</div>
          <div class="nav-item" onclick="showPage('buildings',this)"><span class="nav-icon">&#x1F3D7;</span> Edificios
          </div>
          <div class="nav-item" onclick="showPage('recursos',this)"><span class="nav-icon">&#x1F33E;</span> Recursos
          </div>
        </div>
        <div class="nav-section">
          <div class="nav-label">Mundo</div>
          <div class="nav-item" onclick="showPage('map',this)"><span class="nav-icon">&#x1F5FA;</span> Mapa</div>
        </div>
        <div class="nav-section">
          <div class="nav-label">Militar</div>
          <div class="nav-item" onclick="showPage('fleet',this)"><span class="nav-icon">⚔️</span> Tropas</div>
          <div class="nav-item" onclick="showPage('creatures',this)"><span class="nav-icon">🐉</span> Criaturas</div>
          <div class="nav-item" onclick="showPage('defense',this)"><span class="nav-icon">&#x1F6E1;</span> Defensa</div>
          <div class="nav-item" onclick="window.open('battle-simulator-v0_21.html','_blank')"><span class="nav-icon">&#x2694;&#xFE0F;</span> Simulador</div>
        </div>
        <div class="nav-section">
          <div class="nav-label">Ciencia</div>
          <div class="nav-item" onclick="showPage('research',this)"><span class="nav-icon">&#x1F52C;</span>
            Investigacion</div>
        </div>
        <div class="nav-section">
          <div class="nav-label">Social</div>
          <div class="nav-item" onclick="showPage('ranking',this)"><span class="nav-icon">&#x1F3C6;</span> Ranking</div>
          <div class="nav-item" onclick="showPage('alliances',this)"><span class="nav-icon">&#x1F6E1;</span> Alianzas
          </div>
          <div class="nav-item" onclick="showPage('messages',this)"><span class="nav-icon">&#x1F4E8;</span> Mensajes
          </div>
        </div>
        <div class="nav-section" id="adminNavSection" style="display:none;">
          <div class="nav-label" style="color:var(--danger)">Admin</div>
          <div class="nav-item" onclick="showPage('adminusers',this)" style="color:rgba(255,61,90,.7)"><span
              class="nav-icon">👥</span> Usuarios</div>
        </div>
      </nav>
      <main class="content">
        <div class="page active" id="page-overview">
          <div class="page-title">VISION GENERAL</div>

          <!-- Player profile card -->
          <div class="card" style="margin-bottom:14px;">
            <div style="display:flex;align-items:center;gap:16px;flex-wrap:wrap;margin-bottom:16px;">
              <div style="font-size:3.5rem;line-height:1;">👑</div>
              <div style="flex:1;min-width:0;">
                <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px;flex-wrap:wrap;">
                  <span style="font-size:1.5rem;color:var(--accent);font-family:VT323,monospace;" id="ovUser">--</span>
                  <span style="font-size:.8rem;color:var(--accent2);" id="ovAlliance"></span>
                </div>
                <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
                  <span class="planet-name-big" id="ovVillageName" style="font-size:1rem;color:var(--dim);">Cargando...</span>
                  <button onclick="startRename()" style="background:rgba(0,212,255,.08);border:1px solid rgba(0,212,255,.3);border-radius:4px;color:var(--accent);font-family:'VT323',monospace;font-size:.62rem;padding:2px 7px;cursor:pointer;">✏</button>
                </div>
                <div id="renameForm" style="display:none;margin-top:8px;">
                  <input id="renameInput" style="background:rgba(255,255,255,.05);border:1px solid var(--accent);border-radius:4px;padding:5px 10px;color:var(--text);font-family:'VT323',monospace;font-size:.82rem;outline:none;width:200px;" placeholder="Nuevo nombre...">
                  <button onclick="confirmRename()" style="margin-left:6px;background:rgba(79,255,176,.1);border:1px solid var(--ok);border-radius:4px;color:var(--ok);font-family:'VT323',monospace;font-size:.72rem;padding:5px 10px;cursor:pointer;">✓</button>
                  <button onclick="cancelRename()" style="margin-left:4px;background:rgba(255,61,90,.08);border:1px solid rgba(255,61,90,.3);border-radius:4px;color:var(--danger);font-family:'VT323',monospace;font-size:.72rem;padding:5px 10px;cursor:pointer;">✕</button>
                </div>
                <div class="planet-coords" id="ovVillageCoords" style="font-size:.68rem;color:var(--dim);margin-top:4px;">--</div>
              </div>
            </div>

            <!-- Stats: XP + Battles solo, sin recursos -->
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
              <div style="background:var(--panel2);border-radius:8px;padding:14px;text-align:center;border:1px solid rgba(240,192,64,.15);">
                <div style="font-size:.62rem;color:var(--dim);letter-spacing:.12em;margin-bottom:6px;">⭐ EXPERIENCIA</div>
                <div style="font-size:1.6rem;color:var(--gold);font-weight:bold;font-family:VT323,monospace;" id="ovExperience">0</div>
              </div>
              <div style="background:var(--panel2);border-radius:8px;padding:14px;text-align:center;border:1px solid rgba(255,61,90,.12);">
                <div style="font-size:.62rem;color:var(--dim);letter-spacing:.12em;margin-bottom:6px;">⚔️ BATALLAS JvJ</div>
                <div style="font-size:1.2rem;margin-top:2px;font-family:VT323,monospace;">
                  <span style="color:var(--ok);" id="ovBattlesWon">0</span>
                  <span style="color:var(--dim);font-size:.9rem;"> V · </span>
                  <span style="color:var(--danger);" id="ovBattlesLost">0</span>
                  <span style="color:var(--dim);font-size:.9rem;"> D</span>
                </div>
                <div style="font-size:.58rem;color:var(--dim);margin-top:2px;">Solo contra jugadores</div>
              </div>
            </div>
          </div>

          <!-- Troop movement alerts -->
          <div class="card" style="margin-bottom:14px;">
            <div class="h2">⚠️ Movimientos de tropas</div>
            <div id="ovAlertsBox" style="margin-top:8px;font-size:.8rem;color:var(--dim);">Sin alertas activas.</div>
          </div>

          <!-- Refuerzos estacionados en esta aldea -->
          <div class="card" style="margin-bottom:14px;" id="ovReinforcementsCard" style="display:none;">
            <div class="h2">🛡️ Refuerzos estacionados</div>
            <div id="ovReinforcementsBox" style="margin-top:8px;font-size:.8rem;color:var(--dim);">Sin refuerzos.</div>
          </div>

          <!-- Build queue -->
          <div class="queue-panel">
            <div class="queue-title">CONSTRUCCION EN CURSO</div>
            <div class="queue-empty" id="qEmptyOv">Sin construcciones activas.</div>
            <div id="qItemsOv"></div>
          </div>
        </div>

        <!-- RECURSOS PAGE -->
        <div class="page" id="page-recursos">
          <div class="page-title">RECURSOS</div>
          <div class="page-sub">Asigna aldeanos a cada recurso para aumentar su producción. Los edificios garantizan una
            base mínima.</div>

          <!-- Resumen aldeanos -->
          <div class="queue-panel" style="border-color:rgba(255,221,96,.2);margin-bottom:14px;">
            <div style="display:flex;gap:20px;flex-wrap:wrap;align-items:center;">
              <span style="font-size:.8rem;">👤 Libres: <b id="recAldLibres" style="color:var(--aldeanos)">0</b></span>
              <span style="font-size:.8rem;">⚒️ Trabajando: <b id="recAldWorking"
                  style="color:var(--accent2)">0</b></span>
              <span style="font-size:.8rem;">🏠 Barracas: <b id="recAldCap" style="color:var(--dim)">0</b> plazas</span>
              <span style="font-size:.8rem;">📦 Almacén: <b id="recAlmPct" style="color:var(--gold)">0%</b>
                ocupado</span>
            </div>
          </div>

          <!-- Cards de recursos con barras -->
          <div class="recursos-grid" id="recursosGrid"></div>
        </div>

        <!-- ADMIN USUARIOS PAGE -->
        <div class="page" id="page-adminusers">
          <div class="page-title" style="color:var(--danger)">ADMIN — USUARIOS</div>
          <div class="page-sub">Gestión de cuentas. Solo visible para administradores.</div>
          <div class="card">
            <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;">
              <div class="muted" id="adminUserCount">Cargando...</div>
              <button class="btn" onclick="loadAdminUsers()">↻ Actualizar</button>
            </div>
            <div id="adminUsersBox" style="margin-top:12px;overflow-x:auto;"></div>
          </div>
        </div>

        <div class="page" id="page-buildings">
          <div class="page-title">EDIFICIOS</div>
          <div class="page-sub">Construye y mejora las estructuras de tu colonia</div>
          <div class="queue-panel">
            <div class="queue-title">COLA DE CONSTRUCCION</div>
            <div class="queue-empty" id="qEmpty">Sin construcciones activas.</div>
            <div id="qItems"></div>
          </div>
          <div class="bld-grid" id="bldGrid"></div>
        </div>

        <div class="page" id="page-map">
          <div class="page-title">MAPA MUNDIAL</div>
          <div class="page-sub">Vista 21×21 centrada — usa ↑↓←→ o WASD para moverte. Mapa de 216×216</div>
          <div class="map-container">
            <div class="map-header">
              <div class="map-legend">
                <div class="legend-item">
                  <div class="legend-dot" style="background:rgba(0,212,255,.5)"></div><span>Tu aldea</span>
                </div>
                <div class="legend-item">
                  <div class="legend-dot" style="background:rgba(255,61,90,.5)"></div><span>Aldea enemiga</span>
                </div>
                <div class="legend-item">
                  <div class="legend-dot" style="background:rgba(255,230,0,.5)"></div><span>Castillo Caballero</span>
                </div>
                <div class="legend-item">
                  <div class="legend-dot" style="background:rgba(255,255,255,.04)"></div><span>Vacio</span>
                </div>
              </div>
              <div class="map-nav-pad">
                <div class="map-nav-row"><button class="map-nav-btn" onclick="panMap(0,-1)" title="Arriba">↑</button>
                </div>
                <div class="map-nav-row">
                  <button class="map-nav-btn" onclick="panMap(-1,0)" title="Izquierda">←</button>
                  <button class="map-nav-btn" onclick="panMap(0,0,true)" title="Centrar en tu aldea">⌂</button>
                  <button class="map-nav-btn" onclick="panMap(1,0)" title="Derecha">→</button>
                </div>
                <div class="map-nav-row"><button class="map-nav-btn" onclick="panMap(0,1)" title="Abajo">↓</button>
                </div>
              </div>
            </div>
            <div class="map-coords-display" id="mapCoordsDisplay">Cargando mapa...</div>
            <div style="display:flex;gap:6px;align-items:center;margin-top:6px;">
              <span style="font-size:.68rem;color:var(--dim);">Ir a:</span>
              <input id="mapGoX" type="number" placeholder="X" style="width:54px;background:rgba(255,255,255,.06);border:1px solid var(--border);border-radius:4px;padding:3px 6px;color:var(--text);font-family:VT323,monospace;font-size:.8rem;text-align:center;">
              <span style="color:var(--dim);">,</span>
              <input id="mapGoY" type="number" placeholder="Y" style="width:54px;background:rgba(255,255,255,.06);border:1px solid var(--border);border-radius:4px;padding:3px 6px;color:var(--text);font-family:VT323,monospace;font-size:.8rem;text-align:center;">
              <button onclick="goToCoords()" style="background:rgba(0,212,255,.1);border:1px solid var(--accent);border-radius:4px;color:var(--accent);font-family:VT323,monospace;font-size:.75rem;padding:3px 10px;cursor:pointer;">Ir</button>
            </div>
            <div class="map-grid-wrap">
              <div class="map-grid" id="mapGrid"></div>
            </div>
            <div class="map-panel" id="mapPanel">
              <div class="map-panel-title" id="mapPanelTitle">--</div>
              <div class="map-panel-sub" id="mapPanelSub">--</div>
              <div class="map-actions" id="mapActions"></div>
            </div>
          </div>
        </div>

        <div class="page" id="page-fleet">
          <div class="page-title">TROPAS</div>
          <div class="page-sub">Entrenamiento y unidades disponibles</div>

          <div class="card" style="margin-bottom:14px;">
            <div class="h2">⏳ Cola de entrenamiento</div>
            <div id="trainingQueueBox" style="margin-top:10px;"></div>
          </div>

          <div class="card" style="margin-bottom:14px;">
            <div class="h2">⚔️ Entrenar tropas</div>
            <div class="muted" style="font-size:.7rem;margin-bottom:10px;">Pulsa el icono para ver estadísticas. Los aldeanos se descuentan y materiales al encolar.</div>
            <div id="trainOptionsBox" style="margin-top:10px;"></div>
          </div>

          <!-- troopsListBox eliminado — integrado en trainOptionsBox -->
          <div id="troopsListBox" style="display:none;"></div>
        </div>
        <div class="page" id="page-creatures">
          <div class="page-title">🐉 CRIATURAS</div>
          <div class="page-sub">Criaturas invocadas - No ocupan barracas ni consumen provisiones</div>
          
          <div class="card" style="margin-bottom:14px;">
            <div class="h2">🔮 Torre de Invocación</div>
            <div id="torreInvocacionInfo" style="font-size:.82rem;margin-top:8px;color:var(--gold);">—</div>
            <div class="muted" style="margin-top:4px;font-size:.7rem;">Cada nivel reduce -5% el tiempo de invocación.</div>
          </div>

          <div class="card" style="margin-bottom:14px;">
            <div class="h2">📋 Cola de Invocación</div>
            <div id="summoningQueueBox" style="margin-top:10px;">—</div>
          </div>

          <div class="card" style="margin-bottom:14px;">
            <div class="h2">👹 Criaturas Disponibles</div>
            <div id="creaturesListBox" style="margin-top:10px;"></div>
          </div>

          <div class="card">
            <div class="h2">⚡ Invocar Criatura</div>
            <div id="summonBox" style="margin-top:10px;"></div>
          </div>
        </div>
        <div class="page" id="page-defense">
          <div class="coming-soon">
            <div class="cs-icon">&#x1F6E1;</div>
            <div class="cs-title">MODULO DE DEFENSA</div>
            <div>Proximamente</div>
          </div>
        </div>

        <div class="page" id="page-simulator">
          <div class="page-title">⚔️ SIMULADOR DE BATALLA</div>
          <div class="page-sub">Prueba combinaciones de tropas antes de atacar</div>
          <div id="simulatorContent" style="padding:16px;">
            <p style="color:var(--dim);font-size:.85rem;">Selecciona un caballero desde el mapa y pulsa "Simular" para ver el resultado estimado del combate antes de enviar tus tropas.</p>
          </div>
        </div>
        <div class="page" id="page-research">
          <div class="coming-soon">
            <div class="cs-icon">&#x1F52C;</div>
            <div class="cs-title">MODULO DE INVESTIGACION</div>
            <div>Proximamente</div>
          </div>
        </div>

        <div class="page" id="page-ranking">
          <div class="page-title">RANKING</div>
          <div class="page-sub">Clasificación militar — cada tropa cuenta 1 punto</div>
          <div class="card">
            <div style="display:flex;gap:10px;align-items:center;justify-content:space-between;">
              <div class="muted">Se actualiza automáticamente cada 6 horas.</div>
              <button class="btn" onclick="forceRefreshRanking()">↻ Forzar actualización</button>
            </div>
            <div id="rankingBox" style="margin-top:12px;"></div>
          </div>
        </div>

        <div class="page" id="page-alliances">
          <div class="page-title">ALIANZAS</div>
          <div class="page-sub">Crear, solicitar, gestionar y comunicarse</div>

          <!-- CABECERA MI ALIANZA -->
          <div class="card" style="margin-bottom:14px;">
            <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:10px;">
              <div class="h2">Mi alianza</div>
              <button class="btn btn-sm" onclick="renderAlliances()">&#x21BB; Actualizar</button>
            </div>
            <div id="myAllianceBox" class="muted">Cargando&#x2026;</div>
          </div>

          <!-- SIN ALIANZA -->
          <div id="alNoAlliancePanel">
            <div class="grid2">
              <div class="card">
                <div class="h2">Crear alianza</div>
                <div class="muted" style="margin-bottom:10px;">Nombre + Tag (2-6 letras). Ser&#xE1;s el l&#xED;der.</div>
                <div style="display:grid;grid-template-columns:1fr 110px;gap:8px;">
                  <input id="alName" class="input" placeholder="Nombre de alianza" maxlength="40"/>
                  <input id="alTag" class="input" placeholder="TAG" maxlength="6" style="text-transform:uppercase;"/>
                </div>
                <button class="btn" style="margin-top:10px;" onclick="createAlliance()">&#x2694; Crear alianza</button>
                <div id="createAllianceMsg" class="muted" style="margin-top:8px;min-height:16px;"></div>
              </div>
              <div class="card">
                <div class="h2">Solicitar unirse</div>
                <div class="muted" style="margin-bottom:10px;">Busca una alianza en la lista y pulsa Solicitar. El l&#xED;der deber&#xE1; aceptarte.</div>
                <div id="alPendingMsg" class="muted" style="min-height:16px;"></div>
              </div>
            </div>
            <div class="card" style="margin-top:14px;">
              <div class="h2">Alianzas activas</div>
              <div id="alliancesBox" style="margin-top:8px;"></div>
            </div>
          </div>

          <!-- MIEMBRO ACTIVO (no l&#xED;der) -->
          <div id="alMemberPanel" style="display:none;">
            <div class="grid2">
              <div class="card">
                <div class="h2">Miembros</div>
                <div id="alMembersList" class="muted">Cargando&#x2026;</div>
              </div>
              <div class="card">
                <div class="h2">Acciones</div>
                <button class="btn" style="width:100%;margin-bottom:8px;" onclick="openAllianceChat()">&#x1F4AC; Chat de alianza</button>
                <button class="btn" style="width:100%;background:rgba(224,64,64,.1);border-color:var(--danger);color:var(--danger);" onclick="leaveAlliance()">&#x1F6AA; Salir de la alianza</button>
              </div>
            </div>
          </div>

          <!-- L&#xCD;DER -->
          <div id="alLeaderPanel" style="display:none;">
            <div class="grid2">
              <div class="card">
                <div class="h2">Miembros activos</div>
                <div id="alLeaderMembersList" class="muted">Cargando&#x2026;</div>
              </div>
              <div class="card">
                <div class="h2">Solicitudes pendientes</div>
                <div id="alPendingList" class="muted">Cargando&#x2026;</div>
              </div>
            </div>
            <div class="card" style="margin-top:14px;">
              <div class="h2">Invitar jugador</div>
              <div style="display:flex;gap:8px;margin-top:8px;">
                <input id="alInviteUser" class="input" placeholder="Nombre de usuario&#x2026;" style="flex:1;" onkeydown="if(event.key==='Enter') inviteToAlliance()"/>
                <button class="btn" onclick="inviteToAlliance()">Invitar</button>
              </div>
              <div id="alInviteMsg" class="muted" style="margin-top:8px;min-height:16px;"></div>
            </div>
            <div class="card" style="margin-top:14px;">
              <div class="h2">Acciones de l&#xED;der</div>
              <div style="display:flex;gap:8px;flex-wrap:wrap;">
                <button class="btn" onclick="openAllianceChat()">&#x1F4AC; Chat de alianza</button>
                <button class="btn" style="background:rgba(224,64,64,.1);border-color:var(--danger);color:var(--danger);" onclick="dissolveAlliance()">&#x1F4A3; Disolver alianza</button>
              </div>
            </div>
          </div>

          <!-- PENDIENTE / INVITADO -->
          <div id="alPendingPanel" style="display:none;">
            <div class="card">
              <div id="alPendingStatusBox" class="muted">Cargando&#x2026;</div>
              <div style="display:flex;gap:8px;margin-top:12px;flex-wrap:wrap;" id="alPendingActions"></div>
            </div>
          </div>
        </div>

        <div class="page" id="page-messages">
          <div class="page-title">MENSAJES</div>
          <div class="page-sub">Sistema · Alianza · Mensajes directos</div>

          <div style="display:grid;grid-template-columns:280px 1fr;gap:16px;height:calc(100vh - 200px);min-height:420px;">

            <!-- ── PANEL IZQUIERDO: bandeja ────────────────────── -->
            <div style="display:flex;flex-direction:column;gap:0;background:var(--panel);border:1px solid var(--border);border-radius:8px;overflow:hidden;">

              <!-- Cabecera + acciones rápidas -->
              <div style="padding:14px 14px 10px;border-bottom:1px solid var(--border);">
                <div style="font-size:.7rem;letter-spacing:.12em;color:var(--accent);margin-bottom:10px;">📬 BANDEJA</div>

                <!-- DM -->
                <div style="display:flex;gap:6px;margin-bottom:8px;">
                  <input id="dmUser" placeholder="Username para DM…"
                    style="flex:1;background:rgba(255,255,255,.04);border:1px solid var(--border);border-radius:4px;padding:6px 8px;color:var(--text);font-family:VT323,monospace;font-size:.78rem;outline:none;"
                    onkeydown="if(event.key==='Enter') startDM()" />
                  <button onclick="startDM()"
                    style="padding:5px 10px;background:rgba(240,192,64,.1);border:1px solid var(--accent);border-radius:4px;color:var(--accent);font-family:VT323,monospace;font-size:.75rem;cursor:pointer;white-space:nowrap;">✉ DM</button>
                </div>

                <!-- Botones rápidos -->
                <div style="display:flex;gap:6px;">
                  <button onclick="openAllianceChat()"
                    style="flex:1;padding:5px 4px;background:rgba(96,208,96,.08);border:1px solid var(--accent2);border-radius:4px;color:var(--accent2);font-family:VT323,monospace;font-size:.72rem;cursor:pointer;">⚔ Alianza</button>
                  <button onclick="openSystemThread()"
                    style="flex:1;padding:5px 4px;background:rgba(192,96,255,.08);border:1px solid var(--esencia);border-radius:4px;color:var(--esencia);font-family:VT323,monospace;font-size:.72rem;cursor:pointer;">🔔 Sistema</button>
                  <button onclick="renderThreads()"
                    style="flex:1;padding:5px 4px;background:rgba(255,255,255,.04);border:1px solid var(--border);border-radius:4px;color:var(--dim);font-family:VT323,monospace;font-size:.72rem;cursor:pointer;">↻</button>
                </div>
              </div>

              <!-- Lista de hilos -->
              <div id="threadsBox" style="flex:1;overflow-y:auto;padding:6px 0;"></div>
            </div>

            <!-- ── PANEL DERECHO: chat ─────────────────────────── -->
            <div style="display:flex;flex-direction:column;background:var(--panel);border:1px solid var(--border);border-radius:8px;overflow:hidden;">

              <!-- Cabecera del hilo activo -->
              <div id="chatHeader"
                style="padding:12px 16px;border-bottom:1px solid var(--border);display:flex;align-items:center;gap:10px;min-height:48px;">
                <span style="color:var(--dim);font-size:.78rem;">Selecciona una conversación…</span>
              </div>

              <!-- Mensajes -->
              <div id="chatBox" style="flex:1;overflow-y:auto;padding:14px 16px;display:flex;flex-direction:column;gap:8px;"></div>

              <!-- Input envío (oculto hasta que haya hilo activo) -->
              <div id="chatInputArea"
                style="padding:10px 14px;border-top:1px solid var(--border);display:none;gap:8px;align-items:center;">
                <input id="chatMsg" placeholder="Escribe un mensaje…"
                  style="flex:1;background:rgba(255,255,255,.04);border:1px solid var(--border);border-radius:6px;padding:8px 12px;color:var(--text);font-family:VT323,monospace;font-size:.85rem;outline:none;"
                  onkeydown="if(event.key==='Enter') sendChatMsg()" />
                <button onclick="sendChatMsg()"
                  style="padding:7px 16px;background:rgba(240,192,64,.12);border:1px solid var(--accent);border-radius:6px;color:var(--accent);font-family:VT323,monospace;font-size:.82rem;cursor:pointer;">Enviar</button>
              </div>
            </div>
          </div>
        </div>
      </main>
    </div>
  </div>

  <script>
    // ============================================================
    // CONFIG
    // ============================================================
    // --- Supabase (DEV) ---
    // NOTE: The anon key is safe to include in the client for development, but your database must enforce RLS.
    // For convenience during development, you can paste credentials once in the in-app "Supabase Setup" prompt.
    // They are stored in localStorage (browser-only) so you don't have to edit this file every time.
    let SUPABASE_URL = 'https://plrsfepvdgxlaxzejfbu.supabase.co';
    let SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBscnNmZXB2ZGd4bGF4emVqZmJ1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzEwMjIzNjksImV4cCI6MjA4NjU5ODM2OX0.7ypfPPSwvNCyU-QdQe-58gjBYV7glm3fD9yPLHQstTc';

    // Try to load dev credentials from localStorage (so you can just open the file and play).
    try {
      const lsUrl = localStorage.getItem('EW_SUPABASE_URL');
      const lsKey = localStorage.getItem('EW_SUPABASE_KEY');
      if (lsUrl && lsKey) { SUPABASE_URL = lsUrl; SUPABASE_KEY = lsKey; }
    } catch (e) { }


    const GAME_VERSION = '0.70';
    const MAP_SIZE = 380;
    const MAP_VIEW = 10;

    // sessionStorage persiste entre F5 pero no entre pestañas
    // Edge y Firefox bloquean localStorage de CDNs externos, pero sessionStorage funciona
    const sbClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY, {
      auth: {
        storage:          window.sessionStorage,
        persistSession:   true,
        autoRefreshToken: true,
        detectSessionInUrl: false
      }
    });


    let currentUser = null;
    let myVillages = [];
    let activeVillage = null;
    let allVillages = [];
    let uiTimer = null;
    let autoSaveTimer = null;
    let isFlushing = false;
    let pendingFlush = false;

    // NPC_CASTLES cargado desde game-data.js (ver <head> del HTML)
    let playerObjectives = []; // Progress for current user

    // ============================================================
    // TROOP TYPES — normal (ocupa barracas + gasta provisiones) vs criatura
    // ============================================================

    // Rango de visión/ataque (distancia Chebyshev en casillas del mapa)
    function getTorreRange(blds) {
      var lvl = (blds && blds.torre && blds.torre.level) || 0;
      return lvl * 5;
    }

    // TROOP_TYPES — stats alineados con battle-simulator-v0_1
    // type: 'normal' → ocupa barracas + consume provisiones al enviarse
    // type: 'creature' → no ocupa barracas, no consume provisiones
    const TROOP_TYPES = {
      aldeano: {
        name: 'Aldeano', icon: '👤', type: 'normal',
        attackChance: 8, hp: 10, attacksPerTurn: 1, damage: 2,
        defense: 10, armor: 0, weapon: 0, dexterity: 5,
        speed: 1, capacity: 10,
        cost: { madera: 0, hierro: 0, prov: 1 },
        time: 60, barracasSlots: 1,
        desc: 'Tropa básica. Ocupa 1 plaza en barracas y consume 1 provisión al enviarse.'
      },
      soldado: {
        name: 'Guerrero', icon: '⚔️', type: 'normal',
        attackChance: 12, hp: 25, attacksPerTurn: 1, damage: 8,
        defense: 14, armor: 2, weapon: 2, dexterity: 8,
        speed: 2, capacity: 20,
        cost: { madera: 0, hierro: 10, prov: 2 },
        time: 180, barracasSlots: 1,
        desc: 'Soldado de infantería. Más HP y daño que el aldeano. Requiere hierro.'
      },
      mago: {
        name: 'Mago', icon: '🧙', type: 'normal',
        attackChance: 15, hp: 15, attacksPerTurn: 2, damage: 12,
        defense: 10, armor: 0, weapon: 4, dexterity: 12,
        speed: 1, capacity: 5,
        cost: { madera: 0, hierro: 0, prov: 3, esencia: 20 },
        time: 300, barracasSlots: 1,
        desc: 'Ataca 2 veces por turno con magia. Daño alto, defensa baja.'
      },
      druida: {
        name: 'Druida', icon: '🌿', type: 'normal',
        attackChance: 14, hp: 20, attacksPerTurn: 1, damage: 6,
        defense: 12, armor: 1, weapon: 1, dexterity: 10,
        speed: 1, capacity: 15,
        cost: { madera: 5, hierro: 0, prov: 2, esencia: 10 },
        time: 240, barracasSlots: 1,
        desc: 'Equilibrado entre ataque y defensa. Gran capacidad de carga.'
      },
      explorador: {
        name: 'Explorador', icon: '🏹', type: 'normal',
        attackChance: 16, hp: 12, attacksPerTurn: 2, damage: 5,
        defense: 11, armor: 0, weapon: 1, dexterity: 15,
        speed: 4, capacity: 8,
        cost: { madera: 5, hierro: 5, prov: 1 },
        time: 120, barracasSlots: 1,
        desc: 'Muy rápido en el mapa. Ideal para saqueo y exploración.'
      },
      asesino: {
        name: 'Asesino', icon: '🎯', type: 'normal',
        attackChance: 18, hp: 8, attacksPerTurn: 1, damage: 14,
        defense: 9, armor: 0, weapon: 6, dexterity: 20,
        speed: 3, capacity: 5,
        cost: { madera: 10, hierro: 30, esencia: 15, prov: 3 },
        time: 400, barracasSlots: 1,
        desc: 'Especialista en eliminación. Daño y destreza extremos. Frágil.'
      },
      paladin: {
        name: 'Paladín', icon: '🛡️', type: 'normal',
        attackChance: 10, hp: 35, attacksPerTurn: 1, damage: 5,
        defense: 18, armor: 8, weapon: 2, dexterity: 6,
        speed: 1, capacity: 10,
        cost: { madera: 0, piedra: 20, hierro: 40, prov: 4 },
        time: 450, barracasSlots: 1,
        desc: 'Tanque pesado. Armadura y HP formidables. Lento pero resistente.'
      },
      chaman: {
        name: 'Chamán', icon: '🔮', type: 'normal',
        attackChance: 14, hp: 18, attacksPerTurn: 1, damage: 10,
        defense: 11, armor: 1, weapon: 3, dexterity: 11,
        speed: 1, capacity: 8,
        cost: { madera: 15, piedra: 10, esencia: 25, prov: 3 },
        time: 350, barracasSlots: 1,
        desc: 'Gala la fuerza de la naturaleza. Estadísticas mágicas equilibradas.'
      },
      invocador: {
        name: 'Invocador', icon: '🧙‍♂️', type: 'normal',
        attackChance: 6, hp: 7, attacksPerTurn: 1, damage: 1,
        defense: 7, armor: 0, weapon: 0, dexterity: 5,
        speed: 1, capacity: 8,
        cost: { madera: 5, hierro: 5, esencia: 10, prov: 1 },
        time: 120, barracasSlots: 1,
        desc: 'Tropa débil que permite invocar criaturas poderosas. Requisito para invocaciones.'
      }
    };

    const CREATURE_TYPES = {
      orco: {
        name: 'Orco', icon: '👹', tier: 1,
        attackChance: 10, hp: 30, attacksPerTurn: 1, damage: 10,
        defense: 12, armor: 0, weapon: 0, dexterity: 6,
        speed: 2, capacity: 0,
        summonersNeeded: 10, cost: { esencia: 50 }, time: 900, // 15 min
        desc: 'Guerrero brutal. Tier 1. Requiere 10 invocadores.'
      },
      hada: {
        name: 'Hada', icon: '🧚', tier: 1,
        attackChance: 14, hp: 20, attacksPerTurn: 2, damage: 8,
        defense: 10, armor: 0, weapon: 0, dexterity: 15,
        speed: 3, capacity: 0,
        summonersNeeded: 10, cost: { esencia: 50 }, time: 900,
        desc: 'Criatura veloz con doble ataque. Tier 1. Requiere 10 invocadores.'
      },
      golem: {
        name: 'Gólem', icon: '🗿', tier: 2,
        attackChance: 8, hp: 80, attacksPerTurn: 1, damage: 18,
        defense: 18, armor: 0, weapon: 0, dexterity: 4,
        speed: 1, capacity: 0,
        summonersNeeded: 50, cost: { esencia: 150 }, time: 1800, // 30 min
        desc: 'Tanque de piedra. Tier 2. Requiere 50 invocadores.'
      },
      espectro: {
        name: 'Espectro', icon: '👻', tier: 2,
        attackChance: 16, hp: 50, attacksPerTurn: 1, damage: 22,
        defense: 8, armor: 0, weapon: 0, dexterity: 18,
        speed: 2, capacity: 0,
        summonersNeeded: 50, cost: { esencia: 150 }, time: 1800,
        desc: 'Asesino etéreo con alta precisión. Tier 2. Requiere 50 invocadores.'
      },
      grifo: {
        name: 'Grifo', icon: '🦅', tier: 3,
        attackChance: 14, hp: 120, attacksPerTurn: 2, damage: 28,
        defense: 14, armor: 0, weapon: 0, dexterity: 16,
        speed: 4, capacity: 0,
        summonersNeeded: 150, cost: { esencia: 400 }, time: 3600, // 60 min
        desc: 'Bestia alada con doble ataque. Tier 3. Requiere 150 invocadores.'
      },
      hidra: {
        name: 'Hidra', icon: '🐉', tier: 3,
        attackChance: 12, hp: 180, attacksPerTurn: 3, damage: 20,
        defense: 16, armor: 0, weapon: 0, dexterity: 10,
        speed: 2, capacity: 0,
        summonersNeeded: 150, cost: { esencia: 400 }, time: 3600,
        desc: 'Monstruo de múltiples cabezas. Tier 3. Requiere 150 invocadores.'
      },
      fenix: {
        name: 'Fénix', icon: '🔥', tier: 4,
        attackChance: 16, hp: 200, attacksPerTurn: 2, damage: 45,
        defense: 12, armor: 0, weapon: 0, dexterity: 20,
        speed: 3, capacity: 0,
        summonersNeeded: 400, cost: { esencia: 1000 }, time: 7200, // 120 min
        desc: 'Ave de fuego inmortal. Tier 4. Requiere 400 invocadores.'
      },
      behemot: {
        name: 'Behemot', icon: '🦏', tier: 4,
        attackChance: 10, hp: 350, attacksPerTurn: 1, damage: 55,
        defense: 22, armor: 0, weapon: 0, dexterity: 6,
        speed: 1, capacity: 0,
        summonersNeeded: 400, cost: { esencia: 1000 }, time: 7200,
        desc: 'Coloso imparable. Tier 4. Requiere 400 invocadores.'
      },
      dragon: {
        name: 'Dragón', icon: '🐲', tier: 5,
        attackChance: 18, hp: 500, attacksPerTurn: 3, damage: 80,
        defense: 20, armor: 0, weapon: 0, dexterity: 14,
        speed: 3, capacity: 0,
        summonersNeeded: 1000, cost: { esencia: 2500 }, time: 14400, // 240 min
        desc: 'Dragón antiguo legendario. Tier 5. Requiere 1000 invocadores.'
      },
      arconte: {
        name: 'Arconte', icon: '👼', tier: 5,
        attackChance: 20, hp: 400, attacksPerTurn: 2, damage: 70,
        defense: 25, armor: 0, weapon: 0, dexterity: 18,
        speed: 2, capacity: 0,
        summonersNeeded: 1000, cost: { esencia: 2500 }, time: 14400,
        desc: 'Ser celestial supremo. Tier 5. Requiere 1000 invocadores.'
      }
    };

    // ============================================================
    // SCALING LOGIC
    // ============================================================
    function getTroopStatsWithLevel(type, level) {
      const base = TROOP_TYPES[type];
      if (!base) return null;
      if (!level || level < 1) level = 1;

      // New balanced scaling: ~4% bonus per level for HP/Damage
      // Fixed small increment for Chance/Defense/Dexterity
      const growth = 1 + (level - 1) * 0.04;

      return {
        ...base,
        level: level,
        hp: Math.floor(base.hp * growth),
        damage: Math.floor(base.damage * growth),
        attackChance: base.attackChance + (level - 1) * 0.5,
        defense: base.defense + (level - 1) * 0.5,
        dexterity: base.dexterity + (level - 1) * 0.5,
        // Speed remains constant, capacity scales slowly
        speed: base.speed,
        capacity: base.capacity + (level - 1) * 1
      };
    }

    // ============================================================
    // BUILDINGS — todos empiezan en nivel 1, producen desde nivel 1
    // Coste nivel 0 → 1 es muy barato (casi gratis, es la "mejora inicial")
    // ============================================================
    const BUILDINGS = [
      // ── RECURSOS ─────────────────────────────────────────────
      {
        id: 'aserradero', name: 'Aserradero', icon: '🌲', desc: 'Produce madera por hora. Nivel 1 ya activo desde el inicio.',
        prod: function (l) { return { madera: Math.floor(30 + 40 * l * Math.pow(1.1, l)) }; },
        cost: function (l) {
          return l === 0
            ? { madera: 0, piedra: 0 }
            : { madera: Math.floor(80 * Math.pow(1.5, l)), piedra: Math.floor(20 * Math.pow(1.5, l)) };
        },
        time: function (l) { return l === 0 ? 0 : Math.max(5, Math.floor(10 * (l + 1))); }
      },

      {
        id: 'cantera', name: 'Cantera', icon: '⛰️', desc: 'Produce piedra por hora. Nivel 1 activo desde el inicio.',
        prod: function (l) { return { piedra: Math.floor(20 + 30 * l * Math.pow(1.1, l)) }; },
        cost: function (l) {
          return l === 0
            ? { madera: 0, piedra: 0 }
            : { madera: Math.floor(60 * Math.pow(1.5, l)), piedra: Math.floor(40 * Math.pow(1.5, l)) };
        },
        time: function (l) { return l === 0 ? 0 : Math.max(5, Math.floor(12 * (l + 1))); }
      },

      {
        id: 'minehierro', name: 'Mina de Hierro', icon: '⚒️', desc: 'Produce hierro por hora. Nivel 1 activo desde el inicio.',
        prod: function (l) { return { hierro: Math.floor(10 + 20 * l * Math.pow(1.1, l)) }; },
        cost: function (l) {
          return l === 0
            ? { madera: 0, piedra: 0, hierro: 0 }
            : { madera: Math.floor(100 * Math.pow(1.5, l)), piedra: Math.floor(80 * Math.pow(1.5, l)), hierro: Math.floor(30 * Math.pow(1.5, l)) };
        },
        time: function (l) { return l === 0 ? 0 : Math.max(8, Math.floor(15 * (l + 1))); }
      },

      // ── GRANJA ───────────────────────────────────────────────
      {
        id: 'granja', name: 'Granja', icon: '🌾',
        desc: 'Produce provisiones según los aldeanos asignados. Nivel 1 = 6 provisiones/aldeano/h. Las provisiones se consumen al enviar tropas en misión y no se recuperan al volver.',
        prod: function () { return {}; },
        cost: function (l) {
          return l === 0
            ? { madera: 0, piedra: 0 }
            : { madera: Math.floor(60 * Math.pow(1.5, l)), piedra: Math.floor(40 * Math.pow(1.5, l)) };
        },
        time: function (l) { return l === 0 ? 0 : Math.max(8, Math.floor(10 * (l + 1))); }
      },

      // ── MÁGICO ───────────────────────────────────────────────
      {
        id: 'circulo', name: 'Círculo Místico', icon: '✨', desc: 'Canaliza la Esencia. No ocupa almacén.',
        prod: function (l) { return { esencia: Math.floor(5 + 15 * l * Math.pow(1.1, l)) }; },
        cost: function (l) {
          return l === 0
            ? { madera: 0, piedra: 0, esencia: 0 }
            : { madera: Math.floor(200 * Math.pow(1.8, l)), piedra: Math.floor(200 * Math.pow(1.8, l)), esencia: Math.floor(50 * Math.pow(1.6, l)) };
        },
        time: function (l) { return l === 0 ? 0 : Math.max(20, Math.floor(30 * (l + 1))); }
      },

      // ── ALMACENAMIENTO ───────────────────────────────────────
      {
        id: 'almacen', name: 'Almacén', icon: '🏛️', desc: 'Aumenta la capacidad de almacenamiento de madera, piedra, hierro y provisiones. Nivel 0 = 1.000 unidades, se dobla por nivel. La Esencia tiene límite separado.',
        prod: function () { return {}; },
        cost: function (l) {
          return l === 0
            ? { madera: 0, piedra: 0, hierro: 0 }
            : { madera: Math.floor(300 * Math.pow(2, l)), piedra: Math.floor(300 * Math.pow(2, l)), hierro: Math.floor(150 * Math.pow(2, l)) };
        },
        time: function (l) { return l === 0 ? 0 : Math.max(15, Math.floor(20 * (l + 1))); }
      },

      // ── MILITAR ──────────────────────────────────────────────
      // ── MILITAR ──────────────────────────────────────────────
      {
        id: 'barracas', name: 'Barracas', icon: '🏰',
        desc: 'Capacidad máxima de tropas normales (no criaturas). Nivel 1 = 50 plazas, +20 plazas por nivel. Las tropas en misión no ocupan plaza.',
        prod: function () { return {}; },
        cost: function (l) {
          return l === 0
            ? { madera: 0, piedra: 0, hierro: 0 }
            : { madera: Math.floor(200 * Math.pow(1.8, l)), piedra: Math.floor(300 * Math.pow(1.8, l)), hierro: Math.floor(100 * Math.pow(1.8, l)) };
        },
        time: function (l) { return l === 0 ? 0 : Math.max(15, Math.floor(20 * (l + 1))); }
      },

      {
        id: 'reclutamiento', name: 'Reclutamiento', icon: '⚔️',
        desc: 'Genera aldeanos automáticamente. Nivel 1 = 1 aldeano cada ~5 min. Cada nivel reduce el intervalo un 10%. Los aldeanos se pierden si las Barracas están llenas.',
        prod: function () { return {}; },
        cost: function (l) {
          return l === 0
            ? { madera: 0, piedra: 0, hierro: 0 }
            : { madera: Math.floor(150 * Math.pow(1.8, l)), piedra: Math.floor(100 * Math.pow(1.8, l)), hierro: Math.floor(50 * Math.pow(1.8, l)) };
        },
        time: function (l) { return l === 0 ? 0 : Math.max(10, Math.floor(15 * (l + 1))); }
      },

      {
        id: 'muralla', name: 'Muralla', icon: '🏰',
        desc: 'Escudo de la aldea con HP propio. El atacante debe destruirla antes de dañar a tus tropas. Nivel 1 = 500 HP de muralla, +500 HP por nivel. Nivel 10 = 5.000 HP.',
        prod: function () { return {}; },
        cost: function (l) {
          return l === 0
            ? { piedra: 0, hierro: 0 }
            : { piedra: Math.floor(500 * Math.pow(2, l)), hierro: Math.floor(200 * Math.pow(2, l)) };
        },
        time: function (l) { return l === 0 ? 0 : Math.max(30, Math.floor(40 * (l + 1))); }
      },

      {
        id: 'lab', name: 'Laboratorio', icon: '📜', desc: 'Permite investigar nuevas tecnologías. Módulo en desarrollo — próximamente activo.',
        prod: function () { return {}; },
        cost: function (l) {
          return l === 0
            ? { madera: 0, piedra: 0, esencia: 0 }
            : { madera: Math.floor(200 * Math.pow(2, l)), piedra: Math.floor(400 * Math.pow(2, l)), esencia: Math.floor(100 * Math.pow(2, l)) };
        },
        time: function (l) { return l === 0 ? 0 : Math.max(15, Math.floor(25 * (l + 1))); }
      },
      {
        id: 'cuarteles', name: 'Cuarteles', icon: '🎖️',
        desc: 'Acelera el entrenamiento de tropas (excepto aldeanos y criaturas). Cada nivel reduce un 1% el tiempo de entrenamiento, hasta un máximo del 50% (nivel 50).',
        prod: function () { return {}; },
        cost: function (l) {
          return l === 0
            ? { madera: 0, piedra: 0, hierro: 0 }
            : { madera: Math.floor(250 * Math.pow(1.9, l)), piedra: Math.floor(350 * Math.pow(1.9, l)), hierro: Math.floor(150 * Math.pow(1.9, l)) };
        },
        time: function (l) { return l === 0 ? 0 : Math.max(20, Math.floor(30 * (l + 1))); }
      },

      {
        id: 'torre', name: 'Torre de Vigía', icon: '🗼',
        desc: 'Controla el alcance de tu aldea. Nivel 1 = 5 casillas de alcance, +5 por nivel. Sin Torre no puedes atacar, espiar ni fundar nuevas aldeas.',
        prod: function () { return {}; },
        cost: function (l) {
          return l === 0
            ? { madera: 0, piedra: 0 }
            : { madera: Math.floor(80 * Math.pow(1.9, l)), piedra: Math.floor(160 * Math.pow(1.9, l)) };
        },
        time: function (l) { return l === 0 ? 0 : Math.max(20, Math.floor(30 * (l + 1))); }
      },
      {
        id: 'torreinvocacion', name: 'Torre de Invocación', icon: '🔮',
        desc: 'Desbloquea la invocación de criaturas poderosas. Cada nivel reduce un 5% el tiempo de invocación. Necesitas Invocadores entrenados para invocar criaturas.',
        prod: function () { return {}; },
        cost: function (l) {
          return l === 0
            ? { madera: 0, piedra: 0, esencia: 0 }
            : { madera: Math.floor(200 * Math.pow(2, l)), piedra: Math.floor(300 * Math.pow(2, l)), esencia: Math.floor(100 * Math.pow(2, l)) };
        },
        time: function (l) { return l === 0 ? 0 : Math.max(40, Math.floor(50 * (l + 1))); }
      },
    ];

    // Capacidad barracas — lee el edificio 'barracas'
    // Nivel 1: 50 plazas. +20 por cada nivel adicional.
    function getCuartelesReduction(blds) {
      // Each level of Cuarteles = 1% faster training (max 50%)
      var lvl = (blds && blds['cuarteles'] && blds['cuarteles'].level) || 0;
      return Math.min(0.5, lvl * 0.01);
    }

    function getBarracksCapacity(blds) {
      var lvl = (blds['barracas'] && blds['barracas'].level) || 0;
      if (lvl === 0) return 0;
      return 50 + (lvl - 1) * 20; // nivel 1=50, nivel 2=70, nivel 3=90...
    }

    // ============================================================
    // BARRACAS — fuente de verdad para plazas ocupadas
    // Regla: plazas = aldeanos + tropas_militares - tropas_en_mision
    // Las tropas en misión (ataque, espionaje, movimiento) NO ocupan plaza.
    // ============================================================
    function getBarracksUsed(vs) {
      if (!vs) return 0;
      var troops  = vs.troops  || {};
      var missions = vs.mission_queue || [];

      // Contar tropas actualmente EN MISIÓN (tipo attack, spy, o move/return saliente)
      var inMission = {};
      missions.forEach(function(m) {
        if (!m.troops) return;
        // Las misiones 'return' ya vienen hacia casa — aún están fuera, no ocupan plaza
        Object.keys(m.troops).forEach(function(k) {
          inMission[k] = (inMission[k] || 0) + (m.troops[k] || 0);
        });
      });

      var used = 0;
      // troops.aldeano = TOTAL de aldeanos en base (libres + trabajando).
      // Los trabajadores (aldeanos_assigned) son un SUBCONJUNTO de troops.aldeano, NO se suman aparte.
      var aldInBase = Math.max(0, (troops.aldeano || 0) - (inMission.aldeano || 0));
      used += aldInBase;

      // Tropas militares que NO son aldeano
      Object.keys(TROOP_TYPES).forEach(function(k) {
        if (k === 'aldeano') return;
        var inBase = Math.max(0, (troops[k] || 0) - (inMission[k] || 0));
        used += inBase * (TROOP_TYPES[k].barracasSlots || 1);
      });

      return used;
    }

    // Tasa de producción de aldeanos/hora — edificio 'reclutamiento'
    function getAldeanosProd(blds) {
      // LEGACY: devuelve 0 — la producción de aldeanos ahora es discreta (ver calcAldeanosTick)
      return 0;
    }

    // Minutos entre un aldeano y el siguiente según nivel del edificio reclutamiento
    // Nivel 1 = 5 min. Cada nivel reduce un 10%: lvl2=4.5, lvl3=4.05...
    function getAldeanosIntervalMs(blds) {
      var lvl = (blds['reclutamiento'] && blds['reclutamiento'].level) || 0;
      if (lvl === 0) return Infinity; // sin reclutamiento = sin producción
      var baseMin = 5;
      var mins = baseMin * Math.pow(0.9, lvl - 1);
      return Math.round(mins * 60 * 1000); // en milisegundos
    }

    // Calcula cuántos aldeanos se han producido desde last_aldeano_at
    // y actualiza el estado. Llamar antes de cualquier acción que use aldeanos.
    // Regla: si barracas llenas → aldeanos producidos se pierden (producción no se pausa).
    function calcAndApplyAldeanos(vs) {
      var barrCap = getBarracksCapacity(vs.buildings);
      if (!vs.troops) vs.troops = {};

      var intervalMs = getAldeanosIntervalMs(vs.buildings);
      if (intervalMs === Infinity) return;

      var now = Date.now();
      var lastAld = vs.last_aldeano_at ? new Date(vs.last_aldeano_at).getTime() : now;
      var elapsed = now - lastAld;

      var newAldeanos = Math.floor(elapsed / intervalMs);
      if (newAldeanos <= 0) return;

      // Siempre avanzar el timer — la producción no se pausa aunque se pierdan aldeanos
      var remainder = elapsed - (newAldeanos * intervalMs);
      vs.last_aldeano_at = new Date(now - remainder).toISOString();

      // Calcular espacio disponible usando la fuente de verdad
      var used = getBarracksUsed(vs);
      var free = Math.max(0, barrCap - used);

      if (free <= 0) return; // barracas llenas — aldeanos producidos se pierden en silencio

      // Solo añadir los que caben
      var toAdd = Math.min(newAldeanos, free);
      vs.troops.aldeano = (vs.troops.aldeano || 0) + toAdd;
    }

    // Provisiones por aldeano en granja: base 5 + nivel granja (nivel 1 = 6/h por aldeano)

    // Capacidad del almacen: nivel 0 = 1000, se dobla cada nivel
    function getCapacity(blds) {
      var lvl = (blds['almacen'] && blds['almacen'].level) || 0;
      return Math.floor(1000 * Math.pow(2, lvl));
    }

    // Recursos que cuentan para el almacen
    function getStoredTotal(res) {
      return (res.madera || 0) + (res.piedra || 0) + (res.hierro || 0) + (res.provisiones || 0);
    }

    // ============================================================
    // TROPAS
    // ============================================================
    function renderTroops() {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      var res = calcRes(vs);
      var w = vs.aldeanos_assigned || defaultAssignments();
      var range = getTorreRange(vs.buildings);
      var lvl = (vs.buildings.torre && vs.buildings.torre.level) || 0;

      renderTrainingQueue();
      renderTrainOptions();

      var box = document.getElementById('troopsListBox');
      if (!box) return;

      var troops = vs.troops || defaultTroops();
      var barrCap = getBarracksCapacity(vs.buildings);

      var usedSlots = getBarracksUsed(vs);
      // Tropas militares (no aldeanos) para mostrar en desglose
      var usedTroopSlots = 0;
      Object.keys(TROOP_TYPES).forEach(function (k) {
        if (k === 'aldeano') return;
        usedTroopSlots += (troops[k] || 0) * (TROOP_TYPES[k].barracasSlots || 1);
      });

      var aldWorking = res.aldeanos_working || 0;
      var aldTotal = res.aldeanos_total || 0;

      var html = '<div style="display:flex;justify-content:space-between;align-items:center;padding:8px 0 12px;border-bottom:2px solid var(--border);margin-bottom:8px;">'
        + '<span style="font-size:.75rem;color:var(--dim);">PLAZAS OCUPADAS</span>'
        + '<span style="font-size:.85rem;color:var(--accent);"><b>' + usedSlots + '</b> / ' + barrCap + '</span>'
        + '</div>'
        + '<div style="background:var(--panel2);border:1px solid var(--border);border-radius:6px;padding:8px 12px;margin-bottom:10px;font-size:.72rem;">'
        + '<div style="display:flex;justify-content:space-between;margin-bottom:6px;">'
        + '<span style="color:var(--dim)">👤 Aldeanos</span>'
        + '<span style="color:var(--aldeanos);font-size:.85rem;"><b>' + aldTotal + '</b></span>'
        + '</div>'
        + '<div style="display:flex;justify-content:space-between;">'
        + '<span style="color:var(--dim)">⚔️ Tropas militares (plazas)</span>'
        + '<span style="color:var(--text)">' + usedTroopSlots + '</span>'
        + '</div>'
        + '</div>'
        + '<div style="margin-bottom:4px;"></div>';

      // troopsListBox ya no se usa — la lista está integrada en renderTrainOptions
      box.innerHTML = '';
    }

    // ============================================================
    // CREATURES UI RENDERING
    // ============================================================
    
    function renderCreatures() {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      
      // Torre de Invocación info
      var torreLevel = (vs.buildings.torreinvocacion && vs.buildings.torreinvocacion.level) || 0;
      var torreInfo = document.getElementById('torreInvocacionInfo');
      if (torreInfo) {
        if (torreLevel === 0) {
          torreInfo.innerHTML = '<span style="color:var(--danger);">⚠️ Torre de Invocación no construida</span>';
        } else {
          var reduction = torreLevel * 5;
          torreInfo.innerHTML = 'Nivel ' + torreLevel + ' • <span style="color:var(--ok);">-' + reduction + '% tiempo de invocación</span>';
        }
      }
      
      // Cola de invocación
      renderSummoningQueue();
      
      // Lista de criaturas actuales
      renderCreaturesList();
      
      // Botones de invocación
      renderSummonOptions();
    }
    
    function renderSummoningQueue() {
      var box = document.getElementById('summoningQueueBox');
      if (!box || !activeVillage) return;
      
      var vs = activeVillage.state;
      var queue = vs.summoning_queue || [];
      
      if (queue.length === 0) {
        box.innerHTML = '<div style="color:var(--dim);font-size:.8rem;">No hay invocaciones en curso</div>';
        return;
      }
      
      var html = '';
      var now = Date.now();

      // First item: active with progress bar
      var active = queue[0];
      var cData = CREATURE_TYPES[active.creature];
      if (cData) {
        var finish = new Date(active.finish_at).getTime();
        var timeLeft = Math.max(0, Math.ceil((finish - now) / 1000));
        var start = new Date(active.start_at).getTime();
        var total = Math.max(1, (finish - start) / 1000);
        var pct = Math.min(100, Math.round(((total - timeLeft) / total) * 100));
        var paused = active.paused;
        if (paused) pct = 0;

        html += '<div style="background:var(--panel2);padding:8px 10px;border-radius:6px;margin-bottom:8px;">';
        html += '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:5px;">';
        html += '<span style="font-size:.9rem;">' + cData.icon + ' ' + cData.name + '</span>';
        html += '<span style="font-size:.75rem;color:var(--ok);">' + fmtTime(timeLeft) + '</span>';
        html += '</div>';
        html += '<div style="background:var(--bg);height:7px;border-radius:4px;overflow:hidden;">';
        html += '<div style="width:' + pct + '%;height:100%;background:var(--ok);transition:width 1s linear;"></div>';
        html += '</div>';
        if (paused) {
          var inv = vs.troops.invocador || 0;
          html += '<div style="color:var(--danger);font-size:.68rem;margin-top:4px;">⚠️ PAUSADA — Faltan ' + (active.summonersNeeded - inv) + ' invocadores</div>';
        }
        html += '</div>';
      }

      // Remaining items: grouped by creature type, just count
      if (queue.length > 1) {
        var waiting = queue.slice(1);
        // Count by type
        var counts = {};
        waiting.forEach(function(s) {
          counts[s.creature] = (counts[s.creature] || 0) + 1;
        });
        var lastFinishQ = new Date(queue[queue.length-1].finish_at);
        var lastStrQ = lastFinishQ.toLocaleTimeString('es-ES', { hour:'2-digit', minute:'2-digit', second:'2-digit' });
        var totalLeft = Math.max(0, Math.ceil((lastFinishQ.getTime() - Date.now()) / 1000));
        html += '<div style="background:var(--panel2);padding:7px 10px;border-radius:6px;">';
        html += '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:5px;">';
        html += '<div style="font-size:.68rem;color:var(--dim);letter-spacing:.08em;">EN ESPERA</div>';
        html += '<div style="font-size:.63rem;color:var(--dim);">Cola completa: <span style="color:var(--accent);">' + fmtTime(totalLeft) + '</span> · <b>' + lastStrQ + '</b></div>';
        html += '</div>';
        html += '<div style="display:flex;flex-wrap:wrap;gap:6px;">';
        Object.keys(counts).forEach(function(key) {
          var cd = CREATURE_TYPES[key];
          if (!cd) return;
          html += '<div style="display:flex;align-items:center;gap:4px;background:var(--bg);padding:3px 8px;border-radius:4px;font-size:.78rem;">';
          html += cd.icon + ' ' + cd.name + ' <span style="color:var(--ok);font-weight:bold;margin-left:2px;">×' + counts[key] + '</span>';
          html += '</div>';
        });
        html += '</div></div>';
      }
      
      box.innerHTML = html;
    }
    
    function renderCreaturesList() {
      var box = document.getElementById('creaturesListBox');
      if (!box || !activeVillage) return;
      
      var vs = activeVillage.state;
      var creatures = vs.creatures || defaultCreatures();
      
      var hasAny = false;
      var html = '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(140px,1fr));gap:8px;">';
      
      Object.keys(CREATURE_TYPES).forEach(function(key) {
        var count = creatures[key] || 0;
        if (count === 0) return;
        hasAny = true;
        
        var cData = CREATURE_TYPES[key];
        html += '<div style="background:var(--panel2);padding:10px;border-radius:6px;text-align:center;">';
        html += '<div style="font-size:2rem;">' + cData.icon + '</div>';
        html += '<div style="font-size:.75rem;margin-top:4px;">' + cData.name + '</div>';
        html += '<div style="font-size:1.2rem;color:var(--ok);font-weight:bold;margin-top:4px;">' + count + '</div>';
        html += '</div>';
      });
      
      html += '</div>';
      
      if (!hasAny) {
        box.innerHTML = '<div style="color:var(--dim);font-size:.8rem;">No tienes criaturas invocadas</div>';
      } else {
        box.innerHTML = html;
      }
    }
    
    function showCreatureStats(key) {
      var c = CREATURE_TYPES[key];
      if (!c) return;
      var existing = document.getElementById('creatureStatsModal');
      if (existing) existing.remove();
      var overlay = document.createElement('div');
      overlay.id = 'creatureStatsModal';
      overlay.style.cssText = 'position:fixed;inset:0;z-index:9999;background:rgba(0,0,0,.75);display:flex;align-items:center;justify-content:center;';
      overlay.onclick = function(e){ if(e.target===overlay) overlay.remove(); };
      window._closeCreatureStats = function(){ var m=document.getElementById('creatureStatsModal'); if(m) m.remove(); };
      overlay.innerHTML = '<div style="background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:20px;max-width:340px;width:90%;font-family:VT323,monospace;">'
        + '<div style="display:flex;align-items:center;gap:10px;margin-bottom:14px;border-bottom:1px solid var(--border);padding-bottom:10px;">'
        + '<span style="font-size:2.5rem;">' + c.icon + '</span>'
        + '<div><div style="font-size:1.2rem;color:var(--accent);">' + c.name + '</div>'
        + '<div style="font-size:.7rem;color:var(--esencia);">TIER ' + c.tier + ' — ' + (c.type||'criatura') + '</div></div>'
        + '<button onclick="_closeCreatureStats()" style="margin-left:auto;background:none;border:none;color:var(--dim);font-size:1.2rem;cursor:pointer;">✕</button>'
        + '</div>'
        + '<div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;font-size:.82rem;margin-bottom:14px;">'
        + '<div style="color:var(--dim);">❤️ HP</div><div style="color:var(--text);">' + c.hp + '</div>'
        + '<div style="color:var(--dim);">⚔️ Daño</div><div style="color:var(--text);">' + c.damage + '</div>'
        + '<div style="color:var(--dim);">🛡️ Defensa</div><div style="color:var(--text);">' + c.defense + '</div>'
        + '<div style="color:var(--dim);">⚡ Ataques/turno</div><div style="color:var(--text);">' + c.attacksPerTurn + '</div>'
        + '<div style="color:var(--dim);">🎯 Precisión</div><div style="color:var(--text);">' + c.attackChance + '</div>'
        + '<div style="color:var(--dim);">🏃 Velocidad</div><div style="color:var(--text);">' + c.speed + '</div>'
        + '</div>'
        + '<div style="font-size:.72rem;color:var(--dim);border-top:1px solid var(--border);padding-top:10px;margin-bottom:14px;">' + escapeHtml(c.desc) + '</div>'
        + '<div style="font-size:.75rem;background:var(--panel2);border-radius:6px;padding:8px;display:grid;grid-template-columns:1fr 1fr 1fr;gap:4px;text-align:center;">'
        + '<div><div style="color:var(--dim);">Invocadores</div><div style="color:var(--esencia);">' + c.summonersNeeded + '</div></div>'
        + '<div><div style="color:var(--dim);">Esencia</div><div style="color:var(--esencia);">✨ ' + c.cost.esencia + '</div></div>'
        + '<div><div style="color:var(--dim);">Tiempo</div><div style="color:var(--gold);">⏱ ' + Math.floor(c.time/60) + 'min</div></div>'
        + '</div>'
        + '</div>';
      document.body.appendChild(overlay);
    }

    function renderSummonOptions() {
      var box = document.getElementById('summonBox');
      if (!box || !activeVillage) return;
      
      var vs = activeVillage.state;
      var torreLevel = (vs.buildings.torreinvocacion && vs.buildings.torreinvocacion.level) || 0;
      
      if (torreLevel === 0) {
        box.innerHTML = '<div style="color:var(--danger);font-size:.85rem;">⚠️ Construye la Torre de Invocación primero</div>';
        return;
      }
      
      var invocadorLevel = getTroopLevel('invocador');
      var invocadoresActuales = vs.troops.invocador || 0;
      
      var html = '<div style="display:grid;gap:10px;">';
      
      // Group by tier
      var tiers = {};
      Object.keys(CREATURE_TYPES).forEach(function(key) {
        var cData = CREATURE_TYPES[key];
        if (!tiers[cData.tier]) tiers[cData.tier] = [];
        tiers[cData.tier].push({ key: key, data: cData });
      });
      
      Object.keys(tiers).sort().forEach(function(tier) {
        var tierInt = parseInt(tier);
        // VISIBLE si el nivel de la Torre de Invocación >= tier
        // INVOCABLE solo si además tienes los invocadores necesarios
        var visible = torreLevel >= tierInt;
        var unlocked = invocadorLevel >= tierInt;
        
        // Ocultar solo si la torre no tiene nivel suficiente
        if (!visible) return;

        html += '<div style="background:var(--panel2);padding:10px;border-radius:6px;">';
        html += '<div style="font-size:.75rem;color:var(--dim);letter-spacing:.1em;margin-bottom:8px;">TIER ' + tier + '</div>';
        
        tiers[tier].forEach(function(c) {
          var canSummonResult = canSummon(c.key, vs);
          var isOk = canSummonResult.ok;
          
          html += '<div style="display:flex;align-items:center;gap:8px;padding:8px;background:var(--bg);border-radius:4px;margin-bottom:6px;' + (!unlocked ? 'opacity:.5;filter:grayscale(.4);' : (!isOk ? 'opacity:.7;' : '')) + '">';
          // Icon clickable for stats
          html += '<button onclick="showCreatureStats(\'' + c.key + '\')" title="Ver estadísticas" style="background:none;border:none;cursor:pointer;font-size:1.8rem;padding:0;line-height:1;flex-shrink:0;">' + c.data.icon + '</button>';
          html += '<div style="flex:1;min-width:0;">';
          html += '<div style="font-size:.85rem;color:var(--text);">' + c.data.name + '</div>';
          html += '<div style="font-size:.68rem;color:var(--dim);margin-top:2px;">';
          html += '🧙‍♂️ ' + c.data.summonersNeeded + ' · ✨ ' + c.data.cost.esencia + ' · ⏱ ' + Math.floor(c.data.time/60) + 'min';
          html += '</div>';
          if (!unlocked) {
            html += '<div style="font-size:.63rem;color:var(--dim);margin-top:2px;">🔒 Requiere invocadores de nivel ' + tierInt + ' para invocar</div>';
          } else if (!isOk) {
            html += '<div style="font-size:.63rem;color:var(--danger);margin-top:2px;">' + escapeHtml(canSummonResult.reason) + '</div>';
          }
          html += '</div>';
          // Quantity input + button
          html += '<div style="display:flex;align-items:center;gap:4px;flex-shrink:0;">';
          html += '<input id="summonQty_' + c.key + '" type="number" value="1" min="1" max="99" style="width:46px;background:rgba(255,255,255,.06);border:1px solid var(--border);border-radius:4px;padding:4px 6px;color:var(--text);font-family:VT323,monospace;font-size:.85rem;text-align:center;">';
          html += '<button onclick="startSummoningFromInput(\'' + c.key + '\')" ' + (!isOk ? 'disabled' : '') + ' style="background:' + (isOk ? 'var(--ok)' : 'var(--border)') + ';border:none;color:white;padding:5px 10px;border-radius:4px;cursor:' + (isOk ? 'pointer' : 'default') + ';font-size:.75rem;white-space:nowrap;">+ Cola</button>';
          html += '</div>';
          html += '</div>';
        });
        
        html += '</div>';
      });
      
      html += '</div>';
      box.innerHTML = html;
    }


    function showBarracasModal() {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      var res = calcRes(vs);
      var barrCap = getBarracksCapacity(vs.buildings);
      var usedSlots = getBarracksUsed(vs);

      var html = '<div class="bld-modal-overlay" id="barrOverlay" onclick="if(event.target.id===\'barrOverlay\') this.remove()">'
        + '<div class="bld-modal" style="max-width:800px;">'
        + '<div class="bld-modal-head">'
        + '<div class="bld-modal-icon">🏰</div>'
        + '<div><div class="bld-modal-title">BARRACAS</div>'
        + '<div class="bld-modal-sub">Recluta tropas para tu ejército. Plazas: ' + usedSlots + ' / ' + barrCap + '</div></div>'
        + '<button class="bld-modal-close" onclick="this.closest(\'.bld-modal-overlay\').remove()">&#x2715;</button>'
        + '</div>'
        + '<div class="bld-modal-body" style="display:grid;grid-template-columns:repeat(auto-fill, minmax(240px, 1fr));gap:15px;padding:20px;">';

      Object.keys(TROOP_TYPES).forEach(function (key) {
        var stats = getTroopStatsWithLevel(key, 1);
        var cost = stats.cost || {};
        html += '<div style="background:var(--panel2);border:1px solid var(--border);border-radius:8px;padding:12px;display:flex;flex-direction:column;gap:8px;">'
          + '<div style="display:flex;align-items:center;gap:10px;">'
          + '<span style="font-size:1.8rem;">' + stats.icon + '</span>'
          + '<div style="flex:1;">'
          + '<div style="font-size:.9rem;font-weight:700;">' + stats.name + '</div>'
          + '<div style="font-size:.65rem;color:var(--dim);">' + stats.desc + '</div>'
          + '</div>'
          + '</div>'
          + '<div style="display:flex;gap:10px;font-size:.75rem;flex-wrap:wrap;color:var(--accent);">';
        if (cost.madera) html += '<span>🌲 ' + cost.madera + '</span>';
        if (cost.hierro) html += '<span>⚙️ ' + cost.hierro + '</span>';
        if (cost.prov) html += '<span>🌾 ' + cost.prov + '</span>';
        if (cost.esencia) html += '<span>✨ ' + cost.esencia + '</span>';
        html += '</div>'
          + '<div style="display:flex;gap:6px;margin-top:4px;">'
          + '<input type="number" id="recAmount-' + key + '" value="1" min="1" class="input" style="flex:1;padding:4px 8px;font-size:.8rem;">'
          + '<button class="btn" style="padding:6px 12px;font-size:.75rem;" onclick="startRecruitment(\'' + key + '\')">Reclutar</button>'
          + '</div>'
          + '</div>';
      });

      html += '</div></div></div>';
      var mod = document.createElement('div');
      mod.innerHTML = html;
      document.body.appendChild(mod.firstChild);
    }

    function startRecruitmentFromInput(type) {
      var input = document.getElementById('trainQty_' + type);
      var amount = input ? (parseInt(input.value) || 1) : 1;
      startRecruitment(type, amount);
    }

    function startRecruitment(type, amount) {
      if (!activeVillage) return;
      if (!amount || amount <= 0) return;

      var vs = activeVillage.state;
      var res = calcRes(vs);
      var stats = getTroopStatsWithLevel(type, 1);
      var costTotal = {};
      Object.keys(stats.cost).forEach(k => costTotal[k] = stats.cost[k] * amount);

      if (!canAfford(costTotal, res)) { showNotif('No tienes recursos suficientes.', 'err'); return; }

      var barrCap = getBarracksCapacity(vs.buildings);
      var usedSlots = getBarracksUsed(vs);
      var slotsFreed  = amount * 1;
      var slotsNeeded = amount * (stats.barracasSlots || 1);
      if (usedSlots - slotsFreed + slotsNeeded > barrCap) {
        showNotif('No hay espacio suficiente en las barracas.', 'err'); return;
      }

      var resNow = calcRes(vs);
      var aldLibres = resNow.aldeanos_libres || 0;
      if (aldLibres < amount) {
        showNotif('Necesitas ' + amount + ' aldeanos LIBRES. Tienes ' + aldLibres + '.', 'err'); return;
      }

      snapshotResources(vs);

      // Descontar recursos y aldeanos INMEDIATAMENTE
      Object.keys(costTotal).forEach(k => {
        if (k === 'prov') vs.resources.provisiones = Math.max(0, vs.resources.provisiones - costTotal[k]);
        else if (vs.resources[k] !== undefined) vs.resources[k] = Math.max(0, vs.resources[k] - costTotal[k]);
      });
      if (!vs.troops) vs.troops = {};
      consumeAldeanos(vs, amount); // resta proporcional de recolectores si hace falta

      // Encolar entrenamiento (secuencial, como criaturas)
      if (!vs.training_queue) vs.training_queue = [];
      var cuartRed = getCuartelesReduction(vs.buildings);
      var baseTime = stats.time || 180;
      var finalTime = Math.max(30, Math.floor(baseTime * (1 - cuartRed)));

      for (var i = 0; i < amount; i++) {
        var lastFinish = Date.now();
        if (vs.training_queue.length > 0) {
          lastFinish = Math.max(lastFinish, new Date(vs.training_queue[vs.training_queue.length - 1].finish_at).getTime());
        }
        vs.training_queue.push({
          type: type,
          finish_at: new Date(lastFinish + finalTime * 1000).toISOString(),
          start_at: new Date(lastFinish).toISOString()
        });
      }

      showNotif(amount + ' ' + stats.name + ' en cola de entrenamiento', 'ok');
      flushVillage();
      tick();
      renderTroops();
    }

    function showTroopStats(key) {
      var t = TROOP_TYPES[key];
      if (!t) return;
      var existing = document.getElementById('troopStatsModal');
      if (existing) existing.remove();
      window._closeTroopStats = function(){ var m=document.getElementById('troopStatsModal'); if(m) m.remove(); };
      var overlay = document.createElement('div');
      overlay.id = 'troopStatsModal';
      overlay.style.cssText = 'position:fixed;inset:0;z-index:9999;background:rgba(0,0,0,.75);display:flex;align-items:center;justify-content:center;';
      overlay.onclick = function(e){ if(e.target===overlay) overlay.remove(); };
      overlay.innerHTML = '<div style="background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:20px;max-width:340px;width:90%;font-family:VT323,monospace;">'
        + '<div style="display:flex;align-items:center;gap:10px;margin-bottom:14px;border-bottom:1px solid var(--border);padding-bottom:10px;">'
        + '<span style="font-size:2.5rem;">' + t.icon + '</span>'
        + '<div><div style="font-size:1.2rem;color:var(--accent);">' + t.name + '</div>'
        + '<div style="font-size:.7rem;color:var(--dim);">Tropa normal · 1 plaza barracas</div></div>'
        + '<button onclick="_closeTroopStats()" style="margin-left:auto;background:none;border:none;color:var(--dim);font-size:1.2rem;cursor:pointer;">✕</button>'
        + '</div>'
        + '<div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;font-size:.82rem;margin-bottom:14px;">'
        + '<div style="color:var(--dim);">❤️ HP</div><div style="color:var(--text);">' + t.hp + '</div>'
        + '<div style="color:var(--dim);">⚔️ Daño</div><div style="color:var(--text);">' + t.damage + '</div>'
        + '<div style="color:var(--dim);">🛡️ Defensa</div><div style="color:var(--text);">' + t.defense + '</div>'
        + '<div style="color:var(--dim);">⚡ Ataques/turno</div><div style="color:var(--text);">' + t.attacksPerTurn + '</div>'
        + '<div style="color:var(--dim);">🎯 % Acierto</div><div style="color:var(--text);">' + t.attackChance + '/20</div>'
        + '<div style="color:var(--dim);">🏃 Velocidad</div><div style="color:var(--text);">' + t.speed + '</div>'
        + '<div style="color:var(--dim);">🗡️ Arma base</div><div style="color:var(--text);">' + t.weapon + '</div>'
        + '<div style="color:var(--dim);">🛡 Armadura base</div><div style="color:var(--text);">' + t.armor + '</div>'
        + '<div style="color:var(--dim);">📦 Capacidad carga</div><div style="color:var(--text);">' + t.capacity + '</div>'
        + '</div>'
        + '<div style="font-size:.72rem;color:var(--dim);border-top:1px solid var(--border);padding-top:10px;margin-bottom:14px;">' + escapeHtml(t.desc) + '</div>'
        + '<div style="font-size:.75rem;background:var(--panel2);border-radius:6px;padding:8px;display:grid;grid-template-columns:1fr 1fr 1fr;gap:4px;text-align:center;">'
        + '<div><div style="color:var(--dim);">1 Aldeano</div><div style="color:var(--aldeanos);">👤 ×1</div></div>'
        + '<div><div style="color:var(--dim);">Tiempo</div><div style="color:var(--gold);">⏱ ' + Math.floor((t.time||180)/60) + 'min</div></div>'
        + '<div><div style="color:var(--dim);">Plazas</div><div style="color:var(--accent);">🏠 ' + (t.barracasSlots||1) + '</div></div>'
        + '</div>'
        + '</div>';
      document.body.appendChild(overlay);
    }

    function renderTrainOptions() {
      var box = document.getElementById('trainOptionsBox');
      if (!box || !activeVillage) return;
      var vs = activeVillage.state;
      var troops = vs.troops || {};
      var res = calcRes(vs);
      var cuartLvl = (vs.buildings.cuarteles && vs.buildings.cuarteles.level) || 0;
      var cuartRed = getCuartelesReduction(vs.buildings);
      var aldLibres = res.aldeanos_libres || 0;
      var aldTotal = res.aldeanos_total || 0;
      var barrCap = getBarracksCapacity(vs.buildings);
      var usedSlots = getBarracksUsed(vs);
      var barrLvl = (vs.buildings.barracas && vs.buildings.barracas.level) || 0;

      var html = '';

      // Cabecera plazas + cuarteles
      html += '<div style="display:flex;justify-content:space-between;align-items:center;padding:4px 0 10px;border-bottom:1px solid var(--border);margin-bottom:10px;">';
      html += '<span style="font-size:.78rem;color:var(--dim);letter-spacing:.08em;">PLAZAS OCUPADAS</span>';
      html += '<span style="font-size:1rem;color:var(--accent);font-family:VT323,monospace;"><b>' + usedSlots + '</b> / ' + barrCap + '</span>';
      html += '</div>';
      if (cuartLvl > 0) {
        html += '<div style="font-size:.72rem;color:var(--ok);margin-bottom:10px;">🎖️ Cuarteles Niv.' + cuartLvl + ' → -' + Math.round(cuartRed*100) + '% entrenamiento</div>';
      }

      html += '<div style="display:grid;gap:7px;">';

      // ── Aldeano: tropa base, sin botón entrenar ──
      var ald = TROOP_TYPES['aldeano'];
      html += '<div style="display:flex;align-items:center;gap:12px;padding:11px 14px;background:var(--panel2);border-radius:7px;border:1px solid rgba(255,221,96,.18);">';
      html += '<button onclick="showTroopStats(\'aldeano\')" title="Ver estadísticas" style="background:none;border:none;cursor:pointer;font-size:2.2rem;padding:0;line-height:1;flex-shrink:0;">' + ald.icon + '</button>';
      html += '<div style="flex:1;min-width:0;">';
      html += '<div style="font-size:1.1rem;color:var(--aldeanos);font-family:VT323,monospace;">' + ald.name + '</div>';
      html += '<div style="font-size:.72rem;color:var(--dim);margin-top:2px;">Tropa base · Se generan automáticamente · <span style="color:var(--aldeanos);">' + aldLibres + ' libres</span></div>';
      html += '</div>';
      html += '<div style="font-size:1.8rem;color:var(--aldeanos);font-family:VT323,monospace;font-weight:bold;flex-shrink:0;">' + aldTotal + '</div>';
      html += '</div>';

      if (barrLvl === 0) {
        html += '<div style="color:var(--danger);font-size:.85rem;padding:8px 0;">⚠️ Construye las Barracas para entrenar tropas militares</div>';
        html += '</div>';
        box.innerHTML = html;
        return;
      }

      // ── Tropas militares ──
      Object.keys(TROOP_TYPES).forEach(function(key) {
        if (key === 'aldeano') return;
        var t = TROOP_TYPES[key];
        var count = troops[key] || 0;
        var baseTime = t.time || 180;
        var finalTime = Math.max(30, Math.floor(baseTime * (1 - cuartRed)));
        var mins = Math.floor(finalTime / 60);
        var secs = finalTime % 60;
        var timeStr = mins + 'min' + (secs ? ' ' + secs + 's' : '');
        var costPerUnit = t.cost || {};
        var canAffordOne = canAfford(costPerUnit, res);
        var hasAldeano = aldLibres >= 1;
        var canTrain = canAffordOne && hasAldeano;
        var costStr = '';
        if (costPerUnit.hierro) costStr += '⚙️' + costPerUnit.hierro + ' ';
        if (costPerUnit.madera) costStr += '🌲' + costPerUnit.madera + ' ';
        if (costPerUnit.piedra) costStr += '⛰️' + costPerUnit.piedra + ' ';
        if (costPerUnit.esencia) costStr += '✨' + costPerUnit.esencia + ' ';
        if (costPerUnit.prov) costStr += '🌾' + costPerUnit.prov + ' ';

        html += '<div style="display:flex;align-items:center;gap:12px;padding:11px 14px;background:var(--panel2);border-radius:7px;border:1px solid ' + (canTrain ? 'rgba(255,255,255,.07)' : 'rgba(255,255,255,.02)') + ';' + (!canTrain ? 'opacity:.6;' : '') + '">';
        // Icono clickable para stats
        html += '<button onclick="showTroopStats(\'' + key + '\')" title="Ver estadísticas" style="background:none;border:none;cursor:pointer;font-size:2.2rem;padding:0;line-height:1;flex-shrink:0;">' + t.icon + '</button>';
        // Info centro
        html += '<div style="flex:1;min-width:0;">';
        html += '<div style="font-size:1.1rem;color:var(--text);font-family:VT323,monospace;">' + t.name + '</div>';
        html += '<div style="font-size:.72rem;color:var(--dim);margin-top:2px;">👤×1 · ' + (costStr.trim() || '—') + ' · ⏱ ' + timeStr + '</div>';
        if (!hasAldeano) html += '<div style="font-size:.68rem;color:var(--danger);margin-top:2px;">Sin aldeanos libres</div>';
        else if (!canAffordOne) html += '<div style="font-size:.68rem;color:var(--danger);margin-top:2px;">Sin recursos suficientes</div>';
        html += '</div>';
        // Cantidad en base
        html += '<div style="text-align:right;flex-shrink:0;margin-right:10px;min-width:36px;">';
        html += '<div style="font-size:1.8rem;color:' + (count > 0 ? 'var(--accent)' : 'var(--dim)') + ';font-family:VT323,monospace;line-height:1;">' + count + '</div>';
        html += '<div style="font-size:.6rem;color:var(--dim);">en base</div>';
        html += '</div>';
        // Input + botón
        html += '<div style="display:flex;align-items:center;gap:5px;flex-shrink:0;">';
        html += '<input id="trainQty_' + key + '" type="number" value="1" min="1" max="99" style="width:48px;background:rgba(255,255,255,.06);border:1px solid var(--border);border-radius:5px;padding:5px 6px;color:var(--text);font-family:VT323,monospace;font-size:1rem;text-align:center;">';
        html += '<button onclick="startRecruitmentFromInput(\'' + key + '\')" ' + (!canTrain ? 'disabled' : '') + ' style="background:' + (canTrain ? 'var(--accent)' : 'var(--border)') + ';border:none;color:' + (canTrain ? 'var(--bg)' : 'var(--dim)') + ';padding:6px 13px;border-radius:5px;cursor:' + (canTrain ? 'pointer' : 'default') + ';font-family:VT323,monospace;font-size:1rem;white-space:nowrap;font-weight:bold;">+ Cola</button>';
        html += '</div>';
        html += '</div>';
      });

      html += '</div>';
      box.innerHTML = html;
    }

    function resolveTrainingQueue(vs) {
      if (!vs.training_queue || vs.training_queue.length === 0) return vs;
      var now = Date.now();
      var remaining = [];
      var changed = false;
      for (var t of vs.training_queue) {
        var finishTime = new Date(t.finish_at).getTime();
        if (finishTime <= now) {
          // Tropa lista — añadir
          if (!vs.troops) vs.troops = {};
          vs.troops[t.type] = (vs.troops[t.type] || 0) + 1;
          changed = true;
        } else {
          remaining.push(t);
        }
      }
      vs.training_queue = remaining;
      return vs;
    }

    function renderTrainingQueue() {
      var box = document.getElementById('trainingQueueBox');
      if (!box || !activeVillage) return;
      var vs = activeVillage.state;
      var queue = vs.training_queue || [];
      if (queue.length === 0) {
        box.innerHTML = '<div style="color:var(--dim);font-size:.8rem;">No hay tropas en entrenamiento</div>';
        return;
      }
      var now = Date.now();
      var html = '';

      // Tiempo total de TODA la cola — siempre del último elemento
      var lastFinish = new Date(queue[queue.length - 1].finish_at);
      var lastStr = lastFinish.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
      var totalSecsLeft = Math.max(0, Math.ceil((lastFinish.getTime() - now) / 1000));

      // First active
      var active = queue[0];
      var tStats = TROOP_TYPES[active.type];
      if (tStats) {
        var finish = new Date(active.finish_at).getTime();
        var timeLeft = Math.max(0, Math.ceil((finish - now) / 1000));
        var start = new Date(active.start_at).getTime();
        var total = Math.max(1, (finish - start) / 1000);
        var pct = Math.min(100, Math.round(((total - timeLeft) / total) * 100));
        html += '<div style="background:var(--panel2);padding:8px 10px;border-radius:6px;margin-bottom:8px;">';
        html += '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:5px;">';
        html += '<span style="font-size:.9rem;">' + tStats.icon + ' ' + tStats.name + '</span>';
        html += '<span style="font-size:.75rem;color:var(--ok);">' + fmtTime(timeLeft) + '</span>';
        html += '</div>';
        html += '<div style="background:var(--bg);height:7px;border-radius:4px;overflow:hidden;">';
        html += '<div style="width:' + pct + '%;height:100%;background:var(--accent);transition:width 1s linear;"></div>';
        html += '</div>';
        // Total queue time — siempre visible, no solo si hay >1
        html += '<div style="font-size:.63rem;color:var(--dim);margin-top:4px;">Cola completa (' + queue.length + ' tropas): <span style="color:var(--accent);">' + fmtTime(totalSecsLeft) + '</span> · termina <b>' + lastStr + '</b></div>';
        html += '</div>';
      }
      // Waiting
      if (queue.length > 1) {
        var waiting = queue.slice(1);
        var counts = {};
        waiting.forEach(function(t) { counts[t.type] = (counts[t.type] || 0) + 1; });
        html += '<div style="background:var(--panel2);padding:7px 10px;border-radius:6px;">';
        html += '<div style="font-size:.68rem;color:var(--dim);margin-bottom:5px;letter-spacing:.08em;">EN ESPERA</div>';
        html += '<div style="display:flex;flex-wrap:wrap;gap:6px;">';
        Object.keys(counts).forEach(function(key) {
          var ts = TROOP_TYPES[key];
          if (!ts) return;
          html += '<div style="display:flex;align-items:center;gap:4px;background:var(--bg);padding:3px 8px;border-radius:4px;font-size:.78rem;">';
          html += ts.icon + ' ' + ts.name + ' <span style="color:var(--accent);font-weight:bold;margin-left:2px;">×' + counts[key] + '</span>';
          html += '</div>';
        });
        html += '</div></div>';
      }
      box.innerHTML = html;
    }

    // ============================================================
    // COMBAT SIMULATOR LOGIC (Ported from v0.11)
    // ============================================================
    function divideIntoGroups(total) {
      if (total <= 0) return [];
      let groups = [];
      let remaining = total;
      let power = Math.floor(Math.log10(total));
      while (remaining > 0) {
        let size = Math.pow(10, power);
        if (remaining >= size) {
          groups.push(size);
          remaining -= size;
        } else {
          power--;
          if (power < 0) {
            if (remaining > 0) groups.push(remaining);
            break;
          }
        }
      }
      return groups;
    }

    function createArmy(armyId, troops) {
      let army = [];
      Object.keys(troops).forEach(type => {
        let entry = troops[type];
        // Soporte para caballeros NPC: { count, stats } en vez de número simple
        let count, stats;
        if (entry && typeof entry === 'object' && entry.stats) {
          count = entry.count || 1;
          stats = entry.stats;
        } else {
          count = entry;
          stats = TROOP_TYPES[type];
        }
        if (!count || count <= 0) return;
        if (!stats) return;
        let groupSizes = divideIntoGroups(count);
        groupSizes.forEach((size, idx) => {
          army.push({
            armyId,
            groupId: army.length + 1,
            type,
            stats: JSON.parse(JSON.stringify(stats)),
            count: size,
            totalHP: size * stats.hp
          });
        });
      });
      return army;
    }

    // ============================================================
    // TROOP RECOVERY & LOOT SYSTEM
    // ============================================================
    
    function calculateRecovery(casualties) {
      // Recuperación aleatoria 10-30% de las bajas
      var recovered = {};
      Object.keys(casualties).forEach(function(type) {
        var dead = casualties[type] || 0;
        if (dead > 0) {
          var recoveryRate = 0.1 + Math.random() * 0.2; // 10-30%
          recovered[type] = Math.floor(dead * recoveryRate);
        }
      });
      return recovered;
    }
    
    function calculateLootCapacity(troops) {
      // Capacidad total = suma de capacidades individuales
      // Criaturas tienen capacity=0, así que no pueden saquear
      var total = 0;
      Object.keys(troops).forEach(function(type) {
        var count = troops[type] || 0;
        var troopData = TROOP_TYPES[type] || CREATURE_TYPES[type];
        if (troopData && count > 0) {
          total += count * (troopData.capacity || 0);
        }
      });
      return total;
    }
    
    function calculateLoot(defenderResources, capacity) {
      // Calcular total disponible
      var available = {
        madera: defenderResources.madera || 0,
        piedra: defenderResources.piedra || 0,
        hierro: defenderResources.hierro || 0,
        provisiones: defenderResources.provisiones || 0,
        esencia: defenderResources.esencia || 0
      };
      
      var totalAvailable = available.madera + available.piedra + available.hierro + 
                           available.provisiones + available.esencia;
      
      if (totalAvailable === 0 || capacity === 0) {
        return { madera: 0, piedra: 0, hierro: 0, provisiones: 0, esencia: 0 };
      }
      
      // Saquear proporcionalmente hasta llenar capacidad
      var ratio = Math.min(1, capacity / totalAvailable);
      
      return {
        madera: Math.floor(available.madera * ratio),
        piedra: Math.floor(available.piedra * ratio),
        hierro: Math.floor(available.hierro * ratio),
        provisiones: Math.floor(available.provisiones * ratio),
        esencia: Math.floor(available.esencia * ratio)
      };
    }
    
    function generateBattleReport(attackerName, defenderName, attackerTroops, defenderTroops, 
                                   result, loot, attackerXP, defenderXP, isNPC) {
      var winner = result.winner === 1 ? 'atacante' : result.winner === 2 ? 'defensor' : 'empate';
      
      // Calcular bajas y recuperación para atacante
      var attackerInitial = {};
      var attackerFinal = result.survivors1 || {};
      var attackerCasualties = {};
      var attackerRecovered = {};
      
      Object.keys(attackerTroops).forEach(function(type) {
        var initial = attackerTroops[type] || 0;
        var final = attackerFinal[type] || 0;
        if (initial > 0) {
          attackerInitial[type] = initial;
          attackerCasualties[type] = initial - final;
        }
      });
      attackerRecovered = calculateRecovery(attackerCasualties);
      
      // Calcular bajas y recuperación para defensor
      var defenderInitial = {};
      var defenderFinal = result.survivors2 || {};
      var defenderCasualties = {};
      var defenderRecovered = {};
      
      Object.keys(defenderTroops).forEach(function(type) {
        var initial = defenderTroops[type] || 0;
        var final = defenderFinal[type] || 0;
        if (initial > 0) {
          defenderInitial[type] = initial;
          defenderCasualties[type] = initial - final;
        }
      });
      defenderRecovered = calculateRecovery(defenderCasualties);
      
      // Generar HTML del informe
      var html = '<div style="background:var(--panel);border:1px solid var(--border);border-radius:8px;padding:16px;max-width:700px;margin:0 auto;">';
      
      // ATACANTES
      html += '<div style="margin-bottom:20px;"><div style="font-size:1.1rem;font-weight:bold;color:var(--danger);margin-bottom:12px;border-bottom:2px solid var(--danger);padding-bottom:6px;">⚔️ ATACANTES</div>';
      html += '<div style="color:var(--text);font-size:.85rem;margin-bottom:8px;"><b>' + attackerName + '</b></div>';
      html += generateTroopTable(attackerInitial, attackerFinal, attackerRecovered, false);
      html += '<div style="margin-top:8px;color:var(--accent);font-size:.8rem;">📊 Experiencia ganada: ' + fmt(attackerXP) + '</div>';
      html += '</div>';
      
      // DEFENSORES
      html += '<div style="margin-bottom:20px;"><div style="font-size:1.1rem;font-weight:bold;color:var(--ok);margin-bottom:12px;border-bottom:2px solid var(--ok);padding-bottom:6px;">🛡️ DEFENSORES</div>';
      html += '<div style="color:var(--text);font-size:.85rem;margin-bottom:8px;"><b>' + defenderName + '</b></div>';
      html += generateTroopTable(defenderInitial, defenderFinal, defenderRecovered, isNPC);
      html += '<div style="margin-top:8px;color:var(--accent);font-size:.8rem;">📊 Experiencia ganada: ' + fmt(defenderXP) + '</div>';
      html += '</div>';
      
      // RESULTADO
      html += '<div style="background:var(--panel2);border-radius:6px;padding:12px;margin-bottom:16px;text-align:center;">';
      html += '<div style="font-size:1.2rem;font-weight:bold;color:' + (winner === 'atacante' ? 'var(--ok)' : winner === 'defensor' ? 'var(--danger)' : 'var(--dim)') + ';margin-bottom:8px;">';
      html += winner === 'atacante' ? '🏆 Ha ganado el bando atacante' : winner === 'defensor' ? '💀 Ha ganado el bando defensor' : '⚖️ Empate';
      html += '</div>';
      html += '<div style="font-size:.75rem;color:var(--dim);">Rondas de combate: ' + result.rounds + '</div>';
      html += '</div>';
      
      // BOTÍN (solo si ganó atacante)
      if (winner === 'atacante' && loot) {
        var totalLoot = (loot.madera || 0) + (loot.piedra || 0) + (loot.hierro || 0) + 
                        (loot.provisiones || 0) + (loot.esencia || 0);
        if (totalLoot > 0) {
          html += '<div style="background:var(--panel2);border-radius:6px;padding:12px;margin-bottom:16px;">';
          html += '<div style="font-size:.9rem;font-weight:bold;color:var(--accent);margin-bottom:8px;">💰 Materias robadas:</div>';
          html += '<div style="display:flex;gap:16px;justify-content:center;flex-wrap:wrap;font-size:.85rem;">';
          if (loot.madera > 0) html += '<div>🌲 <b style="color:var(--madera);">' + fmt(loot.madera) + '</b></div>';
          if (loot.piedra > 0) html += '<div>⛰️ <b style="color:var(--piedra);">' + fmt(loot.piedra) + '</b></div>';
          if (loot.hierro > 0) html += '<div>⚙️ <b style="color:var(--hierro);">' + fmt(loot.hierro) + '</b></div>';
          if (loot.provisiones > 0) html += '<div>🌾 <b style="color:var(--prov);">' + fmt(loot.provisiones) + '</b></div>';
          if (loot.esencia > 0) html += '<div>✨ <b style="color:var(--esencia);">' + fmt(loot.esencia) + '</b></div>';
          html += '</div></div>';
        }
      }
      
      // LOG DESPLEGABLE
      if (result.log && result.log.length > 0) {
        html += '<div style="margin-top:16px;"><button onclick="toggleBattleLog(this)" style="width:100%;background:var(--panel2);border:1px solid var(--border);color:var(--text);padding:8px;border-radius:4px;cursor:pointer;font-size:.8rem;">Ver detalles de combate ▼</button>';
        html += '<div style="display:none;margin-top:8px;background:var(--bg);border:1px solid var(--border);border-radius:4px;padding:12px;max-height:300px;overflow-y:auto;font-size:.7rem;font-family:monospace;color:var(--dim);">';
        result.log.forEach(function(line) {
          html += line + '<br>';
        });
        html += '</div></div>';
      }
      
      html += '</div>';
      
      return html;
    }
    
    function generateTroopTable(initial, final, recovered, isNPC) {
      var types = Object.keys(initial).filter(function(t) { return initial[t] > 0; });
      if (types.length === 0) return '<div style="color:var(--dim);font-size:.8rem;">Sin tropas</div>';
      
      var html = '<table style="width:100%;border-collapse:collapse;font-size:.8rem;color:var(--text);">';
      html += '<thead><tr style="border-bottom:1px solid var(--border);">';
      html += '<th style="text-align:left;padding:6px;color:var(--dim);font-size:.75rem;"></th>';
      
      types.forEach(function(type) {
        var troopData = TROOP_TYPES[type] || CREATURE_TYPES[type];
        var name = troopData ? troopData.name : type;
        var icon = troopData ? troopData.icon : '❓';
        if (type === '_knight') {
          name = 'Caballero';
          icon = '👑';
        }
        html += '<th style="text-align:center;padding:6px;color:var(--text);">' + icon + ' ' + name + '</th>';
      });
      html += '</tr></thead><tbody>';
      
      // Fila: Iniciales
      html += '<tr><td style="padding:6px;color:var(--dim);">Iniciales</td>';
      types.forEach(function(type) {
        html += '<td style="text-align:center;padding:6px;">' + (initial[type] || 0) + '</td>';
      });
      html += '</tr>';
      
      // Fila: Finales
      html += '<tr><td style="padding:6px;color:var(--dim);">Finales</td>';
      types.forEach(function(type) {
        html += '<td style="text-align:center;padding:6px;">' + (final[type] || 0) + '</td>';
      });
      html += '</tr>';
      
      // Fila: Recuperadas (solo si no es NPC knight)
      if (!isNPC) {
        html += '<tr style="border-top:1px solid var(--border);"><td style="padding:6px;color:var(--ok);">Recuperadas</td>';
        types.forEach(function(type) {
          var rec = recovered[type] || 0;
          html += '<td style="text-align:center;padding:6px;color:var(--ok);">' + rec + '</td>';
        });
        html += '</tr>';
      }
      
      html += '</tbody></table>';
      return html;
    }
    
    function toggleBattleLog(btn) {
      var logDiv = btn.nextElementSibling;
      if (logDiv.style.display === 'none') {
        logDiv.style.display = 'block';
        btn.textContent = 'Ocultar detalles ▲';
      } else {
        logDiv.style.display = 'none';
        btn.textContent = 'Ver detalles de combate ▼';
      }
    }

    // Solo dispara los ataques de un ejército contra el otro (sin respuesta)
    function executeTurnOneDirection(attackers, defenders, log) {
      attackers.forEach(function(group) {
        if (group.count <= 0 || defenders.length === 0) return;
        for (var i = 0; i < (group.stats.attacksPerTurn || 1); i++) {
          if (defenders.length === 0) break;
          var targetIndex = Math.floor(Math.random() * defenders.length);
          var target = defenders[targetIndex];
          var totalDamage = group.count * group.stats.damage;
          var attackRoll = (group.stats.attackChance || 10) + Math.floor(Math.random() * 20) + 1;
          if (attackRoll > target.stats.defense) {
            target.totalHP -= totalDamage;
            var newCount = Math.max(0, Math.floor(target.totalHP / target.stats.hp + 0.0001));
            var killed = target.count - newCount;
            target.count = newCount;
            if (log) log.push(group.stats.icon + ' G' + group.groupId + ' atacó a ' + target.stats.icon + ' G' + target.groupId + ': ' + totalDamage + ' daño, ' + killed + ' bajas.');
            if (target.count <= 0) {
              var idx = defenders.indexOf(target);
              if (idx !== -1) defenders.splice(idx, 1);
            }
          }
        }
      });
    }

    function executeTurn(army1, army2, log) {
      let allGroups = [
        ...army1.map(g => ({ ...g, army: army1, enemyArmy: army2 })),
        ...army2.map(g => ({ ...g, army: army2, enemyArmy: army1 }))
      ];

      allGroups.sort((a, b) => {
        if (b.stats.dexterity !== a.stats.dexterity) return b.stats.dexterity - a.stats.dexterity;
        if (a.count !== b.count) return a.count - b.count;
        return Math.random() - 0.5;
      });

      allGroups.forEach(group => {
        if (group.count <= 0 || group.enemyArmy.length === 0) return;

        for (let i = 0; i < (group.stats.attacksPerTurn || 1); i++) {
          if (group.enemyArmy.length === 0) break;
          let targetIndex = Math.floor(Math.random() * group.enemyArmy.length);
          let target = group.enemyArmy[targetIndex];

          let totalDamage = group.count * group.stats.damage;
          let attackRoll = (group.stats.attackChance || 10) + Math.floor(Math.random() * 20) + 1;
          
          if (attackRoll > target.stats.defense) {
            target.totalHP -= totalDamage;
            let survivorsFloat = target.totalHP / target.stats.hp;
            let newCount = Math.max(0, Math.floor(survivorsFloat + 0.0001));
            let killed = target.count - newCount;
            target.count = newCount;

            if (log) log.push(`${group.stats.icon} G${group.groupId} atacó a ${target.stats.icon} G${target.groupId}: ${totalDamage} daño, ${killed} bajas.`);

            if (target.count <= 0) {
              let idx = group.enemyArmy.indexOf(target);
              if (idx !== -1) group.enemyArmy.splice(idx, 1);
            }
          } else {
            if (log) log.push(`${group.stats.icon} G${group.groupId} falló ataque contra ${target.stats.icon} G${target.groupId}.`);
          }
        }
      });
    }

        function simulateBattle(army1Troops, army2Troops, defenderWallLevel) {
      let army1 = createArmy(1, army1Troops);
      let army2 = createArmy(2, army2Troops);
      let log = [];
      let turn = 1;

      // MURALLA: escudo con HP propio. El atacante debe destruirla antes de llegar a las tropas.
      // Nivel 1 = 500 HP, +500 por nivel. Nivel 10 = 5000 HP.
      var wallHP = (defenderWallLevel && defenderWallLevel > 0) ? defenderWallLevel * 500 : 0;
      if (wallHP > 0) {
        log.push('🏰 Muralla nivel ' + defenderWallLevel + ': ' + wallHP + ' HP de escudo. El atacante debe destruirla primero.');
      }

      while ((army1.length > 0 || wallHP > 0) && army2.length > 0 && turn <= 100) {
        log.push('--- Ronda ' + turn + ' ---');
        if (wallHP > 0) {
          // Fase 1: el atacante golpea la muralla, no a las tropas
          var totalAttackerDmg = 0;
          army1.forEach(function(group) {
            if (group.count <= 0) return;
            var attacks = group.stats.attacksPerTurn || 1;
            totalAttackerDmg += group.count * group.stats.damage * attacks;
          });
          wallHP = Math.max(0, wallHP - totalAttackerDmg);
          log.push('⚔️ Atacantes golpean la muralla: -' + totalAttackerDmg + ' daño → ' + wallHP + ' HP restantes');
          // Fase 2: defensores atacan a tropas enemigas aunque haya muralla
          if (army1.length > 0) executeTurnOneDirection(army2, army1, log);
        } else {
          // Muralla caída: combate normal
          executeTurn(army1, army2, log, null);
        }
        turn++;
      }

      let winner = (army1.length > 0) ? 1 : (army2.length > 0) ? 2 : 0;

      // Calculate survivors
      let survivors1 = {};
      army1.forEach(g => survivors1[g.type] = (survivors1[g.type] || 0) + g.count);
      let survivors2 = {};
      army2.forEach(g => survivors2[g.type] = (survivors2[g.type] || 0) + g.count);

      return { winner, log, survivors1, survivors2, rounds: turn - 1 };
    }

    // Distancia Chebyshev entre aldea propia y casilla objetivo
    function isInTorreRange(tx, ty) {
      if (!activeVillage) return false;
      // Comprueba TODAS las aldeas del jugador, no solo la activa
      var villages = myVillages && myVillages.length > 0 ? myVillages : [activeVillage];
      for (var i = 0; i < villages.length; i++) {
        var v = villages[i];
        if (!v || !v.state) continue;
        var range = getTorreRange(v.state.buildings);
        if (range === 0) continue;
        var mx = v.x || 0, my = v.y || 0;
        if (Math.max(Math.abs(tx - mx), Math.abs(ty - my)) <= range) return true;
      }
      return false;
    }

    // ============================================================
    // WORKER ASSIGNMENT — aldeanos asignados por recurso
    // aldeanos_assigned = { madera:0, piedra:0, hierro:0, provisiones:0 }
    // Un aldeano solo puede estar asignado a UN recurso a la vez.
    // ============================================================

    function defaultTroops() {
      var tr = {};
      Object.keys(TROOP_TYPES).forEach(function (k) { tr[k] = (k === 'aldeano' ? 50 : 0); });
      return tr;
    }

    function defaultCreatures() {
      var cr = {};
      Object.keys(CREATURE_TYPES).forEach(function (k) { cr[k] = 0; });
      return cr;
    }

    // Consume N aldeanos de vs, restando primero de los libres y luego
    // proporcionalmente de los asignados si no hay suficientes libres.
    function consumeAldeanos(vs, amount) {
      if (!vs.troops) vs.troops = {};
      var total = vs.troops.aldeano || 0;
      if (amount > total) amount = total; // no puede sacar más de los que hay

      var assigned = vs.aldeanos_assigned || defaultAssignments();
      var totalAssigned = (assigned.madera||0)+(assigned.piedra||0)+(assigned.hierro||0)
                        +(assigned.provisiones||0)+(assigned.esencia||0);
      var libres = Math.max(0, total - totalAssigned);

      // Restar del total
      vs.troops.aldeano = Math.max(0, total - amount);

      // Si había suficientes libres, los asignados no cambian
      if (amount <= libres) return;

      // Faltan (amount - libres) aldeanos: sacarlos de los asignados proporcionalmente
      var deficit = amount - libres;
      var keys = ['madera','piedra','hierro','provisiones','esencia'];
      if (totalAssigned > 0) {
        keys.forEach(function(k) {
          var prop = (assigned[k] || 0) / totalAssigned;
          var quitar = Math.round(deficit * prop);
          assigned[k] = Math.max(0, (assigned[k] || 0) - quitar);
        });
        // Ajuste por redondeo: aseguramos que la suma de quitas == deficit
        var newTotal = keys.reduce(function(s,k){ return s+(assigned[k]||0); }, 0);
        var diff = (totalAssigned - deficit) - newTotal;
        for (var i = 0; i < keys.length && diff !== 0; i++) {
          if (assigned[keys[i]] > 0 && diff < 0) { assigned[keys[i]]--; diff++; }
          else if (diff > 0) { assigned[keys[i]]++; diff--; }
        }
      } else {
        // No hay asignados, nada que restar
      }
      vs.aldeanos_assigned = assigned;
    }

    function defaultAssignments() {
      // Ahora solo guardamos CUÁNTOS aldeanos están asignados a cada recurso
      // No son aldeanos separados, solo números de asignación
      return { madera: 0, piedra: 0, hierro: 0, provisiones: 0, esencia: 0 };
    }

    const MISSION_FACTOR = 60; // segundos por casilla de distancia (si vel=1)

    // ============================================================
    // TROOP & CREATURE LEVEL SYSTEM (placeholder)
    // TODO: Implementar sistema completo de XP y niveles
    // ============================================================
    function getTroopLevel(troopType) {
      // Para invocadores: nivel basado en cantidad entrenada
      // tier 1: siempre; tier 2: 100+; tier 3: 400+; tier 4: 1000+
      if (troopType === 'invocador') {
        var count = (activeVillage && activeVillage.state && activeVillage.state.troops && activeVillage.state.troops.invocador) || 0;
        if (count >= 1000) return 4;
        if (count >= 400)  return 3;
        if (count >= 100)  return 2;
        return 1;
      }
      return 1;
    }
    
    function getCreatureLevel(creatureType) {
      // Nivel de criatura = nivel de Torre de Invocación
      var torreLevel = (activeVillage && activeVillage.state && activeVillage.state.buildings &&
                        activeVillage.state.buildings.torreinvocacion &&
                        activeVillage.state.buildings.torreinvocacion.level) || 0;
      return Math.max(1, torreLevel);
    }

    // ============================================================
    // SUMMONING QUEUE - Sistema de invocación de criaturas
    // ============================================================
    
    function canSummon(creatureType, vs) {
      var cData = CREATURE_TYPES[creatureType];
      if (!cData) return { ok: false, reason: 'Criatura no válida' };
      
      // Verificar Torre de Invocación
      var torreLevel = (vs.buildings.torreinvocacion && vs.buildings.torreinvocacion.level) || 0;
      if (torreLevel === 0) {
        return { ok: false, reason: 'Necesitas construir la Torre de Invocación' };
      }
      
      // Verificar nivel de invocadores necesario (tier)
      var invocadorLevel = getTroopLevel('invocador');
      if (invocadorLevel < cData.tier) {
        return { ok: false, reason: 'Invocadores nivel ' + cData.tier + ' requeridos (tienes nivel ' + invocadorLevel + ')' };
      }
      
      // Verificar invocadores presentes
      var invocadoresActuales = vs.troops.invocador || 0;
      if (invocadoresActuales < cData.summonersNeeded) {
        return { ok: false, reason: 'Necesitas ' + cData.summonersNeeded + ' invocadores (tienes ' + invocadoresActuales + ')' };
      }
      
      // Verificar esencia
      if ((vs.resources.esencia || 0) < cData.cost.esencia) {
        return { ok: false, reason: 'Esencia insuficiente' };
      }
      
      return { ok: true };
    }
    
    function startSummoningFromInput(creatureType) {
      var input = document.getElementById('summonQty_' + creatureType);
      var amount = input ? (parseInt(input.value) || 1) : 1;
      if (amount < 1) amount = 1;
      startSummoning(creatureType, amount);
    }

    function startSummoning(creatureType, amount) {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      var cData = CREATURE_TYPES[creatureType];
      if (!cData) return;
      
      // Verificar cada unidad
      for (var i = 0; i < amount; i++) {
        var check = canSummon(creatureType, vs);
        if (!check.ok) {
          showNotif(check.reason, 'err');
          break;
        }
        
        // Consumir esencia
        vs.resources.esencia -= cData.cost.esencia;
        
        // Calcular tiempo con reducción por nivel de torre y nivel de criatura
        var torreLevel = (vs.buildings.torreinvocacion && vs.buildings.torreinvocacion.level) || 0;
        var creatureLevel = getCreatureLevel(creatureType);
        var baseTime = cData.time;
        var torreReduction = torreLevel * 0.05; // -5% por nivel de torre
        var creatureReduction = creatureLevel * 0.01; // -1% por nivel de criatura
        var totalReduction = Math.min(0.9, torreReduction + creatureReduction); // Max 90% reducción
        var finalTime = Math.floor(baseTime * (1 - totalReduction));
        
        // Añadir a cola — cada una empieza cuando termina la anterior (secuencial)
        if (!vs.summoning_queue) vs.summoning_queue = [];
        // Calcular cuándo termina la última en cola para encadenar
        var lastFinish = Date.now();
        if (vs.summoning_queue.length > 0) {
          var lastEntry = vs.summoning_queue[vs.summoning_queue.length - 1];
          lastFinish = Math.max(lastFinish, new Date(lastEntry.finish_at).getTime());
        }
        vs.summoning_queue.push({
          creature: creatureType,
          finish_at: new Date(lastFinish + finalTime * 1000).toISOString(),
          start_at: new Date(lastFinish).toISOString(),
          summonersNeeded: cData.summonersNeeded,
          paused: false
        });
      }
      
      flushVillage();
      showNotif(amount + ' ' + cData.name + '(s) en cola de invocación', 'ok');
    }
    
    function resolveSummoningQueue(vs) {
      if (!vs.summoning_queue || vs.summoning_queue.length === 0) return vs;
      
      var now = Date.now();
      var remaining = [];
      var changed = false;
      var invocadoresActuales = vs.troops.invocador || 0;
      
      for (var s of vs.summoning_queue) {
        var cData = CREATURE_TYPES[s.creature];
        if (!cData) continue;
        
        // Verificar si hay suficientes invocadores
        if (invocadoresActuales < s.summonersNeeded) {
          // Pausar invocación
          if (!s.paused) {
            s.paused = true;
            s.pausedAt = new Date().toISOString();
            changed = true;
          }
          remaining.push(s);
          continue;
        }
        
        // Si estaba pausada, reanudar
        if (s.paused) {
          s.paused = false;
          var pausedTime = new Date(s.pausedAt).getTime();
          var timeLeft = new Date(s.finish_at).getTime() - pausedTime;
          s.finish_at = new Date(now + timeLeft).toISOString();
          delete s.pausedAt;
          changed = true;
        }
        
        var finishTime = new Date(s.finish_at).getTime();
        
        if (now >= finishTime && !s.paused) {
          // Invocación completada
          if (!vs.creatures) vs.creatures = defaultCreatures();
          vs.creatures[s.creature] = (vs.creatures[s.creature] || 0) + 1;
          showNotif('¡' + cData.name + ' invocado!', 'ok');
          changed = true;
        } else {
          remaining.push(s);
        }
      }
      
      if (changed) {
        vs.summoning_queue = remaining;
      }
      
      return vs;
    }

    function defaultState() {
      var b = {};
      BUILDINGS.forEach(function (d) { b[d.id] = { level: 1 }; });
      return {
        resources: { madera: 800, piedra: 600, hierro: 400, provisiones: 200, esencia: 50, aldeanos: 50 },
        aldeanos_granja: 0,
        aldeanos_assigned: defaultAssignments(),
        troops: defaultTroops(),
        creatures: defaultCreatures(),
        buildings: b,
        build_queue: null,
        mission_queue: [],
        summoning_queue: [],
        last_updated: new Date().toISOString()
      };
    }


    // ============================================================
    // PRODUCTION RATES
    // Base: edificio produce una cantidad pequeña automáticamente
    // Bonus: cada aldeano asignado añade producción según nivel
    //
    // Bonus (÷10 respecto a valores anteriores para equilibrio):
    //   madera:      3 × nivel_aserradero  por aldeano/h
    //   piedra:      2.5 × nivel_cantera   por aldeano/h  (→ 2 redondeado)
    //   hierro:      2 × nivel_mineHierro  por aldeano/h
    //   provisiones: (5+nivel_granja)÷10   por aldeano/h  → ~0.6 base
    //   esencia:     1 × nivel_circulo     por aldeano/h
    // ============================================================

    function getBaseProd(blds) {
      // Mismas fórmulas que BUILDINGS.prod(lvl) para consistencia con el modal
      var mLvl = (blds.aserradero && blds.aserradero.level) || 1;
      var pLvl = (blds.cantera && blds.cantera.level) || 1;
      var hLvl = (blds.minehierro && blds.minehierro.level) || 1;
      var cLvl = (blds.circulo && blds.circulo.level) || 1;
      return {
        madera: Math.floor(30 + 40 * mLvl * Math.pow(1.1, mLvl)),
        piedra: Math.floor(20 + 30 * pLvl * Math.pow(1.1, pLvl)),
        hierro: Math.floor(10 + 20 * hLvl * Math.pow(1.1, hLvl)),
        provisiones: 0,
        esencia: Math.floor(5 + 15 * cLvl * Math.pow(1.1, cLvl))
      };
    }

    function getBonusPerWorker(blds) {
      // Bonus ~10% de la producción base por aldeano asignado
      var base = getBaseProd(blds);
      var gLvl = (blds.granja && blds.granja.level) || 1;
      return {
        madera: Math.max(1, Math.floor(base.madera * 0.1)),
        piedra: Math.max(1, Math.floor(base.piedra * 0.1)),
        hierro: Math.max(1, Math.floor(base.hierro * 0.1)),
        provisiones: Math.max(1, 5 + gLvl),   // provisiones: 6+ por aldeano/h
        esencia: Math.max(1, Math.floor(base.esencia * 0.1))
      };
    }

    function getProd(blds, aldGranja, workers) {
      var w = workers || defaultAssignments();
      if (!workers && aldGranja) w.provisiones = aldGranja;
      // Asegurar clave esencia
      if (w.esencia === undefined) w.esencia = 0;

      var base = getBaseProd(blds);
      var bonus = getBonusPerWorker(blds);

      return {
        madera: Math.floor(base.madera + (w.madera || 0) * bonus.madera),
        piedra: Math.floor(base.piedra + (w.piedra || 0) * bonus.piedra),
        hierro: Math.floor(base.hierro + (w.hierro || 0) * bonus.hierro),
        provisiones: Math.floor(base.provisiones + (w.provisiones || 0) * bonus.provisiones),
        esencia: Math.floor(base.esencia + (w.esencia || 0) * bonus.esencia),
        aldeanos: getAldeanosProd(blds)
      };
    }

    function calcRes(vs) {
      // Aplicar aldeanos discretos antes de calcular (actualiza vs.resources.aldeanos)
      calcAndApplyAldeanos(vs);

      var now = Date.now();
      var last = new Date(vs.last_updated).getTime();
      // Cap producción offline a 24h para evitar abuso de tiempo
      var hrs = Math.max(0, Math.min((now - last) / 3600000, 24));
      var w = vs.aldeanos_assigned || defaultAssignments();
      if (w.esencia === undefined) w.esencia = 0;
      var p = getProd(vs.buildings, 0, w);
      var cap = getCapacity(vs.buildings);

      var madera = (vs.resources.madera || 0) + p.madera * hrs;
      var piedra = (vs.resources.piedra || 0) + p.piedra * hrs;
      var hierro = (vs.resources.hierro || 0) + p.hierro * hrs;
      var provisiones = (vs.resources.provisiones || 0) + p.provisiones * hrs;
      var esencia = (vs.resources.esencia || 0) + p.esencia * hrs;

      // ═══════════════════════════════════════════════════════════════
      // NUEVO SISTEMA: 1 SOLO TIPO DE ALDEANO
      // troops.aldeano = TOTAL de aldeanos en la aldea
      // aldeanos_assigned = { madera: X, piedra: Y } = asignaciones (solo números)
      // aldeanos_libres = troops.aldeano - sum(assigned) - tropas_en_mision
      // ═══════════════════════════════════════════════════════════════
      
      var assigned = vs.aldeanos_assigned || defaultAssignments();
      if (assigned.esencia === undefined) assigned.esencia = 0;
      
      var totalAssigned = (assigned.madera || 0) + (assigned.piedra || 0) + (assigned.hierro || 0) 
                        + (assigned.provisiones || 0) + (assigned.esencia || 0);
      
      var barrCap = getBarracksCapacity(vs.buildings);
      
      // Aldeanos totales en la aldea (fuente de verdad)
      var aldTotal = (vs.troops && vs.troops.aldeano !== undefined) ? vs.troops.aldeano : 0;
      
      // Aldeanos libres = totales - asignados
      var aldLibres = Math.max(0, aldTotal - totalAssigned);

      // Cap almacén: cada recurso tiene su propio límite independiente (no suma total)
      // Si el almacén es nivel 3 → cap=8000, cada recurso puede llegar a 8000 por separado
      madera      = Math.min(madera,      cap);
      piedra      = Math.min(piedra,      cap);
      hierro      = Math.min(hierro,      cap);
      provisiones = Math.min(provisiones, cap);

      return {
        madera: Math.floor(madera),
        piedra: Math.floor(piedra),
        hierro: Math.floor(hierro),
        provisiones: Math.floor(provisiones),
        esencia: Math.floor(esencia),

        // compatibilidad: res.aldeanos = libres (UI vieja)
        aldeanos: aldLibres,

        // nuevo: para no romper total/libres nunca más
        aldeanos_libres: aldLibres,
        aldeanos_total: Math.floor(aldTotal),
        aldeanos_working: totalAssigned
      };
    }

    // Check if queued build is done (works offline: compares finish_at timestamp to now)
    // ============================================================
    // MISSIONS & TRAVEL
    // ============================================================
    async function cancelMission(missionRef) {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      // Buscar por mid (nuevo) con fallback a finish_at (misiones guardadas antes de v0.92)
      var idx = vs.mission_queue.findIndex(m => m.mid === missionRef || m.finish_at === missionRef);
      if (idx === -1) { showNotif('Misión no encontrada', 'err'); return; }

      var m = vs.mission_queue[idx];
      if (m.type === 'return') { showNotif('No puedes cancelar el retorno', 'err'); return; }

      var now = Date.now();
      var start = new Date(m.start_at).getTime();
      var finish = new Date(m.finish_at).getTime();
      var progress = Math.max(0, Math.min(1, (now - start) / (finish - start)));

      var dx = Math.abs(m.tx - activeVillage.x);
      var dy = Math.abs(m.ty - activeVillage.y);
      var totalDist = Math.max(dx, dy);
      var distTraveled = totalDist * progress;

      var minSpeed = 999;
      Object.keys(m.troops).forEach(k => {
        if ((m.troops[k] || 0) > 0 && TROOP_TYPES[k] && TROOP_TYPES[k].speed < minSpeed) {
          minSpeed = TROOP_TYPES[k].speed;
        }
      });
      if (minSpeed === 999) minSpeed = 1;

      var returnSecs = (distTraveled / minSpeed) * MISSION_FACTOR;
      var returnAt = new Date(now + returnSecs * 1000).toISOString();

      vs.mission_queue.splice(idx, 1);
      vs.mission_queue.push({
        type: 'return',
        tx: activeVillage.x,
        ty: activeVillage.y,
        troops: m.troops,
        finish_at: returnAt,
        start_at: new Date(now).toISOString()
      });

      showNotif('Misión cancelada. Tropas regresan en ' + fmtTime(Math.ceil(returnSecs)), 'ok');
      await flushVillage();
      tick();
    }

    async function startMission(type, tx, ty, targetId, troops) {
      if (!activeVillage) return;
      var vs = activeVillage.state;

      // Calculate travel time
      var dx = Math.abs(tx - activeVillage.x);
      var dy = Math.abs(ty - activeVillage.y);
      var dist = Math.max(dx, dy);

      var minSpeed = 999;
      Object.keys(troops).forEach(k => {
        var troopData = TROOP_TYPES[k] || CREATURE_TYPES[k];
        if (troops[k] > 0 && troopData && troopData.speed < minSpeed) {
          minSpeed = troopData.speed;
        }
      });
      if (minSpeed === 999) minSpeed = 1;

      var seconds = (dist / minSpeed) * MISSION_FACTOR;
      var finishAt = new Date(Date.now() + seconds * 1000).toISOString();

      // Deduct troops and creatures
      snapshotResources(vs);
      Object.keys(troops).forEach(k => {
        if (TROOP_TYPES[k]) {
          // Tropa normal
          vs.troops[k] = Math.max(0, (vs.troops[k] || 0) - troops[k]);
        } else if (CREATURE_TYPES[k]) {
          // Criatura
          vs.creatures[k] = Math.max(0, (vs.creatures[k] || 0) - troops[k]);
        }
      });
      
      // Deduct provisions ONLY for troops (not creatures)
      var totalUnits = 0;
      Object.keys(troops).forEach(k => {
        if (TROOP_TYPES[k]) { // Solo tropas normales consumen provisiones
          totalUnits += troops[k];
        }
      });
      vs.resources.provisiones = Math.max(0, vs.resources.provisiones - totalUnits);

      vs.mission_queue.push({
        mid: Math.random().toString(36).slice(2, 10) + Date.now().toString(36), // ID único
        type, tx, ty, targetId, troops,
        finish_at: finishAt,
        start_at: new Date().toISOString()
      });

      showNotif('Misión enviada! Llegada en ' + fmtTime(Math.ceil(seconds)), 'ok');
      await flushVillage();
      tick();
    }

    async function sendSystemReport(userId, title, body) {
      try {
        // Store as JSON with title + body so inbox can show title collapsed
        var payload = JSON.stringify({ title: title, body: body });
        var r = await sbClient.rpc('send_system_message', {
          p_user_id: userId,
          p_body: payload
        });
        if (r.error) console.warn('sendSystemReport RPC error:', r.error);
      } catch(e) {
        console.warn('sendSystemReport error:', e);
      }
    }

    async function resolveMissions(vs) {
      if (!vs.mission_queue || vs.mission_queue.length === 0) return vs;

      var now = Date.now();
      var remaining = [];
      var changed = false;

      for (var m of vs.mission_queue) {
        var finish = new Date(m.finish_at).getTime();
        if (now >= finish) {
          changed = true;
          // EXECUTE MISSION — wrapped in try/catch para que un error no atasque la misión
          try {
            if (m.type === 'spy') {
              await executeSpyMission(m);
            } else if (m.type === 'attack') {
              await executeAttackMission(m);
            } else if (m.type === 'found') {
              await executeFounding(m);
              continue;
            } else if (m.type === 'move') {
              await executeMove(m);
              continue; // tropas quedan en destino permanentemente
            } else if (m.type === 'reinforce') {
              await executeReinforce(m);
              continue; // tropas quedan en guest_troops
            } else if (m.type === 'transport') {
              await executeTransport(m);
              // NO hacer continue - permitir que las tropas vuelvan
            } else if (m.type === 'return_reinforce') {
              // Tropas volviendo de refuerzo a su aldea origen
              // Se añaden a las tropas del activeVillage (que es el origen)
              Object.keys(m.troops || {}).forEach(function(k) {
                if ((m.troops[k] || 0) <= 0) return;
                if (TROOP_TYPES[k]) vs.troops[k] = (vs.troops[k] || 0) + m.troops[k];
                else if (CREATURE_TYPES[k]) { if (!vs.creatures) vs.creatures = defaultCreatures(); vs.creatures[k] = (vs.creatures[k] || 0) + m.troops[k]; }
              });
              await sendSystemReport(currentUser.id, '↩ TROPAS DE VUELTA',
                'Tus tropas de refuerzo han regresado a casa desde [' + m.tx + ', ' + m.ty + '].');
              continue;
            }
          } catch(e) {
            console.warn('resolveMissions: error ejecutando misión', m.type, e);
            // La misión se descarta igualmente — no se queda atascada
          }

          // Tropas regresan a la velocidad del más lento, igual que la ida
          // Solo vuelven los supervivientes (m.troops ya tiene los supervivientes tras batalla)
          var survivors = m.troops || {};
          var hasSurvivors = Object.values(survivors).some(function(n){ return n > 0; });

          if (hasSurvivors) {
            // Calcular velocidad del más lento entre supervivientes
            var minSpeed = 999;
            Object.keys(survivors).forEach(function(k) {
              if ((survivors[k] || 0) > 0 && TROOP_TYPES[k] && TROOP_TYPES[k].speed < minSpeed) {
                minSpeed = TROOP_TYPES[k].speed;
              }
            });
            if (minSpeed === 999) minSpeed = 1;

            // Misma distancia que la ida
            var dx = Math.abs(m.tx - activeVillage.x);
            var dy = Math.abs(m.ty - activeVillage.y);
            var dist = Math.max(dx, dy);
            var returnSecs = (dist / minSpeed) * MISSION_FACTOR;
            var returnAt = new Date(Date.now() + returnSecs * 1000).toISOString();

            // Añadir misión de retorno
            remaining.push({
              type: 'return',
              tx: activeVillage.x,
              ty: activeVillage.y,
              troops: survivors,
              finish_at: returnAt,
              start_at: new Date().toISOString(),
              origin_name: m.targetId || 'misión',
              loot: m.loot || null
            });
            // Notificación eliminada - causaba spam en cada tick
          }
        } else if (m.type === 'return' && now >= new Date(m.finish_at).getTime()) {
          changed = true;
          // Tropas regresan — calcular espacio real disponible
          var barrCap = getBarracksCapacity(vs.buildings);
          var usedNow = getBarracksUsed(vs);
          var freeSlots = Math.max(0, barrCap - usedNow);

          // Calcular cuántas plazas necesitan las tropas que regresan
          var slotsNeeded = 0;
          Object.keys(m.troops).forEach(function(k) {
            var count = m.troops[k] || 0;
            if (count <= 0) return;
            var slots = k === 'aldeano' ? count : count * ((TROOP_TYPES[k] && TROOP_TYPES[k].barracasSlots) || 1);
            slotsNeeded += slots;
          });

          var accepted = {}, anyRejected = false;

          if (slotsNeeded <= freeSlots) {
            // Caben todas
            Object.keys(m.troops).forEach(function(k) { accepted[k] = m.troops[k] || 0; });
          } else {
            // No caben todas — eliminar porcentaje proporcional de cada tipo (redondeando hacia arriba)
            // LEY: lo que entra NO puede superar el hueco disponible
            var pctEliminar = freeSlots < slotsNeeded ? (slotsNeeded - freeSlots) / slotsNeeded : 0;

            Object.keys(m.troops).forEach(function(k) {
              var total = m.troops[k] || 0;
              if (total <= 0) { accepted[k] = 0; return; }
              var toEliminate = Math.ceil(total * pctEliminar); // redondear hacia arriba (LEY)
              var toAccept = total - toEliminate;
              // Verificar que las plazas de los aceptados no superen freeSlots
              var slotsForThis = k === 'aldeano' ? toAccept : toAccept * ((TROOP_TYPES[k] && TROOP_TYPES[k].barracasSlots) || 1);
              // Si aún así sobrepasa (por redondeos), recortar
              while (toAccept > 0) {
                var testSlots = k === 'aldeano' ? toAccept : toAccept * ((TROOP_TYPES[k] && TROOP_TYPES[k].barracasSlots) || 1);
                if (testSlots <= freeSlots) break;
                toAccept--;
              }
              accepted[k] = toAccept;
              if (toAccept < total) anyRejected = true;
            });

            // Verificación final: la suma de slots aceptados no supera freeSlots (LEY)
            var totalAcceptedSlots = 0;
            Object.keys(accepted).forEach(function(k) {
              var count = accepted[k] || 0;
              totalAcceptedSlots += k === 'aldeano' ? count : count * ((TROOP_TYPES[k] && TROOP_TYPES[k].barracasSlots) || 1);
            });
            if (totalAcceptedSlots > freeSlots) {
              // Recorte de emergencia proporcional adicional
              Object.keys(accepted).forEach(function(k) {
                accepted[k] = Math.floor(accepted[k] * freeSlots / totalAcceptedSlots);
              });
              anyRejected = true;
            }
          }

          // Añadir tropas y criaturas aceptadas al estado
          Object.keys(accepted).forEach(function(k) {
            var toAdd = accepted[k] || 0;
            if (toAdd <= 0) return;
            
            if (TROOP_TYPES[k]) {
              // Tropa normal
              if (k === 'aldeano') {
                vs.troops.aldeano = (vs.troops.aldeano || 0) + toAdd;
              } else {
                vs.troops[k] = (vs.troops[k] || 0) + toAdd;
              }
            } else if (CREATURE_TYPES[k]) {
              // Criatura - no ocupan barracas
              if (!vs.creatures) vs.creatures = defaultCreatures();
              vs.creatures[k] = (vs.creatures[k] || 0) + toAdd;
            }
          });

          // Las provisiones NO se restauran al volver — se gastaron en el camino.
          // Solo se recuperan por producción de granja.

          // Informe de llegada - aplicar botín con límites
          var lootReport = '';
          if (m.loot) {
            var cap = getCapacity(vs.buildings);
            var appliedLoot = {};
            
            ['madera', 'piedra', 'hierro', 'provisiones'].forEach(function(res) {
              var incoming = m.loot[res] || 0;
              if (incoming > 0) {
                var current = vs.resources[res] || 0;
                var space = Math.max(0, cap - current);
                var added = Math.min(incoming, space);
                
                vs.resources[res] = current + added;
                if (added > 0) appliedLoot[res] = added;
              }
            });
            
            // Esencia no tiene límite
            if (m.loot.esencia > 0) {
              vs.resources.esencia = (vs.resources.esencia || 0) + m.loot.esencia;
              appliedLoot.esencia = m.loot.esencia;
            }
            
            // Generar reporte de botín
            if (Object.keys(appliedLoot).length > 0) {
              lootReport = '\n\n💰 Botín obtenido:\n';
              if (appliedLoot.madera) lootReport += '🌲 ' + fmt(appliedLoot.madera) + ' madera\n';
              if (appliedLoot.piedra) lootReport += '⛰️ ' + fmt(appliedLoot.piedra) + ' piedra\n';
              if (appliedLoot.hierro) lootReport += '⚙️ ' + fmt(appliedLoot.hierro) + ' hierro\n';
              if (appliedLoot.provisiones) lootReport += '🌾 ' + fmt(appliedLoot.provisiones) + ' provisiones\n';
              if (appliedLoot.esencia) lootReport += '✨ ' + fmt(appliedLoot.esencia) + ' esencia';
            }
          }

          var acceptedStr = Object.keys(accepted).filter(function(k){ return (accepted[k] || 0) > 0; })
            .map(function(k){ return accepted[k] + ' ' + (TROOP_TYPES[k] ? TROOP_TYPES[k].name : k); }).join(', ') || 'ninguna';
          var rejectedStr = anyRejected ? '\n⚠️ Sin espacio en barracas: algunas tropas se perdieron.' : '';

          await sendSystemReport(currentUser.id, '🏠 TROPAS REGRESAN',
            'Tus tropas han vuelto a la aldea.\n' +
            '✅ Aceptadas: ' + acceptedStr + rejectedStr + lootReport);
          showNotif('¡Tropas han regresado!', 'ok');
          // NO añadir a remaining — la misión de retorno se descarta tras procesar

        } else {
          remaining.push(m);
        }
      }

      if (changed) {
        // Descartar solo misiones con finish_at hace más de 7 días (datos corruptos, no offline legítimo)
        var sevenDaysAgo = Date.now() - 7 * 24 * 3600 * 1000;
        remaining = remaining.filter(function(m) {
          var ft = new Date(m.finish_at).getTime();
          if (ft < sevenDaysAgo) {
            console.warn('resolveMissions: descartando misión corrupta (>7 días)', m);
            return false;
          }
          return true;
        });
        vs.mission_queue = remaining;
      }
      return vs;
    }

    async function executeSpyMission(m) {
      var target = (typeof NPC_CASTLES !== 'undefined' ? NPC_CASTLES : []).find(c => c.id === m.targetId);
      if (target) {
        var obj = playerObjectives.find(o => o.objective_id === target.id);
        var alreadyCleared = obj && obj.status === 'cleared';
        var report =
          '⚔️ INFORME DE ESPIONAJE\n' +
          '══════════════════════\n' +
          target.name + ' [' + m.tx + ', ' + m.ty + ']\n\n' +
          '🗡️ Ataques por turno: ' + target.attacksPerTurn + '\n' +
          '🎯 Bono de ataque:    +' + target.attackChance + '\n' +
          '💥 Daño:              ' + fmt(target.damage) + '\n' +
          '❤️ Vida (PG):         ' + fmt(target.hp) + '\n' +
          '🛡️ Clase de Armadura: ' + target.defense + '\n' +
          '⚡ Destreza:          ' + target.dexterity + '\n\n' +
          '🏆 Recompensa:        ' + fmt(target.rewards.experience) + ' XP\n' +
          (alreadyCleared ? '\n✅ Ya derrotado por ti.' : '\n⚠️ Aún no derrotado.');
        await updateObjective(target.id, 'spied');
        await sendSystemReport(currentUser.id, '🔍 ESPIONAJE: ' + target.name, report);
        showNotif('Espionaje completado. Revisa tus mensajes.', 'ok');
      } else {
        await sendSystemReport(currentUser.id, 'ESPIONAJE', 'Coordenada [' + m.tx + ', ' + m.ty + '] sin objetivo.');
        showNotif('Sin objetivo en esa coordenada.', 'err');
      }
    }

    async function executeAttackMission(m) {
      var target = (typeof NPC_CASTLES !== 'undefined' ? NPC_CASTLES : []).find(c => c.id === m.targetId);
      if (!target) return;

      // Comprobar si ya fue derrotado por este jugador
      var obj = playerObjectives.find(o => o.objective_id === target.id);
      if (obj && obj.status === 'cleared') {
        await sendSystemReport(currentUser.id, '⚔️ BATALLA: ' + target.name,
          '❌ Ya derrotaste a ' + target.name + ' anteriormente. No puedes atacarlo de nuevo.');
        showNotif(target.name + ' ya fue derrotado por ti.', 'err');
        return;
      }

      // El caballero es UNA sola unidad con sus stats completos
      var knightArmy = {
        _knight: {
          count: 1,
          stats: {
            hp:             target.hp,
            damage:         target.damage,
            attacksPerTurn: target.attacksPerTurn,
            attackChance:   target.attackChance,
            defense:        target.defense,
            dexterity:      target.dexterity,
            armor:          0,
            weapon:         0,
            icon:           '👑',
            name:           target.name
          }
        }
      };

      var result = simulateBattle(m.troops, knightArmy, 0);
      var victoria = result.winner === 1;

      // Calcular bajas para XP (ANTES de recuperación)
      var attackerCasualties = {};
      var defenderCasualties = {};
      
      Object.keys(m.troops).forEach(function(type) {
        var initial = m.troops[type] || 0;
        var final = (result.survivors1[type] || 0);
        if (initial > final) {
          attackerCasualties[type] = initial - final;
        }
      });
      
      Object.keys(knightArmy).forEach(function(type) {
        var initial = knightArmy[type].count || 0;
        var final = (result.survivors2[type] || 0);
        if (initial > final) {
          defenderCasualties[type] = initial - final;
        }
      });

      // Calcular XP basada en bajas causadas (matar al enemigo da XP)
      var attackerXP = 0;
      var defenderXP = 0;
      
      // Atacante gana XP por matar tropas del defensor
      Object.keys(defenderCasualties).forEach(function(type) {
        var killed = defenderCasualties[type];
        if (type === '_knight') {
          attackerXP += target.rewards.experience; // XP del caballero
        }
      });
      
      // Defensor gana XP por matar tropas del atacante
      Object.keys(attackerCasualties).forEach(function(type) {
        var killed = attackerCasualties[type];
        var troopData = TROOP_TYPES[type] || CREATURE_TYPES[type];
        if (troopData) {
          // XP = HP de la tropa * cantidad matada (aproximación)
          defenderXP += killed * troopData.hp;
        }
      });

      // Calcular recuperación de tropas
      var attackerRecovered = calculateRecovery(attackerCasualties);
      
      // Tropas que regresan = supervivientes + recuperadas
      var returningTroops = {};
      Object.keys(result.survivors1).forEach(function(type) {
        returningTroops[type] = (result.survivors1[type] || 0) + (attackerRecovered[type] || 0);
      });
      Object.keys(attackerRecovered).forEach(function(type) {
        if (!returningTroops[type]) {
          returningTroops[type] = attackerRecovered[type];
        }
      });

      // Calcular saqueo (solo si victoria)
      var loot = null;
      if (victoria) {
        // Caballeros NPC no tienen recursos para saquear actualmente
        // Esto se puede expandir más adelante
        loot = { madera: 0, piedra: 0, hierro: 0, provisiones: 0, esencia: 0 };
      }

      // Generar informe de batalla
      var reportHTML = generateBattleReport(
        currentUser.user_metadata?.username || 'Jugador',
        target.name,
        m.troops,
        knightArmy,
        result,
        loot,
        attackerXP,
        defenderXP,
        true // isNPC
      );

      if (victoria) {
        // Otorgar XP al perfil
        await sbClient.rpc('add_experience', { amount: attackerXP });
        // Marcar como derrotado para este jugador
        await updateObjective(target.id, 'cleared');
        showNotif('¡' + target.name + ' derrotado! +' + fmt(attackerXP) + ' XP', 'ok');
      } else {
        await updateObjective(target.id, 'attacked');
        showNotif('Derrota contra ' + target.name + '. Revisa el reporte.', 'err');
      }

      // Las tropas que regresan llevan el botín
      m.troops = returningTroops;
      m.loot = loot;

      await sendSystemReport(currentUser.id, (victoria ? '🏆' : '💀') + ' BATALLA: ' + target.name, reportHTML);
    }

    // updateObjective definida más abajo (única versión — upsert)

    function resolveQueue(vs) {
      if (!vs.build_queue) return vs;

      var finishAt = new Date(vs.build_queue.finish_at).getTime();
      if (Date.now() >= finishAt) {
        var id = vs.build_queue.id;

        // UPGRADE BUILDING
        if (!vs.buildings[id]) vs.buildings[id] = { level: 1 };
        else vs.buildings[id].level++;

        // Clear queue
        vs.build_queue = null;

        var def = BUILDINGS.find(function (b) { return b.id === id; });
        showNotif((def ? def.name : id) + ' mejorada!', 'ok');

        // ⚠️ CRITICAL: Save changes removed from here to avoid side-effects.
        // Caller (tick or loadMyVillages) MUST check if queue changed and save.
      }
      return vs;
    }

    // ============================================================
    // USERNAME (EPIC WARRIOS V2)
    // Reglas:
    // - 4 a 15 caracteres
    // - Solo letras, numeros, "_" y "-"
    // - Debe ser unico
    // - Bloqueo por lista de terminos prohibidos (tabla banned_terms)
    // Nota: el backend (RLS/constraints o Edge Function) debe ser la autoridad final.
    // ============================================================
    function normUsername(u) {
      return (u || '')
        .trim()
        .toLowerCase()
        .normalize('NFD').replace(/[\u0300-\u036f]/g, '') // sin acentos
        .replace(/[^a-z0-9_-]/g, '') // solo permitido
        .replace(/([a-z0-9_-])\1{2,}/g, '$1$1') // colapsa repeticiones largas (aaaa->aa)
        ;
    }
    function isUsernameShapeValid(raw) {
      if (!raw) return { ok: false, msg: 'Escribe un nombre de usuario.' };
      if (raw.length < 4 || raw.length > 15) return { ok: false, msg: 'Debe tener entre 4 y 15 caracteres.' };
      if (!/^[A-Za-z0-9_-]+$/.test(raw)) return { ok: false, msg: 'Solo letras, numeros, "_" y "-".' };
      return { ok: true, msg: '' };
    }
    function setUserMsg(t, type) {
      var el = document.getElementById('userMsg');
      if (!el) return;
      el.textContent = t || '';
      el.className = 'auth-msg ' + (type || '');
    }
    async function fetchBannedTerms() {
      // Mantener pequeño: en prod, cachea y pagina si hace falta
      var r = await sbClient.from('banned_terms').select('term').limit(1000);
      if (r.error || !r.data) return [];
      return r.data.map(function (x) { return String(x.term || '').toLowerCase(); }).filter(Boolean);
    }
    async function isUsernameBanned(normalized) {
      // Comprueba si contiene cualquier termino prohibido
      // (Esto detecta muchos "derivados" simples porque normalizamos antes)
      var terms = await fetchBannedTerms();
      for (var i = 0; i < terms.length; i++) {
        var t = terms[i];
        if (t && normalized.includes(t)) return true;
      }
      return false;
    }
    async function isUsernameAvailable(normalized) {
      var r = await sbClient.from('profiles').select('id').eq('normalized_username', normalized).limit(1);
      if (r.error) return { ok: false, msg: 'No se pudo comprobar disponibilidad.' };
      if (r.data && r.data.length > 0) return { ok: false, msg: 'Ese nombre ya existe.' };
      return { ok: true, msg: '' };
    }

    // ============================================================
    // AUTH
    // ============================================================
    function switchTab(tab) {
      document.getElementById('tabL').style.display = tab === 'login' ? 'block' : 'none';
      document.getElementById('tabR').style.display = tab === 'register' ? 'block' : 'none';
      document.getElementById('btnTL').classList.toggle('active', tab === 'login');
      document.getElementById('btnTR').classList.toggle('active', tab === 'register');
      setMsg('', '');
    }
    function setMsg(t, type) { var el = document.getElementById('authMsg'); el.textContent = t; el.className = 'auth-msg ' + type; }

    // Username live check (solo UX; el backend manda)
    var userCheckTimer = null;
    async function onUserInput() {
      var raw = (document.getElementById('rUser') || {}).value || '';
      setUserMsg('', '');
      var shape = isUsernameShapeValid(raw);
      if (!shape.ok) { setUserMsg(shape.msg, 'err'); return; }
      var normalized = normUsername(raw);
      clearTimeout(userCheckTimer);
      userCheckTimer = setTimeout(async function () {
        setUserMsg('Comprobando...', '');
        if (await isUsernameBanned(normalized)) { setUserMsg('Nombre no permitido.', 'err'); return; }
        setUserMsg(av.ok ? 'Disponible ✅' : 'No disponible ❌', av.ok ? 'ok' : 'err');
      }, 250);
    }

    // ============================================================
    // AUTH & NETWORK
    // ============================================================

    // ============================================================
    // AUTH & NETWORK
    // ============================================================

    async function doLogin() {
      const email = document.getElementById('lEmail').value.trim();
      const pass = document.getElementById('lPass').value;
      if (!email || !pass) { setMsg('Rellena email y contraseña.', 'err'); return; }

      document.getElementById('lBtn').disabled = true;
      document.getElementById('lBtn').textContent = 'Conectando...';

      const { data, error } = await sbClient.auth.signInWithPassword({ email, password: pass });

      if (error) {
        setMsg('Error: ' + error.message, 'err');
        document.getElementById('lBtn').disabled = false;
        document.getElementById('lBtn').textContent = 'Entrar';
        return;
      }

      currentUser = data.user;
      document.getElementById('authScreen').style.display = 'none';
      document.getElementById('gameWrapper').classList.add('visible');
      await initGame();
    }

    async function doRegister() {
      const userRaw = (document.getElementById('rUser').value || '').trim();
      const email = document.getElementById('rEmail').value.trim();
      const pass = document.getElementById('rPass').value;

      if (!userRaw) { setUserMsg('El nombre de usuario es obligatorio.', 'err'); return; }
      if (!email || !pass) { setMsg('Rellena email y contraseña.', 'err'); return; }
      if (pass.length < 6) { setMsg('La contraseña debe tener al menos 6 caracteres.', 'err'); return; }

      document.getElementById('rBtn').disabled = true;
      document.getElementById('rBtn').textContent = 'Creando cuenta...';

      // 1. Sign Up
      const { data, error } = await sbClient.auth.signUp({
        email,
        password: pass,
        options: { data: { username: userRaw } }
      });

      if (error) {
        setMsg('Error: ' + error.message, 'err');
        document.getElementById('rBtn').disabled = false;
        document.getElementById('rBtn').textContent = 'Crear Cuenta';
        return;
      }

      if (data.session) {
        currentUser = data.user;
        document.getElementById('authScreen').style.display = 'none';
        document.getElementById('gameWrapper').classList.add('visible');
        // Ensure profile exists (trigger might have failed or be slow)
        await ensureProfile(currentUser.id, userRaw);
        await initGame();
      } else {
        setMsg('Revisa tu email para confirmar o inicia sesión.', 'ok');
        switchTab('login');
        document.getElementById('lEmail').value = email;
        document.getElementById('rBtn').disabled = false;
        document.getElementById('rBtn').textContent = 'Crear Cuenta';
      }
    }

    async function ensureProfile(uid, username) {
      // Just in case the trigger didn't fire or we want to force username
      await sbClient.from('profiles').upsert({ id: uid, username: username }, { onConflict: 'id' });
    }

    async function getMyPlayerData() {
      if (!currentUser) return null;
      try {
        // Try full select first (requires migration columns to exist)
        const { data, error } = await sbClient
          .from('profiles')
          .select('id, username, experience, role, military_score, alliance_tag')
          .eq('id', currentUser.id)
          .single();
        if (!error) return data;
        // Fallback: columns may not exist yet — fetch only guaranteed columns
        console.warn('getMyPlayerData full select failed, trying fallback:', error.message);
        const { data: d2, error: e2 } = await sbClient
          .from('profiles')
          .select('id, username, role')
          .eq('id', currentUser.id)
          .single();
        if (e2) { console.warn('getMyPlayerData fallback error:', e2.message); return null; }
        return { ...d2, experience: 0, military_score: 0, alliance_tag: null };
      } catch (e) {
        console.warn('getMyPlayerData exception:', e);
        return null;
      }
    }

    async function doLogout() {
      await flushVillage();
      // Clean up local state
      if (typeof realtimeChannel !== 'undefined' && realtimeChannel) {
        sbClient.removeChannel(realtimeChannel);
        realtimeChannel = null;
      }
      await sbClient.auth.signOut();
      currentUser = null;
      myVillages = [];
      activeVillage = null;
      activeVillageId = null;
      rankingCache = null;
      clearInterval(uiTimer);
      clearInterval(autoSaveTimer);
      document.getElementById('gameWrapper').classList.remove('visible');
      document.getElementById('authScreen').style.display = 'flex';
      location.reload(); // Hard reload to ensure clean slate
    }


    async function initGame() {
      if (!currentUser) return;

      // 1. Ensure profile exists and get it
      let myName = (currentUser.email || '').split('@')[0];
      await ensureProfile(currentUser.id, myName);

      const profile = await getMyPlayerData();
      myName = profile?.username || myName;
      const myXP = profile?.experience || 0;

      const elUser = document.getElementById('ovUser');
      if (elUser) elUser.textContent = myName;
      const elXP = document.getElementById('ovExperience');
      if (elXP) elXP.textContent = formatNumber(myXP);
      const elTop = document.getElementById('topbarUsername');
      if (elTop) elTop.textContent = myName;

      try {
        await loadMyVillages();
        await loadPlayerObjectives();

        if (myVillages.length === 0) {
          await createFirstVillage();
          // Reload to get the fresh full data structure
          await loadMyVillages();
        }

        if (myVillages.length === 0) {
          showNotif('Error: No se pudo cargar ninguna aldea.', 'err');
          return;
        }

        // Select first village by default
        activeVillage = myVillages[0]; // Object ref

        // Refresh UI
        populateVillageSel();
        // Usar _initSwitch para no pisar el sessionStorage durante el arranque
        window._suppressSessionSave = true;
        switchVillage(activeVillage.id);
        window._suppressSessionSave = false;

      } catch (e) {
        console.error('initGame error:', e);
        showNotif('Error crítico al iniciar juego.', 'err');
        return;
      }

      // Start Loops
      clearInterval(uiTimer);
      uiTimer = setInterval(tick, 1000);
      clearInterval(autoSaveTimer);
      autoSaveTimer = setInterval(scheduleSave, 60000); // 60s auto-save (reducido para ahorrar ancho de banda)
      setInterval(processRecalls, 300000); // Check recalls every 5 min

      if (typeof resetUiAnimation === 'function') resetUiAnimation();
      if (typeof ensureUiAnim === 'function') ensureUiAnim();

      // Load world data
      if (typeof loadAllVillages === 'function') loadAllVillages();
      // Cargar estado de alianza para el overview (sin bloquear)
      refreshMyAlliance().catch(function() {});

      tick();
      showNotif('¡Bienvenido, comandante!', 'ok');

      if (isAdmin()) {
        showNotif('🔒 Modo Admin Detectado', 'accent');
      }

      // Restaurar posición tras F5 (sessionStorage)
      // Espera 200ms para que initGame termine del todo antes de restaurar
      setTimeout(function restoreSession(attempts) {
        try {
          var lastVillage = sessionStorage.getItem('EW_lastVillage');
          var lastPage    = sessionStorage.getItem('EW_lastPage');
          if (!lastVillage && !lastPage) return; // nada que restaurar

          if (myVillages.length === 0 && attempts < 50) {
            return setTimeout(function(){ restoreSession(attempts + 1); }, 100);
          }

          if (lastVillage && myVillages.find(function(v){ return v.id === lastVillage; })) {
            window._suppressSessionSave = true;  // no pisar el valor al restaurar
            switchVillage(lastVillage);
            window._suppressSessionSave = false;
          }
          if (lastPage && lastPage !== 'overview') {
            var navEl = document.querySelector('.nav-item[onclick*="\'' + lastPage + '\'"]');
            showPage(lastPage, navEl);
          }
          var cx = sessionStorage.getItem('EW_camX');
          var cy = sessionStorage.getItem('EW_camY');
          if (cx && cy) { mapCamX = parseInt(cx); mapCamY = parseInt(cy); }
        } catch(e) { console.warn('restoreSession error:', e); }
      }, 200);
    }

    // ============================================================
    // OBJECTIVES
    // ============================================================
    async function loadPlayerObjectives() {
      if (!currentUser) return;
      try {
        const { data } = await sbClient.from('player_objectives').select('*').eq('user_id', currentUser.id);
        if (data) playerObjectives = data;
      } catch (e) { }
    }

    async function updateObjective(id, status) {
      if (!currentUser) return;
      try {
        await sbClient.from('player_objectives').upsert({ user_id: currentUser.id, objective_id: id, status: status, last_interaction: new Date().toISOString() });
        await loadPlayerObjectives();
        renderMap();
      } catch (e) { }
    }

    // ============================================================
    // VILLAGES & DATA MAPPING
    // ============================================================
    async function loadMyVillages() {
      // We need to fetch villages AND their resources/buildings/troops to construct the "state" object
      // expected by the game engine.

      // 1. Fetch Villages — columnas reales: id, owner_id, name, cx, cy, build_queue, mission_queue, summoning_queue, training_queue, last_aldeano_at, created_at
      const { data: villages, error: vErr } = await sbClient.from('villages')
        .select('id, owner_id, name, cx, cy, build_queue, mission_queue, summoning_queue, training_queue, last_aldeano_at, created_at')
        .eq('owner_id', currentUser.id)
        .order('created_at', { ascending: true });

      if (vErr) { console.error('Error fetching villages:', vErr); throw vErr; }


      if (!villages || villages.length === 0) {
        myVillages = [];
        return;
      }

      // 2. Fetch related data for ALL villages
      const loaded = [];

      for (const v of villages) {
        // Fetch Resources (Using maybeSingle to avoid 406 error if none found)
        let { data: res, error: rErr } = await sbClient.from('resources').select('*').eq('village_id', v.id).maybeSingle();
        if (rErr) console.warn('Error loading resources for village', v.id, rErr);

        // SELF-HEALING: If resources missing, create default
        if (!res) {
          const defRes = { village_id: v.id, madera: 500, piedra: 300, hierro: 100, prov: 0, esencia: 0 };
          const { data: newRes, error: insErr } = await sbClient.from('resources').insert(defRes).select().single();
          if (!insErr) res = newRes;
          else {
            console.error('Failed to self-heal resources:', insErr);
            res = defRes; // Fallback to memory object
          }
        }

        // Fetch Buildings
        let { data: blds, error: bErr } = await sbClient.from('buildings').select('*').eq('village_id', v.id).maybeSingle();
        if (bErr) console.warn('Error loading buildings for village', v.id, bErr);

        // SELF-HEALING: If buildings missing
        if (!blds) {
          const defBlds = { village_id: v.id, aserradero: 1, cantera: 1, minehierro: 1, granja: 1, almacen: 1, torre: 1, barracas: 1, circulo: 0, reclutamiento: 0, muralla: 0, lab: 0 };
          const { data: newBlds, error: insErr } = await sbClient.from('buildings').insert(defBlds).select().single();
          if (!insErr) blds = newBlds;
          else {
            console.error('Failed to self-heal buildings:', insErr);
            blds = defBlds;
          }
        }

        // Fetch Troops
        let { data: trp, error: tErr } = await sbClient.from('troops').select('*').eq('village_id', v.id).maybeSingle();
        if (tErr) console.warn('Error loading troops for village', v.id, tErr);

        // SELF-HEALING: If troops missing
        if (!trp) {
          const defTrp = { village_id: v.id };
          Object.keys(TROOP_TYPES).forEach(k => {
            defTrp[k] = (k === 'aldeano' ? 50 : 0);
          });
          const { data: newTrp, error: insErr } = await sbClient.from('troops').insert(defTrp).select().single();
          if (!insErr) trp = newTrp;
          else {
            console.error('Failed to self-heal troops:', insErr);
            trp = defTrp;
          }
        }

        // Fetch Creatures
        let { data: crs, error: cErr } = await sbClient.from('creatures').select('*').eq('village_id', v.id).maybeSingle();
        if (cErr) console.warn('Error loading creatures for village', v.id, cErr);

        // SELF-HEALING: If creatures missing
        if (!crs) {
          const defCrs = { village_id: v.id };
          Object.keys(CREATURE_TYPES).forEach(k => {
            defCrs[k] = 0;
          });
          const { data: newCrs, error: insErr } = await sbClient.from('creatures').insert(defCrs).select().single();
          if (!insErr) crs = newCrs;
          else {
            console.error('Failed to self-heal creatures:', insErr);
            crs = defCrs;
          }
        }


        // If data is missing (maybe insert failed too), try to recover using defaults so the game doesn't break
        const safeRes = res || { madera: 500, piedra: 300, hierro: 100, prov: 0, esencia: 0 };
        const safeBlds = blds || { aserradero: 1, cantera: 1, minehierro: 1, granja: 1, almacen: 1, torre: 1, barracas: 1, circulo: 0, reclutamiento: 0, muralla: 0, lab: 0, torreinvocacion: 0 };
        const safeTrp = trp || {}; // Si no hay fila de troops, empezar en 0 — no hardcodear 50

        // MAPPING: SQL -> Game State JSON
        const state = {
          resources: {
            madera: Number(safeRes.madera) || 0,
            piedra: Number(safeRes.piedra) || 0,
            hierro: Number(safeRes.hierro) || 0,
            provisiones: Number(safeRes.prov) || 0,
            esencia: Number(safeRes.esencia) || 0,
            aldeanos: 0
          },
          aldeanos_assigned: {
            madera: Number(safeRes.w_madera) || 0,
            piedra: Number(safeRes.w_piedra) || 0,
            hierro: Number(safeRes.w_hierro) || 0,
            provisiones: Number(safeRes.w_prov) || 0,
            esencia: Number(safeRes.w_esencia) || 0
          },
          // v0.17 — mapa completo de tropas desde DB
          troops: {},
          buildings: {},
          build_queue: v.build_queue || null,
          mission_queue: (v.mission_queue || []).filter(function(m) {
            // Descartar solo misiones con finish_at hace más de 7 días (corruptas)
            var ft = m.finish_at ? new Date(m.finish_at).getTime() : 0;
            return (Date.now() - ft) < 7 * 24 * 3600 * 1000;
          }),
          summoning_queue: (v.summoning_queue || []),
          training_queue: (v.training_queue || []).filter(function(t) {
            var ft = t.finish_at ? new Date(t.finish_at).getTime() : 0;
            return (Date.now() - ft) < 7 * 24 * 3600 * 1000;
          }),
          last_updated: safeRes.last_update || new Date().toISOString(),
          last_aldeano_at: v.last_aldeano_at || null, // timer discreto de aldeanos
          // Legacy/Compat flags
          _aldeanos_total_mode: true,
          owner_name: currentUser.email
        };

        Object.keys(TROOP_TYPES).forEach(k => {
          state.troops[k] = Number(safeTrp[k]) || 0;
        });
        state.resources.aldeanos = state.troops.aldeano || 0;

        // Map creatures from DB
        state.creatures = {};
        const safeCrs = crs || {};
        Object.keys(CREATURE_TYPES).forEach(k => {
          state.creatures[k] = Number(safeCrs[k]) || 0;
        });


        // Map buildings flat columns -> nested objects
        // Columns: aserradero, cantera, etc.
        // bldKeys derivado de BUILDINGS — añadir edificio nuevo solo en BUILDINGS[]
        const bldKeys = BUILDINGS.map(b => b.id);
        // Edificios activos desde nivel 1 (starter); el resto arrancan en 0 (no construidos)
        const starterBlds = ['aserradero', 'cantera', 'minehierro', 'granja', 'almacen', 'torre', 'barracas'];
        bldKeys.forEach(k => {
          var raw = safeBlds[k];
          // Si la columna existe en DB, usar ese valor. Si no existe aún (edificio nuevo), defaultear correctamente.
          var lvl = (raw !== undefined && raw !== null) ? Number(raw) : (starterBlds.includes(k) ? 1 : 0);
          state.buildings[k] = { level: lvl };
        });

        // Attach state to village object
        v.state = state;
        v.x = Number(v.cx); v.y = Number(v.cy); // Ensure numbers

        // IMMEDIATE OFFLINE PROGRESSION:
        // Check if a building finished while we were offline
        if (v.state.build_queue) {
          const oldQ = JSON.stringify(v.state.build_queue);
          v.state = resolveQueue(v.state);
          const newQ = JSON.stringify(v.state.build_queue);

          if (oldQ !== newQ) {
            // We use the new generic save helper
            await saveVillage(v);
          }
        }

        loaded.push(v);
      }

      myVillages = loaded;
    }

    async function loadAllVillages() {
      // Cargar TODAS las aldeas del mapa (para el mapa global)
      // FIX: 'state' and 'user_id' do not exist in schema. Use 'owner_id'.
      // We don't have 'state' column in villages, so we can't show points/score yet unless we join resources.
      var r = await sbClient.from('villages').select('id, owner_id, name, cx, cy');
      if (r.error) { console.error('Error loading world:', r.error); return; }
      if (r.data) {
        allVillages = r.data.map(function (v) {
          v.x = Number(v.cx); v.y = Number(v.cy); // Ensure numbers
          return v;
        });
      }
    }

    function populateVillageSel() {
      var sel = document.getElementById('villageSel');
      if (!sel) return;
      sel.innerHTML = '';
      myVillages.forEach(function (v) {
        var o = document.createElement('option');
        o.value = v.id;
        o.textContent = v.name + ' [' + v.x + ',' + v.y + ']';
        sel.appendChild(o);
      });
      if (activeVillage) sel.value = activeVillage.id;
    }

    function switchVillage(id) {
      var v = myVillages.find(function (v) { return v.id === id; });
      if (v) {
        activeVillage = v;
        mapCamX = null;
        mapCamY = null;
        resetUiAnimation();
        var sel = document.getElementById('villageSel');
        if (sel) sel.value = v.id;
        // Guardar aldea seleccionada para restaurar tras F5 (no durante arranque)
        if (!window._suppressSessionSave) { try { sessionStorage.setItem('EW_lastVillage', v.id); } catch(e) {} }
        tick();
        // Re-renderizar la página activa si es sensible a la aldea seleccionada
        var activePage = document.querySelector('.page.active');
        if (activePage) {
          var pid = activePage.id;
          if (pid === 'page-recursos')   { renderRecursos && renderRecursos(); }
          if (pid === 'page-buildings')  { renderBuildings && renderBuildings(calcRes(activeVillage.state)); }
          if (pid === 'page-fleet')      { renderTroops && renderTroops(); renderTrainingQueue && renderTrainingQueue(); }
          if (pid === 'page-creatures')  { renderCreatures && renderCreatures(); renderSummoningQueue && renderSummoningQueue(); }
          if (pid === 'page-map')        { renderMap && renderMap(); }
          if (pid === 'page-overview')   { renderReinforcementsPanel && renderReinforcementsPanel(); }
        }
      }
    }

    function getWorkerSum(w) {
      if (!w) return 0;
      return (w.madera || 0) + (w.piedra || 0) + (w.hierro || 0) + (w.provisiones || 0) + (w.esencia || 0);
    }

    async function createFirstVillage() {
      showNotif('Fundando primera colonia...', 'ok');

      // Find empty spot
      let cx, cy;
      let found = false;
      for (let i = 0; i < 100; i++) {
        cx = Math.floor(Math.random() * MAP_SIZE);
        cy = Math.floor(Math.random() * MAP_SIZE);
        // Simple check (collisions will fail on insert unique constraint)
        const { error } = await sbClient.from('villages').select('id').eq('cx', cx).eq('cy', cy).single();
        if (error) { found = true; break; } // Assuming error means "not found" (good)
      }

      const vName = 'Aldea 1';

      // Insert Village
      const { data: v, error: err } = await sbClient.from('villages').insert({
        owner_id: currentUser.id,
        name: vName,
        cx: cx,
        cy: cy,
        build_queue: null
      }).select().single();

      if (err) { throw new Error(err.message); }

      // Insert Related
      await sbClient.from('resources').insert({ village_id: v.id });
      // NEW: Start everything at Level 1
      await sbClient.from('buildings').insert({
        village_id: v.id,
        aserradero: 1, cantera: 1, minehierro: 1, granja: 1, almacen: 1, torre: 1, barracas: 1, circulo: 1, reclutamiento: 1, muralla: 0, lab: 0
      });
      const initialTroops = { village_id: v.id };
      Object.keys(TROOP_TYPES).forEach(k => {
        initialTroops[k] = (k === 'aldeano' ? 50 : 0);
      });
      await sbClient.from('troops').insert(initialTroops);
    }

    // Generic save function for ANY village (not just active)
    async function saveVillage(v) {
      if (!v || !currentUser) return;

      // Snapshot: calcular recursos actuales antes de guardar
      // Esto asegura que guardamos el valor real acumulado, no el del último tick
      snapshotResources(v.state);

      const s = v.state;
      const w = s.aldeanos_assigned || {};
      // 1. Update Resources
      const { error: rErr } = await sbClient.from('resources').update({
        madera: s.resources.madera,
        piedra: s.resources.piedra,
        hierro: s.resources.hierro,
        prov: s.resources.provisiones,
        esencia: s.resources.esencia,
        w_madera: (s.aldeanos_assigned && s.aldeanos_assigned.madera) || 0,
        w_piedra: (s.aldeanos_assigned && s.aldeanos_assigned.piedra) || 0,
        w_hierro: (s.aldeanos_assigned && s.aldeanos_assigned.hierro) || 0,
        w_prov: (s.aldeanos_assigned && s.aldeanos_assigned.provisiones) || 0,
        w_esencia: (s.aldeanos_assigned && s.aldeanos_assigned.esencia) || 0,
        last_update: new Date().toISOString()
      }).eq('village_id', v.id);

      if (rErr) throw rErr;

      // 2. Update Buildings
      const bUpd = {};
      for (let k in s.buildings) { bUpd[k] = s.buildings[k].level; }
      const { error: bErr } = await sbClient.from('buildings').update(bUpd).eq('village_id', v.id);
      if (bErr) {
        console.error('Buildings save error:', bErr);
        throw bErr;
      }

      // 3. Update Troops — all types
      const trpUpd = {};
      const trps = s.troops || defaultTroops();
      Object.keys(TROOP_TYPES).forEach(function (k) { trpUpd[k] = trps[k] || 0; });
      // Sync aldeanos: el total real de aldeanos en barracas se guarda en troops.aldeano.
      // resources.aldeanos es la fuente de verdad en memoria — actualizamos troops para que coincida.
      // Usamos una asignación directa sin ||, para que aldeano=0 sea un valor válido y no se sobreescriba.
      trpUpd.aldeano = (s.resources.aldeanos !== undefined && s.resources.aldeanos !== null)
        ? Math.max(0, Math.floor(s.resources.aldeanos))
        : (trps.aldeano || 0);
      // Mantener sincronizado el estado en memoria también
      s.troops.aldeano = trpUpd.aldeano;
      await sbClient.from('troops').update(trpUpd).eq('village_id', v.id);

      // 4b. Actualizar military_score — suma TODAS las aldeas + criaturas del jugador
      try {
        const allVils = await sbClient.from('villages').select('id').eq('owner_id', currentUser.id);
        if (!allVils.error && allVils.data && allVils.data.length > 0) {
          const vilIds = allVils.data.map(vv => vv.id);
          const allTrps = await sbClient.from('troops').select('*').in('village_id', vilIds);
          const allCrs  = await sbClient.from('creatures').select('*').in('village_id', vilIds);
          let grandTotal = 0;
          if (!allTrps.error && allTrps.data) {
            allTrps.data.forEach(row => { Object.keys(TROOP_TYPES).forEach(k => { grandTotal += (Number(row[k]) || 0); }); });
          }
          if (!allCrs.error && allCrs.data) {
            allCrs.data.forEach(row => { Object.keys(CREATURE_TYPES).forEach(k => { grandTotal += (Number(row[k]) || 0); }); });
          }
          await sbClient.from('profiles').update({ military_score: grandTotal }).eq('id', currentUser.id);
        }
      } catch(e) { console.warn('military_score update failed', e); }

      // 4c. Update Creatures
      const crUpd = {};
      const crs = s.creatures || defaultCreatures();
      Object.keys(CREATURE_TYPES).forEach(function (k) { crUpd[k] = crs[k] || 0; });
      await sbClient.from('creatures').update(crUpd).eq('village_id', v.id);

      // 4. Update Village (Queue, Missions, Name, aldeano timer, summoning queue, training queue)
      await sbClient.from('villages').update({
        build_queue: s.build_queue,
        mission_queue: s.mission_queue || [],
        summoning_queue: s.summoning_queue || [],
        training_queue: s.training_queue || [],
        name: v.name,
        last_aldeano_at: s.last_aldeano_at || null
      }).eq('id', v.id);
    }

    async function flushVillage() {
      if (!activeVillage) return;
      if (isFlushing) { pendingFlush = true; return; }

      isFlushing = true;
      setSave('saving');

      try {
        await saveVillage(activeVillage);
        setSave('saved');
      } catch (e) {
        console.error('Save error details:', e);
        if (e.message) console.error('Message:', e.message);
        setSave('error');
        showNotif('Error guardando: ' + e.message, 'err');
      } finally {
        isFlushing = false;
        if (pendingFlush) {
          pendingFlush = false;
          flushVillage();
        }
      }
    }

    var saveDebounce = null;
    var modalBuildingId = null; // tracks which building is open in modal
    function scheduleSave() {
      clearTimeout(saveDebounce);
      saveDebounce = setTimeout(flushVillage, 2000);
    }

    function setSave(s) {
      var dot = document.getElementById('saveDot');
      var txt = document.getElementById('saveTxt');
      dot.className = 'save-dot ' + s;
      txt.textContent = s === 'saving' ? 'guardando...' : s === 'saved' ? 'guardado' : '';
    }


    // ============================================================
    // UI ANIMATION — números que suben y bajan suave (tipo barra)
    // ============================================================
    let uiShown = null;
    let uiTarget = null;
    let uiAnimStarted = false;

    // Cache de elementos DOM frecuentes — evita querySelector 60 veces/segundo
    let _elCache = {};
    function _el(id) {
      if (!_elCache[id]) _elCache[id] = document.getElementById(id);
      return _elCache[id];
    }

    function resetUiAnimation() {
      uiShown = { madera: 0, piedra: 0, hierro: 0, provisiones: 0, esencia: 0, aldeanos: 0, capPctMa: 0, capPctPi: 0, capPctHi: 0, capPctPr: 0, capPctEs: 0, capPctAld: 0 };
      uiTarget = null;
    }

    function ensureUiAnim() {
      // Animación desactivada temporalmente — los valores se muestran directos desde calcRes()
      // para garantizar que lo que se ve es exactamente lo que hay en estado.
      // Reactivar cuando el sistema de producción esté verificado.
      if (uiAnimStarted) return;
      uiAnimStarted = true;
      function step() {
        if (uiShown && uiTarget) {
          // Sin lerp: copiamos target directamente a shown
          var keys = ['madera', 'piedra', 'hierro', 'provisiones', 'esencia', 'aldeanos', 'capPctMa', 'capPctPi', 'capPctHi', 'capPctPr', 'capPctEs', 'capPctAld'];
          keys.forEach(function (key) { uiShown[key] = uiTarget[key]; });
          renderAnimatedUi();
        }
        requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
    }

    function renderAnimatedUi() {
      if (!activeVillage || !uiShown) return;
      var vs = activeVillage.state;
      var aldGranja = vs.aldeanos_granja || 0;
      var barrCap = getBarracksCapacity(vs.buildings);
      var cap = getCapacity(vs.buildings);

      var madera = Math.round(uiShown.madera || 0);
      var piedra = Math.round(uiShown.piedra || 0);
      var hierro = Math.round(uiShown.hierro || 0);
      var prov = Math.round(uiShown.provisiones || 0);
      var esencia = Math.round(uiShown.esencia || 0);
      var aldLibres = Math.round(uiShown.aldeanos || 0);

      var stored = Math.round(uiShown.stored || 0);
      var capPct = Math.max(0, Math.min(100, uiShown.capPct || 0));

      // Topbar — valores
      _el('rMadera').textContent = fmt(madera);
      _el('rPiedra').textContent = fmt(piedra);
      _el('rHierro').textContent = fmt(hierro);
      _el('rProv').textContent = fmt(prov);
      _el('rEsencia').textContent = fmt(esencia);

      // Barras de capacidad individuales por recurso
      function setBar(id, pct, color) {
        var b = _el(id); if (!b) return;
        var cls = pct >= 100 ? 'full' : pct >= 80 ? 'warn' : 'ok';
        b.style.width = pct + '%';
        if (color) b.style.background = color;
        else b.className = 'cap-bar ' + cls;
      }
      setBar('capBarMa', uiShown.capPctMa || 0);
      setBar('capBarPi', uiShown.capPctPi || 0);
      setBar('capBarHi', uiShown.capPctHi || 0);
      setBar('capBarPr', uiShown.capPctPr || 0);
      setBar('capBarEs', uiShown.capPctEs || 0, 'var(--esencia)');
      setBar('capBarAld', uiShown.capPctAld || 0, 'var(--aldeanos)');

      // Overview — valores (pueden no existir si se rediseñó la página)
      if (_el('ovMadera')) _el('ovMadera').textContent = fmt(madera);
      if (_el('ovPiedra')) _el('ovPiedra').textContent = fmt(piedra);
      if (_el('ovHierro')) _el('ovHierro').textContent = fmt(hierro);
      if (_el('ovProv'))   _el('ovProv').textContent   = fmt(prov);
      if (_el('ovEsencia'))_el('ovEsencia').textContent= fmt(esencia);

      // Arriba: aldeanos libres. Abajo izq: total tropas en base. Abajo der: capacidad.
      var tropasEnBase = getBarracksUsed(vs); // todos los que están en base (no en misión)
      _el('rAldeanos').textContent = aldLibres;
      if (_el('rTropasBase')) _el('rTropasBase').textContent = tropasEnBase;
      if (_el('rBarrCap'))    _el('rBarrCap').textContent    = '/ ' + barrCap;
      if (_el('ovAldeanos')) _el('ovAldeanos').textContent = aldLibres + ' libres / ' + aldGranja + ' en granja';
    }

    // ============================================================
    // UI TICK (every second)
    // ============================================================
    function tick() {
      if (!activeVillage) return;

      // Check if build completed
      if (!activeVillage.state.build_queue) activeVillage.state.build_queue = null;
      var oldQ = activeVillage.state.build_queue ? JSON.stringify(activeVillage.state.build_queue) : null;
      if (!activeVillage.state.mission_queue) activeVillage.state.mission_queue = [];
      var oldM = JSON.stringify(activeVillage.state.mission_queue);
      if (!activeVillage.state.summoning_queue) activeVillage.state.summoning_queue = [];
      var oldS = JSON.stringify(activeVillage.state.summoning_queue);

      activeVillage.state = resolveQueue(activeVillage.state);
      activeVillage.state = resolveSummoningQueue(activeVillage.state);
      activeVillage.state = resolveTrainingQueue(activeVillage.state);

      // Resolve Missions (Async, but we can call it here as it handles its own internal async)
      resolveMissions(activeVillage.state).then(updatedState => {
        activeVillage.state = updatedState;
        var newQ = activeVillage.state.build_queue ? JSON.stringify(activeVillage.state.build_queue) : null;
        var newM = activeVillage.state.mission_queue ? JSON.stringify(activeVillage.state.mission_queue) : null;
        var newS = activeVillage.state.summoning_queue ? JSON.stringify(activeVillage.state.summoning_queue) : null;

        if ((oldQ && !newQ) || (oldM !== newM) || (oldS !== newS)) {
          flushVillage();
        }
      });

      var vs = activeVillage.state;
      var w = vs.aldeanos_assigned || defaultAssignments();
      if (w.esencia === undefined) w.esencia = 0;
      var res = calcRes(vs);
      var prod = getProd(vs.buildings, 0, w);
      var cap = getCapacity(vs.buildings);
      // Porcentaje individual de cada recurso respecto al almacén
      var capPctMa = cap > 0 ? Math.min(100, Math.round(res.madera      / cap * 100)) : 0;
      var capPctPi = cap > 0 ? Math.min(100, Math.round(res.piedra      / cap * 100)) : 0;
      var capPctHi = cap > 0 ? Math.min(100, Math.round(res.hierro      / cap * 100)) : 0;
      var capPctPr = cap > 0 ? Math.min(100, Math.round(res.provisiones / cap * 100)) : 0;
      var capPctEs = cap > 0 ? Math.min(100, Math.round(res.esencia     / cap * 100)) : 0;
      var barrCapTick = getBarracksCapacity(vs.buildings);
      var aldEnBaseTick = Math.max(0, (vs.troops && vs.troops.aldeano) || 0);
      var capPctAld = barrCapTick > 0 ? Math.min(100, Math.round(aldEnBaseTick / barrCapTick * 100)) : 0;

      // IMPORTANTE: tick() NO escribe a state.resources.
      // calcRes() calcula (now - last_updated) cada vez que se llama.
      // Si escribiéramos el resultado a state.resources, el siguiente tick
      // volvería a sumar las mismas horas sobre el nuevo valor — duplicando infinitamente.
      // state.resources solo se actualiza en snapshotResources() → llamado desde saveVillage().
      // tick() solo usa calcRes() para la UI, no para el estado.

      // Production rates (instantáneos)
      _el('rMaderaR').textContent = '+' + fmt(prod.madera) + '/h';
      _el('rPiedraR').textContent = '+' + fmt(prod.piedra) + '/h';
      _el('rHierroR').textContent = '+' + fmt(prod.hierro) + '/h';
      _el('rProvR').textContent = '+' + fmt(prod.provisiones) + '/h';
      _el('rEsenciaR').textContent = '+' + fmt(prod.esencia) + '/h';

      // Objetivos para animación (sube y baja)
      if (!uiShown) resetUiAnimation();
      ensureUiAnim();
      uiTarget = {
        madera: res.madera,
        piedra: res.piedra,
        hierro: res.hierro,
        provisiones: res.provisiones,
        esencia: res.esencia,
        aldeanos: res.aldeanos,
        capPctMa, capPctPi, capPctHi, capPctPr, capPctEs, capPctAld
      };

      if (_el('ovVillageName')) _el('ovVillageName').textContent = activeVillage.name;
      if (_el('ovVillageCoords')) _el('ovVillageCoords').textContent = 'Coordenadas: [' + activeVillage.x + ', ' + activeVillage.y + ']';
      // Overview player stats
      if (_el('ovUser')) {
        var displayUsername = window._playerUsername || (currentUser ? (currentUser.email || '--').split('@')[0] : '--');
        _el('ovUser').textContent = displayUsername;
      }
      if (_el('ovAlliance')) {
        var alTag = (window._playerAllianceTag) ? '[' + window._playerAllianceTag + ']' : '';
        var alName = window._playerAllianceName || '';
        var alStr = alName ? (alName + (alTag ? ' ' + alTag : '')) : (alTag || '—');
        _el('ovAlliance').textContent = alStr;
      }
      if (_el('ovBattlesWon')) _el('ovBattlesWon').textContent = (vs.battles_won_pvp || 0);
      if (_el('ovBattlesLost')) _el('ovBattlesLost').textContent = (vs.battles_lost_pvp || 0);
      // Troop movement alerts in overview
      if (_el('ovAlertsBox')) {
        var alerts = _incomingAttacks || [];
        var allMissions = (vs.mission_queue || []);
        var myOutgoing = allMissions.filter(function(m){ return m.type !== 'return'; });
        var myReturning = allMissions.filter(function(m){ return m.type === 'return'; });
        var alertLines = '';
        alerts.forEach(function(a) {
          var eta = Math.max(0, Math.ceil((new Date(a.finish_at).getTime() - Date.now()) / 1000));
          var fromName = a.fromVillage || 'Enemigo';
          alertLines += '<div style="background:rgba(255,61,90,.07);border:1px solid rgba(255,61,90,.2);border-radius:6px;padding:7px 10px;margin-bottom:5px;">'
            + '<span style="color:var(--danger);">🚨 Ataque entrante</span>'
            + '<span style="color:var(--dim);font-size:.72rem;margin-left:8px;">desde ' + escapeHtml(fromName) + '</span>'
            + '<span style="float:right;color:var(--danger);font-size:.75rem;">ETA ' + fmtTime(eta) + '</span>'
            + '</div>';
        });
        myOutgoing.forEach(function(m) {
          var eta = Math.max(0, Math.ceil((new Date(m.finish_at).getTime() - Date.now()) / 1000));
          var ico = m.type === 'spy' ? '🔍' : m.type === 'found' ? '🏠' : m.type === 'move' ? '⚔' : m.type === 'reinforce' ? '🛡️' : m.type === 'transport' ? '📦' : '⚔️';
          var label = m.type === 'spy' ? 'Espionaje' : m.type === 'found' ? 'Colonos → [' + m.tx + ',' + m.ty + ']' : m.type === 'move' ? 'Moviendo tropas → [' + m.tx + ',' + m.ty + ']' : m.type === 'reinforce' ? 'Refuerzo → [' + m.tx + ',' + m.ty + ']' : m.type === 'transport' ? 'Caravana → [' + m.tx + ',' + m.ty + ']' : 'Ataque';
          alertLines += '<div style="background:rgba(0,212,255,.05);border:1px solid rgba(0,212,255,.1);border-radius:6px;padding:7px 10px;margin-bottom:5px;">'
            + '<span style="color:var(--accent);">' + ico + ' ' + label + '</span>'
            + '<span style="float:right;color:var(--accent);font-size:.75rem;">ETA ' + fmtTime(eta) + '</span>'
            + '</div>';
        });
        myReturning.forEach(function(m) {
          var eta = Math.max(0, Math.ceil((new Date(m.finish_at).getTime() - Date.now()) / 1000));
          alertLines += '<div style="background:rgba(79,255,176,.04);border:1px solid rgba(79,255,176,.1);border-radius:6px;padding:7px 10px;margin-bottom:5px;">'
            + '<span style="color:var(--ok);">↩️ Tropas regresando</span>'
            + '<span style="float:right;color:var(--ok);font-size:.75rem;">ETA ' + fmtTime(eta) + '</span>'
            + '</div>';
        });
        _el('ovAlertsBox').innerHTML = alertLines || '<span style="color:var(--dim);font-size:.8rem;">Sin movimientos activos.</span>';
      }

      renderQueue(vs);
      updateAlertsButton();
      var nowMs = Date.now();
      if (nowMs - _lastSeenUpdate > 300000) { _lastSeenUpdate = nowMs; updateLastSeen(); }   // cada 5 min
      if (nowMs - _lastOnlineCheck > 300000) { _lastOnlineCheck = nowMs; updateOnlineCount(); } // cada 5 min
      updateGranjaPanel();
      // Reinforce panel — solo cada 60s (era cada segundo — demasiadas queries)
      if (nowMs - _lastReinforcementsCheck > 60000 && document.getElementById('page-overview').classList.contains('active')) {
        _lastReinforcementsCheck = nowMs;
        renderReinforcementsPanel();
      }
      if (document.getElementById('page-buildings').classList.contains('active')) {
        renderBuildings(res);
      }
      if (document.getElementById('page-creatures') && document.getElementById('page-creatures').classList.contains('active')) {
        renderSummoningQueue();
      }
      if (document.getElementById('page-fleet') && document.getElementById('page-fleet').classList.contains('active')) {
        renderTrainingQueue();
      }
    }

    // ============================================================
    // ALERTS — incoming attacks detection
    // ============================================================
    var _incomingAttacks = []; // cache updated periodically
    var _lastAlertsCheck = 0;

    var _lastSeenUpdate = 0;
    var _lastOnlineCheck = 0;
    var _lastReinforcementsCheck = 0;
    var _lastAlliancesCheck = 0;
    var _lastMapLoad = 0;
    var _lastResourceSync = 0;

    async function updateLastSeen() {
      if (!currentUser) return;
      try {
        await sbClient.from('profiles').update({ last_seen: new Date().toISOString() }).eq('id', currentUser.id);
      } catch(e) {}
    }

    async function updateOnlineCount() {
      try {
        var cutoff = new Date(Date.now() - 60000).toISOString(); // last 60s
        var r = await sbClient.from('profiles').select('id', { count: 'exact', head: true }).gte('last_seen', cutoff);
        var count = r.count || 0;
        var el = document.getElementById('activePlayers');
        if (el) el.textContent = '🟢 ' + count + ' online';
      } catch(e) {}
    }

    function updateAlertsButton() {
      var count = _incomingAttacks.length;
      var btn = document.getElementById('alertsBtn');
      var badge = document.getElementById('alertsBadge');
      var label = document.getElementById('alertsBtnLabel');
      if (!btn) return;

      if (count > 0) {
        btn.classList.add('has-alerts');
        if (badge) { badge.textContent = count; badge.style.display = 'flex'; }
        if (label) label.textContent = count + ' Ataque' + (count > 1 ? 's' : '');
      } else {
        btn.classList.remove('has-alerts');
        if (badge) badge.style.display = 'none';
        if (label) label.textContent = 'Alertas';
      }

      // Refrescar datos cada 30s sin bloquear el tick
      var now = Date.now();
      if (now - _lastAlertsCheck > 30000) {
        _lastAlertsCheck = now;
        checkIncomingAttacks();
      }
    }

    async function checkIncomingAttacks() {
      if (!activeVillage || !sbClient || !currentUser) return;
      try {
        // Coordenadas de todas mis aldeas
        var myCoords = myVillages.map(function(v) { return { x: v.x, y: v.y, id: v.id, name: v.name }; });
        if (myCoords.length === 0) return;

        // Cargar mission_queue de aldeas enemigas (las que no son mías)
        var { data, error } = await sbClient
          .from('villages')
          .select('id, name, cx, cy, owner_id, mission_queue')
          .neq('owner_id', currentUser.id);

        if (error || !data) return;

        var attacks = [];
        var now = Date.now();

        data.forEach(function(village) {
          var mq = village.mission_queue;
          if (!Array.isArray(mq)) return;
          mq.forEach(function(m) {
            if (m.type !== 'attack') return;
            // ¿apunta a alguna de mis aldeas?
            var target = myCoords.find(function(c) { return c.x === m.tx && c.y === m.ty; });
            if (!target) return;
            var finish = new Date(m.finish_at).getTime();
            if (finish <= now) return; // ya llegó, tick la resolverá
            attacks.push({
              fromName: village.name || '[' + village.cx + ',' + village.cy + ']',
              fromCoords: [village.cx, village.cy],
              toName: target.name,
              toCoords: [m.tx, m.ty],
              finish_at: m.finish_at,
              secsLeft: Math.ceil((finish - now) / 1000)
            });
          });
        });

        // Ordenar por llegada más próxima
        attacks.sort(function(a, b) { return a.secsLeft - b.secsLeft; });
        _incomingAttacks = attacks;
      } catch(e) {
        console.warn('checkIncomingAttacks error:', e);
      }
    }

    function toggleAlertsPanel() {
      var existing = document.getElementById('alertsModalOverlay');
      if (existing) { existing.remove(); return; }

      var attacks = _incomingAttacks;
      var inner = attacks.length === 0
        ? '<div class="alerts-empty">✅ Sin ataques entrantes detectados</div>'
        : attacks.map(function(a) {
            var t = fmtTime(a.secsLeft);
            return '<div class="alert-item">'
              + '<div class="alert-title">⚔️ Ataque entrante a ' + a.toName + '</div>'
              + '<div class="alert-sub">Desde: ' + a.fromName + ' [' + a.fromCoords[0] + ',' + a.fromCoords[1] + ']</div>'
              + '<div class="alert-time">⏱ Llega en: ' + t + '</div>'
              + '</div>';
          }).join('');

      var overlay = document.createElement('div');
      overlay.id = 'alertsModalOverlay';
      overlay.className = 'alerts-modal';
      overlay.innerHTML = '<div class="alerts-panel">'
        + '<div class="alerts-header">'
        + '<h3>🔔 Alertas (' + attacks.length + ')</h3>'
        + '<button onclick="document.getElementById(\'alertsModalOverlay\').remove()" style="background:none;border:none;color:var(--dim);cursor:pointer;font-size:1rem;">✕</button>'
        + '</div>'
        + inner
        + '</div>';

      // Cierra al click fuera del panel
      overlay.addEventListener('click', function(e) {
        if (e.target === overlay) overlay.remove();
      });

      document.body.appendChild(overlay);
    }

    // ============================================================
    // BUILD — saves finish_at timestamp immediately
    // ============================================================
    function startBuild(id) {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      if (vs.build_queue) { showNotif('Ya hay una construccion en curso.', 'err'); return; }
      var def = BUILDINGS.find(function (b) { return b.id === id; });
      var lvl = (vs.buildings[id] && vs.buildings[id].level) || 0;
      var cost = def.cost(lvl);
      var res = calcRes(vs);
      if (!canAfford(cost, res)) { showNotif('Recursos insuficientes.', 'err'); return; }

      // Snapshot primero (fija last_updated = ahora y escribe valores reales)
      // Luego resta el coste — nunca puede quedar negativo porque canAfford ya lo comprobó
      snapshotResources(vs);
      vs.resources.madera       = Math.max(0, vs.resources.madera       - (cost.madera      || 0));
      vs.resources.piedra       = Math.max(0, vs.resources.piedra       - (cost.piedra      || 0));
      vs.resources.hierro       = Math.max(0, vs.resources.hierro       - (cost.hierro      || 0));
      vs.resources.provisiones  = Math.max(0, vs.resources.provisiones  - (cost.provisiones || 0));
      vs.resources.esencia      = Math.max(0, vs.resources.esencia      - (cost.esencia     || 0));
      // last_updated ya lo fijó snapshotResources()

      // Store finish timestamp — this is what makes offline work
      var secs = def.time(lvl);
      vs.build_queue = { id: id, finish_at: new Date(Date.now() + secs * 1000).toISOString() };

      showNotif('Construyendo ' + def.name + ' nivel ' + (lvl + 1) + '...', 'ok');
      flushVillage(); // save immediately to Supabase
      tick();
      renderBuildings(calcRes(vs));
    }

    function canAfford(cost, res, cap, blds) {
      // Recursos individuales suficientes
      var resOk = (res.madera >= (cost.madera || 0)) && (res.piedra >= (cost.piedra || 0))
        && (res.hierro >= (cost.hierro || 0)) && (res.provisiones >= (cost.provisiones || 0))
        && (res.esencia >= (cost.esencia || 0));
      if (!resOk) return false;
      // Espacio libre en almacen para lo que no es esencia (el coste se va, no ocupa)
      return true;
    }

    // ============================================================
    // RENDER BUILDINGS
    // ============================================================
    function renderBuildings(res) {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      if (!res) res = calcRes(vs); // fallback si no se pasó res
      var grid = document.getElementById('bldGrid');
      grid.innerHTML = '';

      BUILDINGS.forEach(function (def) {
        var lvl = (vs.buildings[def.id] && vs.buildings[def.id].level) || 0;
        var next = lvl + 1;
        var cost = def.cost(lvl);
        var prod = def.prod(next);
        var inQueue = vs.build_queue && vs.build_queue.id === def.id;
        var anyQueue = !!vs.build_queue;
        var afford = canAfford(cost, res);
        var icon = def.icon || '🏗️';

        var timeLeftSec = 0, pct = 0;
        if (inQueue) {
          var finish = new Date(vs.build_queue.finish_at).getTime();
          timeLeftSec = Math.max(0, Math.ceil((finish - Date.now()) / 1000));
          var total = def.time(lvl);
          pct = Math.min(100, Math.round(((total - timeLeftSec) / total) * 100));
        }

        var prodHTML = '';
        if (prod.madera) prodHTML += '<span class="pbadge" style="color:var(--madera);border-color:rgba(200,164,90,.3);background:rgba(200,164,90,.05)">🌲 +' + fmt(prod.madera) + '/h</span>';
        if (prod.piedra) prodHTML += '<span class="pbadge" style="color:var(--piedra);border-color:rgba(160,168,176,.3);background:rgba(160,168,176,.05)">⛰️ +' + fmt(prod.piedra) + '/h</span>';
        if (prod.hierro) prodHTML += '<span class="pbadge" style="color:var(--hierro);border-color:rgba(224,120,96,.3);background:rgba(224,120,96,.05)">⚙️ +' + fmt(prod.hierro) + '/h</span>';
        if (prod.provisiones) prodHTML += '<span class="pbadge" style="color:var(--prov);border-color:rgba(111,207,122,.3);background:rgba(111,207,122,.05)">🌾 +' + fmt(prod.provisiones) + '/h</span>';
        if (prod.esencia) prodHTML += '<span class="pbadge" style="color:var(--esencia);border-color:rgba(192,132,252,.3);background:rgba(192,132,252,.05)">✨ +' + fmt(prod.esencia) + '/h</span>';

        var costHTML = '';
        if (cost.madera) costHTML += '<span class="cost-i ' + (res.madera >= (cost.madera || 0) ? 'ok' : 'no') + '">🌲 ' + fmt(cost.madera) + '</span>';
        if (cost.piedra) costHTML += '<span class="cost-i ' + (res.piedra >= (cost.piedra || 0) ? 'ok' : 'no') + '">⛰️ ' + fmt(cost.piedra) + '</span>';
        if (cost.hierro) costHTML += '<span class="cost-i ' + (res.hierro >= (cost.hierro || 0) ? 'ok' : 'no') + '">⚙️ ' + fmt(cost.hierro) + '</span>';
        if (cost.provisiones) costHTML += '<span class="cost-i ' + (res.provisiones >= (cost.provisiones || 0) ? 'ok' : 'no') + '">🌾 ' + fmt(cost.provisiones) + '</span>';
        if (cost.esencia) costHTML += '<span class="cost-i ' + (res.esencia >= (cost.esencia || 0) ? 'ok' : 'no') + '">✨ ' + fmt(cost.esencia) + '</span>';

        var btnCls = 'avail', btnTxt = 'Mejorar a Nivel ' + next;
        if (inQueue) { btnCls = 'busy'; btnTxt = 'Construyendo... (' + timeLeftSec + 's)'; }
        else if (!afford || anyQueue) { btnCls = 'insuf'; btnTxt = !afford ? 'Recursos insuficientes' : 'Cola ocupada'; }

        var card = document.createElement('div');
        card.className = 'bld-card';
        card.innerHTML = '<div class="bld-head" onclick="openBuildingDetail(\'' + def.id + '\')" style="cursor:pointer"><div class="bld-ico">' + icon + '</div><div><div class="bld-name">' + def.name + '</div><div class="bld-lvl">Nivel: <span class="lvl-n">' + lvl + '</span></div></div><span class="detail-badge">ver detalle &rsaquo;</span></div>'
          + '<div class="bld-body"><div class="bld-desc">'
          + (def.id === 'reclutamiento'
            ? 'Nivel ' + lvl + ' → ' + getAldeanosProd(vs.buildings) + ' aldeanos/h'
            : def.id === 'barracas'
              ? 'Nivel ' + lvl + ' → ' + getBarracksCapacity(vs.buildings) + ' plazas de tropas'
              : def.id === 'granja'
                ? 'Nivel ' + lvl + ' → ' + (5 + lvl) + ' provisiones/aldeano/h en granja'
                : 'Nivel actual: ' + lvl) + '</div>'
          + (prodHTML ? '<div class="prod-row">' + prodHTML + '</div>' : '')
          + '<div class="cost-row">' + costHTML + '</div>'
          + (inQueue ? '<div class="pbar-wrap"><div class="pbar-fill" style="width:' + pct + '%"></div></div>' : '')
          + '<button class="bld-btn ' + btnCls + '" onclick="startBuild(\'' + def.id + '\')">' + btnTxt + '</button></div>';
        grid.appendChild(card);
      });
    }

    // ============================================================
    // RENDER QUEUE
    // ============================================================
    function renderQueue(vs) {
      var ids = ['qItems', 'qItemsOv'];
      ids.forEach(function (elId) {
        var el = document.getElementById(elId);
        var emId = elId === 'qItems' ? 'qEmpty' : 'qEmptyOv';
        var em = document.getElementById(emId);
        if (!vs.build_queue) { em.style.display = 'block'; el.innerHTML = ''; return; }
        em.style.display = 'none';
        var q = vs.build_queue;
        var def = BUILDINGS.find(function (b) { return b.id === q.id; });
        var finish = new Date(q.finish_at).getTime();
        var tl = Math.max(0, Math.ceil((finish - Date.now()) / 1000));
        var lvl = ((vs.buildings[q.id] && vs.buildings[q.id].level) || 0);
        var total = def ? def.time(lvl) : 60;
        var pct = Math.min(100, Math.round(((total - tl) / total) * 100));
        var icon = def ? def.icon : '🏗️';
        el.innerHTML = '<div class="queue-item"><div class="queue-icon">' + icon + '</div>'
          + '<div class="queue-info"><div class="queue-name">' + (def ? def.name : q.id) + ' -> Nivel ' + (lvl + 1) + '</div>'
          + '<div class="queue-time">' + tl + 's restantes</div>'
          + '<div class="qbar"><div class="qbar-fill" style="width:' + pct + '%"></div></div></div></div>';
      });

      // RENDER MISSIONS
      var mIds = ['qItems', 'qItemsOv']; // We use the same containers or add specific ones
      mIds.forEach(function (elId) {
        var el = document.getElementById(elId);
        if (!vs.mission_queue || vs.mission_queue.length === 0) return;

        vs.mission_queue.forEach(m => {
          var finish = new Date(m.finish_at).getTime();
          var now = Date.now();
          var tl = Math.max(0, Math.ceil((finish - now) / 1000));

          // FILTRO MEJORADO: No mostrar misiones completadas
          // Si ya terminó (tl=0) y es una misión de retorno, no mostrar (será procesada en resolveMissions)
          if (tl <= 0 && m.type === 'return') return;
          // Para otras misiones, dar 5 segundos de gracia antes de ocultar
          if (tl <= 0 && now - finish > 5000) return;

          var start = m.start_at ? new Date(m.start_at).getTime() : (finish - 60000);
          var total = Math.max(1, Math.ceil((finish - start) / 1000));
          var pct = Math.min(100, Math.round(((total - tl) / total) * 100));

          var icon, name, color;
          if (m.type === 'spy')    { icon = '🏹'; name = 'Espionaje a [' + m.tx + ',' + m.ty + ']'; color = 'var(--accent)'; }
          else if (m.type === 'return') { icon = '🏠'; name = 'Tropas regresando'; color = 'var(--ok)'; }
          else if (m.type === 'found') { icon = '🏘️'; name = 'Colonos hacia [' + m.tx + ',' + m.ty + ']'; color = 'var(--gold)'; }
          else if (m.type === 'move') { icon = '⚔'; name = 'Tropas → [' + m.tx + ',' + m.ty + ']'; color = 'var(--accent)'; }
          else if (m.type === 'reinforce') { icon = '🛡️'; name = 'Refuerzo → [' + m.tx + ',' + m.ty + ']'; color = 'var(--accent2)'; }
          else if (m.type === 'transport') { icon = '📦'; name = 'Caravana → [' + m.tx + ',' + m.ty + ']'; color = 'var(--madera)'; }
          else if (m.type === 'return_reinforce') { icon = '↩'; name = 'Tropas volviendo a casa'; color = 'var(--ok)'; }
          else                     { icon = '⚔️'; name = 'Ataque a [' + m.tx + ',' + m.ty + ']'; color = 'var(--danger)'; }

          var timeStr = tl > 3600 ? Math.floor(tl/3600) + 'h ' + Math.floor((tl%3600)/60) + 'm'
                      : tl > 60   ? Math.floor(tl/60) + 'm ' + (tl%60) + 's'
                      : tl + 's';

          var div = document.createElement('div');
          div.className = 'queue-item mission';
          div.style.borderLeftColor = color;
          var cancelBtn = (m.type !== 'return' && m.type !== 'found' && m.type !== 'move' && m.type !== 'reinforce' && m.type !== 'transport' && m.type !== 'return_reinforce')
            ? '<button onclick="cancelMission(\'' + (m.mid || m.finish_at) + '\')" style="background:rgba(255,61,90,.1);border:1px solid rgba(255,61,90,.3);color:var(--danger);padding:3px 8px;border-radius:3px;font-size:.62rem;cursor:pointer;margin-top:4px;">✗ Cancelar</button>'
            : '';
          div.innerHTML = '<div class="queue-icon">' + icon + '</div>'
            + '<div class="queue-info"><div class="queue-name">' + name + '</div>'
            + '<div class="queue-time">' + timeStr + '</div>'
            + '<div class="qbar"><div class="qbar-fill" style="width:' + pct + '%; background:' + color + '"></div></div>'
            + cancelBtn + '</div>';
          el.appendChild(div);
        });
      });
    }

    // ============================================================
    // MAP — con cámara libre (offset), flechas y WASD
    // ============================================================
    var mapCamX = null; // null = centrado en aldea
    var mapCamY = null;

    function panMap(dx, dy, resetToVillage) {
      if (!activeVillage) return;
      if (resetToVillage) {
        mapCamX = activeVillage.x;
        mapCamY = activeVillage.y;
      } else {
        if (mapCamX === null) mapCamX = activeVillage.x;
        if (mapCamY === null) mapCamY = activeVillage.y;
        mapCamX = Math.max(1, Math.min(MAP_SIZE, mapCamX + dx));
        mapCamY = Math.max(1, Math.min(MAP_SIZE, mapCamY + dy));
      }
      renderMap();
      try { sessionStorage.setItem('EW_camX', String(mapCamX)); sessionStorage.setItem('EW_camY', String(mapCamY)); } catch(e) {}
    }

    // Teclado: flechas + WASD (solo cuando el mapa está activo)
    document.addEventListener('keydown', function (e) {
      var mapActive = document.getElementById('page-map') &&
        document.getElementById('page-map').classList.contains('active');
      if (!mapActive) return;
      // No interferir con inputs de texto
      if (['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement && document.activeElement.tagName)) return;
      var moved = false;
      if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') { panMap(0, -1); moved = true; }
      if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') { panMap(0, 1); moved = true; }
      if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') { panMap(-1, 0); moved = true; }
      if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') { panMap(1, 0); moved = true; }
      if (moved) e.preventDefault();
    });

    function renderMap() {
      if (!activeVillage) { return; }
      if (allVillages.length === 0) {
        document.getElementById('mapCoordsDisplay').textContent = 'Cargando...';
        // Solo recargar mapa si han pasado más de 5 minutos (reduce queries)
        var _nowMap = Date.now();
        var _doLoad = (_nowMap - _lastMapLoad) > 300000 || allVillages.length === 0;
        _lastMapLoad = _doLoad ? _nowMap : _lastMapLoad;
        (_doLoad ? loadAllVillages() : Promise.resolve()).then(function () {
          if (allVillages.length > 0) renderMap();
          else document.getElementById('mapCoordsDisplay').textContent = 'No se pudieron cargar los datos del mapa.';
        });
        return;
      }

      // Cámara: si es null, centrar en aldea
      var cx = (mapCamX !== null) ? mapCamX : activeVillage.x;
      var cy = (mapCamY !== null) ? mapCamY : activeVillage.y;
      if (mapCamX === null) { mapCamX = activeVillage.x; mapCamY = activeVillage.y; }

      var r = MAP_VIEW;
      var size = r * 2 + 1;

      var npcLookup = {};
      (typeof NPC_CASTLES !== 'undefined' ? NPC_CASTLES : []).forEach(function (n) { npcLookup[n.x + ',' + n.y] = n; });

      // Construir lookup de aldeas por coordenada
      var lookup = {};
      allVillages.forEach(function (v) { lookup[v.x + ',' + v.y] = v; });

      var grid = document.getElementById('mapGrid');
      grid.style.gridTemplateColumns = 'repeat(' + size + ', 28px)';
      grid.innerHTML = '';

      // Indica si la cámara está descentrada del jugador
      var isOffCenter = (cx !== activeVillage.x || cy !== activeVillage.y);
      document.getElementById('mapCoordsDisplay').textContent =
        'Cámara: [' + cx + ', ' + cy + ']' +
        (isOffCenter ? '  |  Tu aldea: [' + activeVillage.x + ', ' + activeVillage.y + ']  |  (⌂ para volver)' : '  |  Vista: [' + (cx - r) + ',' + (cy - r) + '] a [' + (cx + r) + ',' + (cy + r) + ']');

      for (var dy2 = -r; dy2 <= r; dy2++) {
        for (var dx2 = -r; dx2 <= r; dx2++) {
          var wx = cx + dx2, wy = cy + dy2;
          var key = wx + ',' + wy;
          var vill = lookup[key];
          var npc = npcLookup[key];

          var cell = document.createElement('div');
          cell.className = 'map-cell';
          cell.title = '[' + wx + ', ' + wy + ']';

          if (wx < 1 || wx > MAP_SIZE || wy < 1 || wy > MAP_SIZE) {
            cell.classList.add('out-of-bounds');
          } else if (vill) {
            var isOwn = (vill.owner_id === currentUser.id);
            var isAlly = !isOwn && (_allyUserIds && _allyUserIds.has(vill.owner_id));
            cell.classList.add(isOwn ? 'own' : (isAlly ? 'ally' : 'enemy'));
            cell.textContent = isOwn ? '🏠' : (isAlly ? '🤝' : '⚔️');
            if (wx === activeVillage.x && wy === activeVillage.y) cell.classList.add('center-marker');
            (function (v, own, ally, x, y) { cell.onclick = function () { selectCell(v, own, ally, x, y); }; })(vill, isOwn, isAlly, wx, wy);
          } else if (npc) {
            cell.classList.add('npc');
            var obj = playerObjectives.find(o => o.objective_id === npc.id);
            var isCleared = obj && obj.status === 'cleared';
            cell.textContent = isCleared ? '🏰' : '🛡️';
            if (isCleared) { cell.style.opacity = '0.4'; cell.title += ' (SUPERADO)'; }
            (function (n, nx, ny) { cell.onclick = function () { selectNPC(n, nx, ny); }; })(npc, wx, wy);
          } else {
            cell.classList.add('empty');
            if (wx === activeVillage.x && wy === activeVillage.y) cell.classList.add('center-marker');
            (function (x, y) { cell.onclick = function () { selectCell(null, false, x, y); }; })(wx, wy);
          }
          grid.appendChild(cell);
        }
      }
    }

    function selectNPC(npc, x, y) {
      var panel = document.getElementById('mapPanel');
      var title = document.getElementById('mapPanelTitle');
      var sub = document.getElementById('mapPanelSub');
      var actions = document.getElementById('mapActions');
      panel.classList.add('show');

      var inRange = isInTorreRange(x, y);
      var obj = playerObjectives.find(o => o.objective_id === npc.id);
      var isCleared = obj && obj.status === 'cleared';
      var isSpied   = obj && obj.status === 'spied';

      // Fecha de derrota (guardada en last_interaction)
      var clearDateStr = '';
      if (isCleared && obj.last_interaction) {
        var d = new Date(obj.last_interaction);
        clearDateStr = ' · ' + d.toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit', year: 'numeric' })
          + ' ' + d.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
      }

      var statusTag = isCleared
        ? ' <span style="color:var(--ok)">[DERROTADO' + clearDateStr + ']</span>'
        : isSpied ? ' <span style="color:var(--accent)">[ESPIADO]</span>' : '';

      title.innerHTML = npc.name + ' ' + (npc.icon || '🏇') + statusTag;

      // Stats: solo visibles si espiado o derrotado
      if (isCleared || isSpied) {
        sub.innerHTML = '[' + x + ', ' + y + '] · '
          + 'PG: ' + fmt(npc.hp) + ' · CA: ' + npc.defense + ' · XP: ' + fmt(npc.rewards.experience);
      } else {
        sub.innerHTML = '[' + x + ', ' + y + '] · <span style="color:var(--dim);font-style:italic;">Stats desconocidos — envía un explorador</span>';
      }

      if (isCleared) {
        actions.innerHTML = '<span style="color:var(--ok);font-size:.72rem;">✅ Ya derrotaste a este caballero.</span>';
      } else if (inRange) {
        actions.innerHTML = ''
          + '<button class="map-action-btn spy" onclick="openMissionModal(\'spy\', \'' + npc.id + '\', ' + x + ', ' + y + ')">🔍 Espiar</button>'
          + '<button class="map-action-btn atk" onclick="openMissionModal(\'attack\', \'' + npc.id + '\', ' + x + ', ' + y + ')">⚔️ Atacar</button>';
      } else {
        actions.innerHTML = '<span style="color:var(--danger);font-size:.72rem;">⚠ Fuera de alcance — mejora la Torre de Vigía</span>';
      }
    }

    function openMissionModal(type, targetId, x, y) {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      var res = calcRes(vs);
      var troops = vs.troops || {};

      // Aldeanos LIBRES (no asignados a recursos) — los únicos que pueden enviarse
      var aldLibres = res.aldeanos_libres || 0;

      var html = '<div class="bld-modal-overlay" id="missionOverlay" onclick="closeMissionOverlay(event)">'
        + '<div class="bld-modal" style="max-width:400px;">'
        + '<div class="bld-modal-head">'
        + '<div class="bld-modal-icon">' + (type === 'spy' ? '🏹' : '⚔️') + '</div>'
        + '<div><div class="bld-modal-title">' + (type === 'spy' ? 'Preparar Espionaje' : 'Enviar Ataque') + '</div>'
        + '<div class="bld-modal-sub">Destino: [' + x + ', ' + y + ']</div></div>'
        + '<button class="bld-modal-close" onclick="document.getElementById(\'bldModal\').style.display=\'none\';">&#x2715;</button>'
        + '</div>'
        + '<div class="bld-modal-body" style="padding:15px;">';

      if (type === 'spy') {
        var scouts = troops.explorador || 0;
        if (scouts <= 0) {
          html += '<p style="color:var(--danger); text-align:center;">Necesitas al menos 1 Explorador para espiar.</p>';
        } else {
          html += '<p>Selecciona cuántos exploradores enviar:</p>'
            + '<input type="number" id="mUnits_explorador" value="1" min="1" max="' + scouts + '" style="width:100%; margin-bottom:10px;">'
            + '<p style="font-size:0.7rem; color:var(--dim);">Solo los exploradores pueden realizar misiones de espionaje.</p>';
        }
      } else {
        html += '<p>Selecciona tus tropas:</p>';
        Object.keys(TROOP_TYPES).forEach(k => {
          var count = (k === 'aldeano') ? aldLibres : (troops[k] || 0);
          if (count > 0) {
            html += '<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">'
              + '<span>' + TROOP_TYPES[k].icon + ' ' + TROOP_TYPES[k].name + ' (' + count + ' disp.)</span>'
              + '<input type="number" id="mUnits_' + k + '" value="0" min="0" max="' + count + '" style="width:60px;" oninput="calcMissionETA(' + x + ',' + y + ')">'
              + '</div>';
          }
        });
        
        // Add creatures
        var creatures = vs.creatures || defaultCreatures();
        var hasCreatures = false;
        Object.keys(CREATURE_TYPES).forEach(k => {
          var count = creatures[k] || 0;
          if (count > 0) {
            if (!hasCreatures) {
              html += '<div style="margin-top:16px;padding-top:12px;border-top:1px solid var(--border);"><p style="color:var(--accent);font-size:.85rem;">🐉 Criaturas:</p></div>';
              hasCreatures = true;
            }
            html += '<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">'
              + '<span>' + CREATURE_TYPES[k].icon + ' ' + CREATURE_TYPES[k].name + ' (' + count + ' disponibles)</span>'
              + '<input type="number" id="mUnits_' + k + '" value="0" min="0" max="' + count + '" style="width:60px;">'
              + '</div>';
          }
        });
        
        if (Object.values(troops).reduce((a, b) => a + b, 0) === 0 && !hasCreatures) {
          html += '<p style="color:var(--danger);">No tienes tropas ni criaturas disponibles.</p>';
        }
      }

      // ETA based on distance + slowest troop
      var dist = Math.max(Math.abs(x - activeVillage.x), Math.abs(y - activeVillage.y));
      html += '</div>'
        + '<div style="padding:8px 15px;border-top:1px solid var(--border);background:var(--panel2);">'
        + '<div style="font-size:.68rem;color:var(--dim);margin-bottom:2px;">📍 Distancia: ' + dist + ' casillas</div>'
        + '<div id="missionETA" style="font-size:.8rem;color:var(--accent);">Selecciona tropas para ver ETA</div>'
        + '</div>'
        + '<div class="bld-modal-footer">'
        + '<button class="bld-footer-btn avail" onclick="executeMissionClick(\'' + type + '\', \'' + targetId + '\', ' + x + ', ' + y + ')">Confirmar Misión</button>'
        + '</div>'
        + '</div></div>';
      var wrap = document.getElementById('bldModal'); // reusing building modal container
      wrap.innerHTML = html;
      wrap.style.display = 'block';
    }

    function calcMissionETA(destX, destY) {
      if (!activeVillage) return;
      var dist = Math.max(Math.abs(destX - activeVillage.x), Math.abs(destY - activeVillage.y));
      var minSpeed = Infinity;
      // Check all selected troops
      Object.keys(TROOP_TYPES).forEach(function(k) {
        var input = document.getElementById('mUnits_' + k);
        if (input && parseInt(input.value) > 0) {
          var spd = TROOP_TYPES[k].speed || 1;
          if (spd < minSpeed) minSpeed = spd;
        }
      });
      Object.keys(CREATURE_TYPES).forEach(function(k) {
        var input = document.getElementById('mUnits_' + k);
        if (input && parseInt(input.value) > 0) {
          var spd = CREATURE_TYPES[k].speed || 1;
          if (spd < minSpeed) minSpeed = spd;
        }
      });
      var etaEl = document.getElementById('missionETA');
      if (!etaEl) return;
      if (!isFinite(minSpeed)) {
        etaEl.textContent = 'Selecciona tropas para ver ETA';
        etaEl.style.color = 'var(--dim)';
        return;
      }
      // Speed = casillas/min
      var etaSecs = Math.ceil((dist / minSpeed) * 60);
      var arrivalTime = new Date(Date.now() + etaSecs * 1000);
      var arrStr = arrivalTime.toLocaleTimeString('es-ES', { hour:'2-digit', minute:'2-digit', second:'2-digit' });
      etaEl.textContent = '⏱ ' + fmtTime(etaSecs) + ' · Llegada ~' + arrStr + ' (vel. mín: ' + minSpeed + ')';
      etaEl.style.color = 'var(--accent)';
    }

    function closeMissionOverlay(event) {
      if (event.target.id === 'missionOverlay') {
        document.getElementById('bldModal').style.display = 'none';
      }
    }

    async function executeMissionClick(type, targetId, x, y) {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      var res = calcRes(vs);
      var selectedTroops = {};
      var total = 0;

      // Collect troops
      Object.keys(TROOP_TYPES).forEach(k => {
        var el = document.getElementById('mUnits_' + k);
        if (el) {
          var val = parseInt(el.value) || 0;
          if (val > 0) {
            selectedTroops[k] = val;
            total += val;
          }
        }
      });

      // Collect creatures
      Object.keys(CREATURE_TYPES).forEach(k => {
        var el = document.getElementById('mUnits_' + k);
        if (el) {
          var val = parseInt(el.value) || 0;
          if (val > 0) {
            selectedTroops[k] = val;
            total += val;
          }
        }
      });

      if (total <= 0) {
        showNotif("Debes seleccionar al menos una unidad.", "err");
        return;
      }

      // Verificar aldeanos libres si se seleccionaron
      if (selectedTroops.aldeano && selectedTroops.aldeano > 0) {
        var aldLibres = res.aldeanos_libres || 0;
        if (selectedTroops.aldeano > aldLibres) {
          showNotif('Solo tienes ' + aldLibres + ' aldeanos libres. ' + (res.aldeanos_total - aldLibres) + ' están asignados a recursos.', 'err');
          return;
        }
      }

      // Verificar tropas y criaturas disponibles
      for (var k in selectedTroops) {
        if (k === 'aldeano') continue; // ya verificado arriba
        
        if (TROOP_TYPES[k]) {
          var available = vs.troops[k] || 0;
          if (selectedTroops[k] > available) {
            showNotif('No tienes suficientes ' + TROOP_TYPES[k].name + 's', 'err');
            return;
          }
        } else if (CREATURE_TYPES[k]) {
          var available = (vs.creatures && vs.creatures[k]) || 0;
          if (selectedTroops[k] > available) {
            showNotif('No tienes suficientes ' + CREATURE_TYPES[k].name + 's', 'err');
            return;
          }
        }
      }

      document.getElementById('bldModal').style.display = 'none';
      await startMission(type, x, y, targetId, selectedTroops);
    }

    function goToCoords() {
      var x = parseInt(document.getElementById('mapGoX').value);
      var y = parseInt(document.getElementById('mapGoY').value);
      if (isNaN(x) || isNaN(y)) { showNotif('Coordenadas inválidas', 'err'); return; }
      mapOffX = Math.max(0, Math.min(MAP_SIZE - MAP_VIEW, x - Math.floor(MAP_VIEW/2)));
      mapOffY = Math.max(0, Math.min(MAP_SIZE - MAP_VIEW, y - Math.floor(MAP_VIEW/2)));
      renderMap();
      showNotif('Navegando a [' + x + ', ' + y + ']', 'ok');
    }

    async function foundVillage(x, y) {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      var myVillagesList = myVillages || [];
      if (myVillagesList.length >= 10) { showNotif('Máximo 10 aldeas', 'err'); return; }
      var exploradores = (vs.troops && vs.troops.explorador) || 0;
      if (exploradores < 1) { showNotif('Necesitas al menos 1 explorador', 'err'); return; }
      var aldeanos = (vs.troops && vs.troops.aldeano) || 0;
      if (aldeanos < 50) { showNotif('Necesitas 50 aldeanos', 'err'); return; }

      // Calcular tiempo de viaje — el más lento marca la velocidad (aldeano speed=1, explorador speed=4)
      var dist = Math.max(Math.abs(x - activeVillage.x), Math.abs(y - activeVillage.y));
      var foundingTroops = { explorador: 1, aldeano: 50 };
      var minSpeed = Object.keys(foundingTroops).reduce(function(min, k) {
        var spd = (TROOP_TYPES[k] && TROOP_TYPES[k].speed) || 1;
        return Math.min(min, spd);
      }, 999);
      if (minSpeed === 999) minSpeed = 1;
      var seconds = Math.ceil((dist / minSpeed) * MISSION_FACTOR);
      var arrivalStr = new Date(Date.now() + seconds * 1000).toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });

      if (!confirm('Fundar aldea en [' + x + ', ' + y + ']?\n\nConsume 1 explorador + 50 aldeanos.\nTiempo de viaje: ' + fmtTime(seconds) + ' (llegada ~' + arrivalStr + ')')) return;

      // Guardar valores originales por si hay que revertir
      var origExploradores = exploradores;
      var origAldeanos = aldeanos;
      var origAssigned = vs.aldeanos_assigned ? JSON.parse(JSON.stringify(vs.aldeanos_assigned)) : null;

      // Consumir tropas
      vs.troops.explorador = Math.max(0, exploradores - 1);
      consumeAldeanos(vs, 50);

      // Añadir misión de fundación al queue
      var finishAt = new Date(Date.now() + seconds * 1000).toISOString();
      if (!vs.mission_queue) vs.mission_queue = [];
      vs.mission_queue.push({
        type: 'found',
        tx: x,
        ty: y,
        targetId: null,
        troops: { explorador: 1, aldeano: 50 },
        finish_at: finishAt,
        start_at: new Date().toISOString()
      });

      try {
        flushVillage();
        showNotif('🏠 Colonos en camino a [' + x + ', ' + y + ']! Llegarán en ' + fmtTime(seconds), 'ok');
        tick();
      } catch(e) {
        // Revertir si falla el guardado
        vs.troops.explorador = origExploradores;
        vs.troops.aldeano = origAldeanos;
        if (origAssigned) vs.aldeanos_assigned = origAssigned;
        vs.mission_queue = vs.mission_queue.filter(function(m) { return m.finish_at !== finishAt; });
        showNotif('Error al enviar colonos: ' + (e.message || e), 'err');
        console.error('foundVillage error:', e);
      }
    }

    async function executeFounding(m) {
      // Crear la aldea en Supabase cuando llegan los colonos
      var myVillagesList = myVillages || [];
      if (myVillagesList.length >= 10) {
        await sendSystemReport(currentUser.id, '⚠️ COLONOS RECHAZADOS',
          'Tus colonos llegaron a [' + m.tx + ', ' + m.ty + '] pero ya tienes el máximo de 10 aldeas. Los colonos se perdieron.');
        return;
      }
      // Verificar que la casilla siga libre
      var occupied = allVillages.find(function(v) { return v.x === m.tx && v.y === m.ty; });
      if (occupied) {
        await sendSystemReport(currentUser.id, '⚠️ COLONOS RECHAZADOS',
          'Tus colonos llegaron a [' + m.tx + ', ' + m.ty + '] pero otro jugador ya fundó una aldea ahí. Los colonos se perdieron.');
        return;
      }
      try {
        var newVillageName = 'Aldea ' + (myVillagesList.length + 1);
        var r = await sbClient.from('villages').insert({
          owner_id: currentUser.id,
          name: newVillageName,
          cx: m.tx,
          cy: m.ty,
          build_queue: null,
          mission_queue: [],
          summoning_queue: [],
          training_queue: []
        }).select('id').single();
        if (r.error) throw r.error;

        var newId = r.data.id;
        await sbClient.from('resources').insert({ village_id: newId, madera: 500, piedra: 300, hierro: 100, prov: 200, esencia: 0 });
        await sbClient.from('buildings').insert({
          village_id: newId,
          aserradero: 1, cantera: 1, minehierro: 1, granja: 1, almacen: 1,
          torre: 1, barracas: 1, circulo: 1, reclutamiento: 1,
          muralla: 0, lab: 0
        });
        var newTroops = { village_id: newId };
        Object.keys(TROOP_TYPES).forEach(function(k) { newTroops[k] = k === 'aldeano' ? 50 : 0; });
        await sbClient.from('troops').insert(newTroops);

        await sendSystemReport(currentUser.id, '🏠 ¡NUEVA ALDEA FUNDADA!',
          'Tus colonos han llegado a [' + m.tx + ', ' + m.ty + '] y han fundado ' + newVillageName + '.\n¡Ya puedes seleccionarla en el desplegable de aldeas!');
        showNotif('¡Nueva aldea fundada en [' + m.tx + ', ' + m.ty + ']!', 'ok');
        await loadMyVillages();
        renderMap();
      } catch(e) {
        console.error('executeFounding error:', e);
        await sendSystemReport(currentUser.id, '❌ ERROR AL FUNDAR ALDEA',
          'Los colonos llegaron a [' + m.tx + ', ' + m.ty + '] pero ocurrió un error al crear la aldea: ' + (e.message || e));
      }
    }

    async function openMapDM(targetUserId, targetName) {
      if (!targetUserId) { showNotif('No se puede identificar al jugador', 'err'); return; }
      showNotif('Abriendo chat con ' + targetName + '…', 'ok');
      // Navigate to messages and open DM
      showPage('messages', document.querySelector('.nav-item[onclick*="messages"]'));
      await new Promise(r => setTimeout(r, 300));
      // Find or create DM thread with this user
      try {
        var r = await sbClient.rpc('get_or_create_dm_thread', {
          p_user1: currentUser.id, p_user2: targetUserId
        });
        if (r.error) throw r.error;
        currentThreadId = r.data;
        currentThreadType = 'dm';
        renderMessagesHeader('dm', 'DM con ' + targetName);
        subscribeToThread(currentThreadId);
        await loadThreadMessages('dm');
        await renderThreads();
      } catch(e) {
        showNotif('Error: ' + e.message, 'err');
      }
    }

    function selectCell(village, isOwn, isAlly, x, y) {
      // backward compat: if called with 4 args (old path), shift
      if (typeof isAlly === 'number') { y = x; x = isAlly; isAlly = false; }
      var panel = document.getElementById('mapPanel');
      var title = document.getElementById('mapPanelTitle');
      var sub = document.getElementById('mapPanelSub');
      var actions = document.getElementById('mapActions');
      panel.classList.add('show');

      var inRange = isInTorreRange(x, y);
      var rng = activeVillage ? getTorreRange(activeVillage.state.buildings) : 0;
      var rngTag = rng === 0
        ? ' <span style="color:var(--danger);font-size:.64rem;">⚠ Sin torre</span>'
        : (inRange
          ? ' <span style="color:var(--ok);font-size:.64rem;">✓ En rango (' + rng + ')</span>'
          : ' <span style="color:var(--danger);font-size:.64rem;">✗ Fuera de rango (' + rng + ')</span>');

      if (!village) {
        title.textContent = 'Casilla vacía';
        sub.innerHTML = '[' + x + ', ' + y + ']' + rngTag;
        if (inRange) {
          var myVillageCount = (myVillages || []).length;
          if (myVillageCount >= 10) {
            actions.innerHTML = '<span style="font-size:.7rem;color:var(--danger);">Máximo 10 aldeas alcanzado.</span>';
          } else {
            actions.innerHTML = '<button class="map-action-btn move" onclick="foundVillage(' + x + ',' + y + ')">🏠 Fundar Aldea<br><span style="font-size:.6rem;color:rgba(255,255,255,.6);">Consume 1 explorador + 50 aldeanos</span></button>';
          }
        } else {
          var rng2 = activeVillage ? getTorreRange(activeVillage.state.buildings) : 0;
          var outMsg = rng2 === 0
            ? '<span style="font-size:.7rem;color:var(--danger)">⚠ No tienes Torre de Vigía. Constrúyela para poder fundar aldeas aquí.</span>'
            : '<span style="font-size:.7rem;color:var(--danger)">⚠ Fuera de alcance. Mejora la Torre de Vigía (nivel actual: ' + rng2 + ') para fundar una aldea aquí.</span>';
          actions.innerHTML = outMsg;
        }
        return;
      }

      var ownerName = (village.state && village.state.owner_name) ? village.state.owner_name : 'Desconocido';

      if (isOwn) {
        title.textContent = (village.name || 'Mi Aldea') + ' 🏠';
        sub.innerHTML = '[' + x + ', ' + y + '] · Tuya' + rngTag;
        if (village.id === activeVillage.id) {
          actions.innerHTML = '<span style="font-size:.7rem;color:var(--dim);">Esta es tu aldea activa.</span>';
        } else {
          var vid2 = village.id || '';
          var vname2 = (village.name || 'Aldea').replace(/'/g, "\\'");
          actions.innerHTML = ''
            + '<button class="map-action-btn move" onclick="openMoveModal(\'' + vid2 + '\',\'' + vname2 + '\',' + x + ',' + y + ',false)">⚔ Mover tropas</button>'
            + '<button class="map-action-btn move" style="background:rgba(212,146,58,.1);border-color:var(--madera);color:var(--madera);" onclick="openTransportModal(\'' + vid2 + '\',\'' + vname2 + '\',' + x + ',' + y + ',false)">📦 Transportar recursos</button>';
        }
      } else if (isAlly) {
        var allyOwnerId = (village.owner_id || '');
        var allyVid = (village.id || '');
        var allyVname = (village.name || 'Aldea aliada').replace(/'/g, "\\'");
        title.textContent = (village.name || 'Aldea aliada') + ' 🤝';
        sub.innerHTML = '[' + x + ', ' + y + '] · Aliado' + rngTag;
        if (inRange) {
          actions.innerHTML = ''
            + '<button class="map-action-btn move" onclick="openMoveModal(\'' + allyVid + '\',\'' + allyVname + '\',' + x + ',' + y + ',true)">🛡️ Enviar refuerzo</button>'
            + '<button class="map-action-btn move" style="background:rgba(212,146,58,.1);border-color:var(--madera);color:var(--madera);" onclick="openTransportModal(\'' + allyVid + '\',\'' + allyVname + '\',' + x + ',' + y + ',true)">📦 Enviar recursos</button>'
            + '<button class="map-action-btn spy" style="background:rgba(0,212,255,.1);border-color:var(--accent);color:var(--accent);" onclick="openMapDM(\'' + allyOwnerId + '\',\'' + escapeHtml(ownerName || 'Aliado') + '\')">✉️ Mensaje</button>';
        } else {
          actions.innerHTML = '<span style="color:var(--danger);font-size:.72rem;">⚠ Fuera de alcance — mejora la Torre de Vigía</span>';
        }
      } else {
        title.textContent = (village.name || 'Aldea enemiga') + ' ⚔️';
        sub.textContent = '[' + x + ', ' + y + '] · ' + String(ownerName || '');
        var span = document.createElement('span');
        span.style.fontSize = '.64rem';
        span.style.marginLeft = '6px';
        if (rng === 0) { span.style.color = 'var(--danger)'; span.textContent = '⚠ Sin torre'; }
        else if (inRange) { span.style.color = 'var(--ok)'; span.textContent = '✓ En rango (' + rng + ')'; }
        else { span.style.color = 'var(--danger)'; span.textContent = '✗ Fuera de rango (' + rng + ')'; }
        sub.appendChild(span);
        var ownerId = (village.owner_id || village.user_id || '');
        var vid = (village.id || '');
        if (inRange) {
          actions.innerHTML = ''
            + '<button class="map-action-btn atk" onclick="openMissionModal(\'attack\',\'' + vid + '\',' + x + ',' + y + ')">⚔️ Atacar</button>'
            + '<button class="map-action-btn spy" onclick="openMissionModal(\'spy\',\'' + vid + '\',' + x + ',' + y + ')">🔍 Espiar</button>'
            + '<button class="map-action-btn move" style="background:rgba(0,212,255,.1);border-color:var(--accent);color:var(--accent);" onclick="openMapDM(\'' + ownerId + '\',\'' + ownerName + '\')">✉️ Mensaje</button>';
        } else {
          actions.innerHTML = '<span style="color:var(--danger);font-size:.72rem;">⚠ Fuera de alcance — mejora la Torre de Vigía</span>';
        }
      }
    }

    // ================================================================
    // MOVE / TRANSPORT / REINFORCE SYSTEM
    // ================================================================

    var _allyUserIds = new Set();

    async function loadAllyUserIds() {
      _allyUserIds = new Set();
      if (!_myAllianceId) return;
      try {
        var r = await sbClient.from('alliance_members')
          .select('user_id').eq('alliance_id', _myAllianceId).eq('status', 'active');
        if (r.data) r.data.forEach(function(m) {
          if (m.user_id !== currentUser.id) _allyUserIds.add(m.user_id);
        });
      } catch(e) { console.warn('loadAllyUserIds error', e); }
    }

    function calcTotalCapacity(troops) {
      var cap = 0;
      Object.keys(troops).forEach(function(k) {
        var count = troops[k] || 0;
        if (count <= 0) return;
        var td = TROOP_TYPES[k] || CREATURE_TYPES[k];
        cap += count * ((td && td.capacity) || 0);
      });
      return cap;
    }

    // ============================================================
    // MOVER TROPAS - 2 PASOS
    // Paso 1: Seleccionar tropas → Paso 2: Seleccionar recursos (opcional)
    // Las tropas SE QUEDAN permanentemente en destino
    // ============================================================
    function openMoveModal(destVillageId, destVillageName, tx, ty, isAllyDest) {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      var res = calcRes(vs);
      var troops = vs.troops || {};
      var aldLibres = res.aldeanos_libres || 0;
      var dist = Math.max(Math.abs(tx - activeVillage.x), Math.abs(ty - activeVillage.y));
      
      // PASO 1: Seleccionar tropas
      var troopRows = '';
      var hasTroops = false;
      Object.keys(TROOP_TYPES).forEach(function(k) {
        var count = (k === 'aldeano') ? aldLibres : (troops[k] || 0);
        if (count <= 0) return;
        hasTroops = true;
        var capInfo = (TROOP_TYPES[k].capacity || 0) > 0 ? ' • Cap: ' + TROOP_TYPES[k].capacity : '';
        troopRows += '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">'
          + '<span>' + TROOP_TYPES[k].icon + ' ' + TROOP_TYPES[k].name + ' (' + count + ' disp.)<span style="color:var(--dim);font-size:.7rem;">' + capInfo + '</span></span>'
          + '<input type="number" id="mv_troop_' + k + '" value="0" min="0" max="' + count + '" style="width:64px;" oninput="calcMoveCapacity()">'
          + '</div>';
      });
      
      // Agregar criaturas
      var creatures = vs.creatures || defaultCreatures();
      Object.keys(CREATURE_TYPES).forEach(function(k) {
        var count = creatures[k] || 0;
        if (count <= 0) return;
        hasTroops = true;
        troopRows += '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">'
          + '<span>' + CREATURE_TYPES[k].icon + ' ' + CREATURE_TYPES[k].name + ' (' + count + ' disponibles)</span>'
          + '<input type="number" id="mv_troop_' + k + '" value="0" min="0" max="' + count + '" style="width:64px;" oninput="calcMoveCapacity()">'
          + '</div>';
      });
      
      if (!hasTroops) {
        showNotif('No tienes tropas disponibles.', 'err');
        return;
      }
      
      var titleTxt = isAllyDest ? '🛡️ Enviar refuerzo' : '⚔ Mover tropas';
      var note = isAllyDest
        ? '<div style="font-size:.72rem;color:var(--accent2);margin-bottom:10px;">Las tropas se quedarán en la aldea aliada. Tú o el aliado podéis llamarlas de vuelta.</div>'
        : '<div style="font-size:.72rem;color:var(--accent);margin-bottom:10px;">Las tropas pasarán a ser de esta aldea permanentemente.</div>';
      
      var html = '<div class="bld-modal-overlay" id="moveOverlay" onclick="closeMoveOverlay(event)">'
        + '<div class="bld-modal" style="max-width:420px;">'
        + '<div class="bld-modal-head"><div class="bld-modal-icon">' + (isAllyDest ? '🛡️' : '⚔') + '</div>'
        + '<div><div class="bld-modal-title">' + titleTxt + '</div>'
        + '<div class="bld-modal-sub">Paso 1/2: Selecciona tropas • Hacia ' + escapeHtml(destVillageName) + '</div></div>'
        + '<button class="bld-modal-close" onclick="document.getElementById(\'bldModal\').style.display=\'none\';">&#x2715;</button>'
        + '</div><div class="bld-modal-body" style="padding:15px;">' + note
        + '<div style="font-size:.68rem;color:var(--accent);margin-bottom:6px;">Capacidad de carga: <b id="mvCapDisplay">0</b> unidades</div>'
        + troopRows
        + '</div><div style="padding:8px 15px;border-top:1px solid var(--border);background:var(--panel2);">'
        + '<div style="font-size:.68rem;color:var(--dim);">📍 Distancia: ' + dist + ' casillas</div>'
        + '<div id="mvTroopETA" style="font-size:.8rem;color:var(--dim);">Selecciona tropas para ver ETA</div>'
        + '</div><div class="bld-modal-footer">'
        + '<button class="bld-footer-btn avail" onclick="moveStep2(\'' + destVillageId + '\',\'' + destVillageName + '\',' + tx + ',' + ty + ',' + (isAllyDest ? 'true' : 'false') + ')">Siguiente →</button>'
        + '</div></div></div>';
      
      window._moveDest = { vid: destVillageId, name: destVillageName, tx: tx, ty: ty, isAlly: isAllyDest, dist: dist };
      
      var wrap = document.getElementById('bldModal');
      wrap.innerHTML = html;
      wrap.style.display = 'block';
    }
    
    function calcMoveCapacity() {
      var totalCap = 0;
      var minSpeed = Infinity;
      var hasTroops = false;
      
      Object.keys(TROOP_TYPES).forEach(function(k) {
        var el = document.getElementById('mv_troop_' + k);
        if (!el) return;
        var qty = parseInt(el.value) || 0;
        if (qty > 0) {
          hasTroops = true;
          totalCap += qty * (TROOP_TYPES[k].capacity || 0);
          var spd = TROOP_TYPES[k].speed || 1;
          if (spd < minSpeed) minSpeed = spd;
        }
      });
      
      Object.keys(CREATURE_TYPES).forEach(function(k) {
        var el = document.getElementById('mv_troop_' + k);
        if (!el) return;
        var qty = parseInt(el.value) || 0;
        if (qty > 0) {
          hasTroops = true;
          // Criaturas NO tienen capacidad de carga
          var spd = CREATURE_TYPES[k].speed || 1;
          if (spd < minSpeed) minSpeed = spd;
        }
      });
      
      var capEl = document.getElementById('mvCapDisplay');
      if (capEl) capEl.textContent = totalCap;
      
      var etaEl = document.getElementById('mvTroopETA');
      if (etaEl) {
        if (!hasTroops) {
          etaEl.textContent = 'Selecciona tropas para ver ETA';
          etaEl.style.color = 'var(--dim)';
        } else {
          var dist = (window._moveDest && window._moveDest.dist) || 0;
          var secs = Math.ceil((dist / minSpeed) * MISSION_FACTOR);
          var arr = new Date(Date.now() + secs * 1000).toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
          etaEl.textContent = '⏱ ' + fmtTime(secs) + ' • Llegada ~' + arr + ' (vel: ' + minSpeed + ')';
          etaEl.style.color = 'var(--accent)';
        }
      }
    }
    
    function moveStep2(destVillageId, destVillageName, tx, ty, isAllyDest) {
      // Recoger tropas seleccionadas
      var selectedTroops = {};
      var totalCap = 0;
      var minSpeed = Infinity;
      var hasTroops = false;
      
      Object.keys(TROOP_TYPES).forEach(function(k) {
        var el = document.getElementById('mv_troop_' + k);
        if (!el) return;
        var qty = parseInt(el.value) || 0;
        if (qty > 0) {
          selectedTroops[k] = qty;
          hasTroops = true;
          totalCap += qty * (TROOP_TYPES[k].capacity || 0);
          var spd = TROOP_TYPES[k].speed || 1;
          if (spd < minSpeed) minSpeed = spd;
        }
      });
      
      Object.keys(CREATURE_TYPES).forEach(function(k) {
        var el = document.getElementById('mv_troop_' + k);
        if (!el) return;
        var qty = parseInt(el.value) || 0;
        if (qty > 0) {
          selectedTroops[k] = qty;
          hasTroops = true;
          var spd = CREATURE_TYPES[k].speed || 1;
          if (spd < minSpeed) minSpeed = spd;
        }
      });
      
      if (!hasTroops) {
        showNotif('Selecciona al menos una tropa.', 'err');
        return;
      }
      
      // PASO 2: Seleccionar recursos (opcional)
      var vs = activeVillage.state;
      var dist = Math.max(Math.abs(tx - activeVillage.x), Math.abs(ty - activeVillage.y));
      
      var resRows = '';
      if (totalCap > 0) {
        var resKeys = ['madera','piedra','hierro','provisiones','esencia'];
        var resIcons = {madera:'🌲',piedra:'⛰️',hierro:'⚙️',provisiones:'🌾',esencia:'✨'};
        resKeys.forEach(function(rk) {
          var have = Math.floor(vs.resources[rk] || 0);
          if (have <= 0) return;
          resRows += '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">'
            + '<span>' + resIcons[rk] + ' ' + rk.charAt(0).toUpperCase() + rk.slice(1) + ' (' + fmt(have) + ' disp.)</span>'
            + '<input type="number" id="mv_' + rk + '" value="0" min="0" max="' + Math.min(have, totalCap) + '" style="width:80px;" oninput="calcMoveLoad()">'
            + '</div>';
        });
      }
      
      var troopSummary = '';
      Object.keys(selectedTroops).forEach(function(k) {
        var typeData = TROOP_TYPES[k] || CREATURE_TYPES[k];
        troopSummary += (typeData.icon || '') + ' ' + selectedTroops[k] + ' ' + (typeData.name || k) + ' • ';
      });
      troopSummary = troopSummary.slice(0, -3);
      
      var titleTxt = isAllyDest ? '🛡️ Enviar refuerzo' : '⚔ Mover tropas';
      var note = isAllyDest
        ? 'Las tropas se quedarán en la aldea aliada hasta que las llames de vuelta.'
        : 'Las tropas pasarán a ser de esta aldea permanentemente.';
      
      var html = '<div class="bld-modal-overlay" id="moveOverlay" onclick="closeMoveOverlay(event)">'
        + '<div class="bld-modal" style="max-width:420px;">'
        + '<div class="bld-modal-head"><div class="bld-modal-icon">' + (isAllyDest ? '🛡️' : '⚔') + '</div>'
        + '<div><div class="bld-modal-title">' + titleTxt + '</div>'
        + '<div class="bld-modal-sub">Paso 2/2: Recursos (opcional) • Hacia ' + escapeHtml(destVillageName) + '</div></div>'
        + '<button class="bld-modal-close" onclick="document.getElementById(\'bldModal\').style.display=\'none\';">&#x2715;</button>'
        + '</div><div class="bld-modal-body" style="padding:15px;">'
        + '<div style="font-size:.7rem;color:var(--dim);margin-bottom:6px;padding:6px 8px;background:var(--panel2);border-radius:4px;">' + troopSummary + '</div>'
        + '<div style="font-size:.68rem;color:var(--accent2);margin-bottom:8px;">' + note + '</div>';
      
      if (totalCap > 0 && resRows) {
        html += '<div style="font-size:.68rem;color:var(--accent);margin-bottom:6px;">Capacidad: <b id="mvCapDisplay2">' + totalCap + '</b> uds • Cargado: <b id="mvLoadDisplay" style="color:var(--ok)">0</b></div>'
          + resRows;
      } else if (totalCap > 0) {
        html += '<p style="color:var(--dim);font-size:.75rem;">Sin recursos disponibles para enviar.</p>';
      } else {
        html += '<p style="color:var(--dim);font-size:.75rem;">Las tropas seleccionadas no tienen capacidad de carga.</p>';
      }
      
      html += '</div><div style="padding:8px 15px;border-top:1px solid var(--border);background:var(--panel2);">'
        + '<div style="font-size:.68rem;color:var(--dim);">📍 ' + dist + ' casillas • ETA: <span id="mvETA">' + fmtTime(Math.ceil((dist / minSpeed) * MISSION_FACTOR)) + '</span></div>'
        + '<div id="mvWarning" style="font-size:.68rem;color:var(--danger);min-height:14px;"></div>'
        + '</div><div class="bld-modal-footer">'
        + '<button class="bld-footer-btn" style="background:var(--border);color:var(--dim);" onclick="openMoveModal(\'' + destVillageId + '\',\'' + destVillageName + '\',' + tx + ',' + ty + ',' + (isAllyDest ? 'true' : 'false') + ')">← Atrás</button>'
        + '<button class="bld-footer-btn avail" onclick="executeMoveClick(\'' + destVillageId + '\',' + tx + ',' + ty + ',' + (isAllyDest ? 'true' : 'false') + ')">Enviar tropas</button>'
        + '</div></div></div>';
      
      window._moveTotalCap = totalCap;
      window._moveMinSpeed = minSpeed;
      window._moveDist = dist;
      window._moveSelectedTroops = selectedTroops;
      
      var wrap = document.getElementById('bldModal');
      wrap.innerHTML = html;
      wrap.style.display = 'block';
      if (totalCap > 0) calcMoveLoad();
    }
    
    function calcMoveLoad() {
      var load = 0;
      ['madera','piedra','hierro','provisiones','esencia'].forEach(function(rk) {
        var el = document.getElementById('mv_' + rk);
        if (el) load += parseInt(el.value) || 0;
      });
      var loadEl = document.getElementById('mvLoadDisplay');
      var warnEl = document.getElementById('mvWarning');
      if (loadEl) { loadEl.textContent = load; loadEl.style.color = load > (window._moveTotalCap || 0) ? 'var(--danger)' : 'var(--ok)'; }
      if (warnEl) warnEl.textContent = load > (window._moveTotalCap || 0) ? '⚠ Sobrepasa la capacidad de carga' : '';
    }
    
    function closeMoveOverlay(event) {
      if (event.target.id === 'moveOverlay') document.getElementById('bldModal').style.display = 'none';
    }

    async function executeMoveClick(destVillageId, tx, ty, isAllyDest) {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      var res = calcRes(vs);
      
      // Usar tropas pre-seleccionadas del paso 1
      var selectedTroops = window._moveSelectedTroops || {};
      if (Object.keys(selectedTroops).length === 0) {
        showNotif('No hay tropas seleccionadas.', 'err');
        return;
      }
      
      // Validar que tenemos las tropas
      var aldLibres = res.aldeanos_libres || 0;
      for (var k in selectedTroops) {
        var needed = selectedTroops[k];
        var available = 0;
        if (k === 'aldeano') {
          available = aldLibres;
        } else if (TROOP_TYPES[k]) {
          available = vs.troops[k] || 0;
        } else if (CREATURE_TYPES[k]) {
          available = (vs.creatures && vs.creatures[k]) || 0;
        }
        if (needed > available) {
          var typeData = TROOP_TYPES[k] || CREATURE_TYPES[k];
          showNotif('No tienes suficientes ' + (typeData ? typeData.name : k) + 's.', 'err');
          return;
        }
      }
      
      // Recoger recursos opcionales
      var cargo = {}; var totalLoad = 0;
      ['madera','piedra','hierro','provisiones','esencia'].forEach(function(rk) {
        var el = document.getElementById('mv_' + rk);
        var v = parseInt((el && el.value) || 0);
        if (v > 0) { cargo[rk] = v; totalLoad += v; }
      });
      
      // Validar capacidad si hay recursos
      if (totalLoad > 0) {
        var totalCap = window._moveTotalCap || 0;
        if (totalLoad > totalCap) {
          showNotif('Sobrepasa la capacidad de carga.', 'err');
          return;
        }
        for (var rk in cargo) {
          if (cargo[rk] > Math.floor(vs.resources[rk] || 0)) {
            showNotif('No tienes suficientes ' + rk + '.', 'err');
            return;
          }
        }
      }
      
      document.getElementById('bldModal').style.display = 'none';
      
      var dist = Math.max(Math.abs(tx - activeVillage.x), Math.abs(ty - activeVillage.y));
      var minSpeed = window._moveMinSpeed || 1;
      var seconds = Math.ceil((dist / minSpeed) * MISSION_FACTOR);
      var finishAt = new Date(Date.now() + seconds * 1000).toISOString();
      
      snapshotResources(vs);
      
      // Descontar recursos
      for (var rk in cargo) {
        vs.resources[rk] = Math.max(0, (vs.resources[rk] || 0) - cargo[rk]);
      }
      
      // Descontar tropas
      Object.keys(selectedTroops).forEach(function(k) {
        if (k === 'aldeano') {
          vs.resources.aldeanos = Math.max(0, (vs.resources.aldeanos || 0) - selectedTroops[k]);
          vs.troops.aldeano = vs.resources.aldeanos;
        } else if (TROOP_TYPES[k]) {
          vs.troops[k] = Math.max(0, (vs.troops[k] || 0) - selectedTroops[k]);
        } else if (CREATURE_TYPES[k]) {
          vs.creatures[k] = Math.max(0, ((vs.creatures && vs.creatures[k]) || 0) - selectedTroops[k]);
        }
      });
      
      if (!vs.mission_queue) vs.mission_queue = [];
      vs.mission_queue.push({
        type: isAllyDest ? 'reinforce' : 'move',
        tx: tx, ty: ty, targetId: destVillageId,
        troops: selectedTroops,
        cargo: cargo, // Recursos opcionales
        finish_at: finishAt,
        start_at: new Date().toISOString(),
        origin_village_id: activeVillage.id,
        origin_owner_id: currentUser.id
      });
      
      await flushVillage();
      var cargoMsg = totalLoad > 0 ? ' (con ' + totalLoad + ' recursos)' : '';
      showNotif((isAllyDest ? '🛡️ Refuerzo enviado' : '⚔ Tropas en camino') + cargoMsg + ' • ' + fmtTime(seconds), 'ok');
      tick();
    }

    function _calcMinTroopSpeed(troops, aldLibres) {
      var minSpeed = Infinity;
      Object.keys(TROOP_TYPES).forEach(function(k) {
        var count = (k === 'aldeano') ? aldLibres : (troops[k] || 0);
        if (count > 0 && (TROOP_TYPES[k].capacity || 0) > 0) {
          var spd = TROOP_TYPES[k].speed || 1;
          if (spd < minSpeed) minSpeed = spd;
        }
      });
      return isFinite(minSpeed) ? minSpeed : 1;
    }

    // ============================================================
    // TRANSPORTE DE MATERIAL - 2 PASOS
    // Paso 1: Seleccionar tropas → Paso 2: Seleccionar recursos
    // Las tropas VAN, DEJAN recursos y VUELVEN
    // ============================================================
    function openTransportModal(destVillageId, destVillageName, tx, ty, isAllyDest) {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      var res = calcRes(vs);
      var troops = vs.troops || {};
      var aldLibres = res.aldeanos_libres || 0;
      var dist = Math.max(Math.abs(tx - activeVillage.x), Math.abs(ty - activeVillage.y));
      
      // PASO 1: Seleccionar tropas
      var troopRows = '';
      var hasTroops = false;
      Object.keys(TROOP_TYPES).forEach(function(k) {
        var count = (k === 'aldeano') ? aldLibres : (troops[k] || 0);
        if (count <= 0) return;
        if ((TROOP_TYPES[k].capacity || 0) <= 0) return; // Solo tropas con capacidad
        hasTroops = true;
        troopRows += '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">'
          + '<span>' + TROOP_TYPES[k].icon + ' ' + TROOP_TYPES[k].name + ' (' + count + ' disp.) <span style="color:var(--dim);font-size:.7rem;">• Cap: ' + TROOP_TYPES[k].capacity + '</span></span>'
          + '<input type="number" id="tr_troop_' + k + '" value="0" min="0" max="' + count + '" style="width:64px;" oninput="calcTransportCapacity()">'
          + '</div>';
      });
      
      if (!hasTroops) {
        showNotif('No tienes tropas con capacidad de carga disponibles.', 'err');
        return;
      }
      
      var html = '<div class="bld-modal-overlay" id="transportOverlay" onclick="closeTransportOverlay(event)">'
        + '<div class="bld-modal" style="max-width:420px;">'
        + '<div class="bld-modal-head"><div class="bld-modal-icon">📦</div>'
        + '<div><div class="bld-modal-title">Transporte de material</div>'
        + '<div class="bld-modal-sub">Paso 1/2: Selecciona tropas • Hacia ' + escapeHtml(destVillageName) + '</div></div>'
        + '<button class="bld-modal-close" onclick="document.getElementById(\'bldModal\').style.display=\'none\';">&#x2715;</button>'
        + '</div><div class="bld-modal-body" style="padding:15px;">'
        + '<div style="font-size:.72rem;color:var(--accent2);margin-bottom:10px;">Las tropas irán, dejarán el material y volverán automáticamente.</div>'
        + '<div style="font-size:.68rem;color:var(--accent);margin-bottom:6px;">Capacidad total: <b id="trCapDisplay">0</b> unidades</div>'
        + troopRows
        + '</div><div style="padding:8px 15px;border-top:1px solid var(--border);background:var(--panel2);">'
        + '<div style="font-size:.68rem;color:var(--dim);">📍 Distancia: ' + dist + ' casillas</div>'
        + '<div id="trTroopETA" style="font-size:.8rem;color:var(--dim);">Selecciona tropas para ver ETA</div>'
        + '</div><div class="bld-modal-footer">'
        + '<button class="bld-footer-btn avail" onclick="transportStep2(\'' + destVillageId + '\',\'' + destVillageName + '\',' + tx + ',' + ty + ',' + (isAllyDest ? 'true' : 'false') + ')">Siguiente →</button>'
        + '</div></div></div>';
      
      window._transportDest = { vid: destVillageId, name: destVillageName, tx: tx, ty: ty, isAlly: isAllyDest, dist: dist };
      
      var wrap = document.getElementById('bldModal');
      wrap.innerHTML = html;
      wrap.style.display = 'block';
    }
    
    function calcTransportCapacity() {
      var totalCap = 0;
      var minSpeed = Infinity;
      var hasTroops = false;
      
      Object.keys(TROOP_TYPES).forEach(function(k) {
        var el = document.getElementById('tr_troop_' + k);
        if (!el) return;
        var qty = parseInt(el.value) || 0;
        if (qty > 0) {
          hasTroops = true;
          totalCap += qty * (TROOP_TYPES[k].capacity || 0);
          var spd = TROOP_TYPES[k].speed || 1;
          if (spd < minSpeed) minSpeed = spd;
        }
      });
      
      var capEl = document.getElementById('trCapDisplay');
      if (capEl) capEl.textContent = totalCap;
      
      var etaEl = document.getElementById('trTroopETA');
      if (etaEl) {
        if (!hasTroops) {
          etaEl.textContent = 'Selecciona tropas para ver ETA';
          etaEl.style.color = 'var(--dim)';
        } else {
          var dist = (window._transportDest && window._transportDest.dist) || 0;
          var secs = Math.ceil((dist / minSpeed) * MISSION_FACTOR);
          var arr = new Date(Date.now() + secs * 1000).toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
          etaEl.textContent = '⏱ Ida: ' + fmtTime(secs) + ' • Vuelta: ' + fmtTime(secs) + ' • Llegada ~' + arr + ' (vel: ' + minSpeed + ')';
          etaEl.style.color = 'var(--accent)';
        }
      }
    }
    
    function transportStep2(destVillageId, destVillageName, tx, ty, isAllyDest) {
      // Recoger tropas seleccionadas
      var selectedTroops = {};
      var totalCap = 0;
      var minSpeed = Infinity;
      var hasTroops = false;
      
      Object.keys(TROOP_TYPES).forEach(function(k) {
        var el = document.getElementById('tr_troop_' + k);
        if (!el) return;
        var qty = parseInt(el.value) || 0;
        if (qty > 0) {
          selectedTroops[k] = qty;
          hasTroops = true;
          totalCap += qty * (TROOP_TYPES[k].capacity || 0);
          var spd = TROOP_TYPES[k].speed || 1;
          if (spd < minSpeed) minSpeed = spd;
        }
      });
      
      if (!hasTroops) {
        showNotif('Selecciona al menos una tropa.', 'err');
        return;
      }
      
      // PASO 2: Seleccionar recursos
      var vs = activeVillage.state;
      var dist = Math.max(Math.abs(tx - activeVillage.x), Math.abs(ty - activeVillage.y));
      
      var resRows = '';
      var resKeys = ['madera','piedra','hierro','provisiones','esencia'];
      var resIcons = {madera:'🌲',piedra:'⛰️',hierro:'⚙️',provisiones:'🌾',esencia:'✨'};
      resKeys.forEach(function(rk) {
        var have = Math.floor(vs.resources[rk] || 0);
        if (have <= 0) return;
        resRows += '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">'
          + '<span>' + resIcons[rk] + ' ' + rk.charAt(0).toUpperCase() + rk.slice(1) + ' (' + fmt(have) + ' disp.)</span>'
          + '<input type="number" id="tr_' + rk + '" value="0" min="0" max="' + Math.min(have, totalCap) + '" style="width:80px;" oninput="calcTransportLoad()">'
          + '</div>';
      });
      
      var troopSummary = '';
      Object.keys(selectedTroops).forEach(function(k) {
        troopSummary += TROOP_TYPES[k].icon + ' ' + selectedTroops[k] + ' ' + TROOP_TYPES[k].name + '(s) • ';
      });
      troopSummary = troopSummary.slice(0, -3); // quitar último •
      
      var html = '<div class="bld-modal-overlay" id="transportOverlay" onclick="closeTransportOverlay(event)">'
        + '<div class="bld-modal" style="max-width:420px;">'
        + '<div class="bld-modal-head"><div class="bld-modal-icon">📦</div>'
        + '<div><div class="bld-modal-title">Transporte de material</div>'
        + '<div class="bld-modal-sub">Paso 2/2: Selecciona recursos • Hacia ' + escapeHtml(destVillageName) + '</div></div>'
        + '<button class="bld-modal-close" onclick="document.getElementById(\'bldModal\').style.display=\'none\';">&#x2715;</button>'
        + '</div><div class="bld-modal-body" style="padding:15px;">'
        + '<div style="font-size:.7rem;color:var(--dim);margin-bottom:6px;padding:6px 8px;background:var(--panel2);border-radius:4px;">' + troopSummary + '</div>'
        + '<div style="font-size:.68rem;color:var(--accent);margin-bottom:6px;">Capacidad: <b id="trCapDisplay2">' + totalCap + '</b> uds • Cargado: <b id="trLoadDisplay" style="color:var(--ok)">0</b></div>'
        + (resRows || '<p style="color:var(--dim);">Sin recursos disponibles.</p>')
        + '</div><div style="padding:8px 15px;border-top:1px solid var(--border);background:var(--panel2);">'
        + '<div style="font-size:.68rem;color:var(--dim);">📍 ' + dist + ' casillas • ETA: <span id="trETA">' + fmtTime(Math.ceil((dist / minSpeed) * MISSION_FACTOR)) + '</span></div>'
        + '<div id="trWarning" style="font-size:.68rem;color:var(--danger);min-height:14px;"></div>'
        + '</div><div class="bld-modal-footer">'
        + '<button class="bld-footer-btn" style="background:var(--border);color:var(--dim);" onclick="openTransportModal(\'' + destVillageId + '\',\'' + destVillageName + '\',' + tx + ',' + ty + ',' + (isAllyDest ? 'true' : 'false') + ')">← Atrás</button>'
        + '<button class="bld-footer-btn avail" onclick="executeTransportClick(\'' + destVillageId + '\',' + tx + ',' + ty + ',' + (isAllyDest ? 'true' : 'false') + ')">Enviar transporte</button>'
        + '</div></div></div>';
      
      window._transportTotalCap = totalCap;
      window._transportMinSpeed = minSpeed;
      window._transportDist = dist;
      window._transportSelectedTroops = selectedTroops;
      
      var wrap = document.getElementById('bldModal');
      wrap.innerHTML = html;
      wrap.style.display = 'block';
      calcTransportLoad();
    }
    
    function closeTransportOverlay(event) {
      if (event.target.id === 'transportOverlay') {
        document.getElementById('bldModal').style.display = 'none';
      }
    }

    function calcTransportLoad() {
      var load = 0;
      ['madera','piedra','hierro','provisiones','esencia'].forEach(function(rk) {
        var el = document.getElementById('tr_' + rk);
        if (el) load += parseInt(el.value) || 0;
      });
      var loadEl = document.getElementById('trLoadDisplay');
      var warnEl = document.getElementById('trWarning');
      var etaEl = document.getElementById('trETA');
      if (loadEl) { loadEl.textContent = load; loadEl.style.color = load > (window._transportTotalCap || 0) ? 'var(--danger)' : 'var(--ok)'; }
      if (warnEl) warnEl.textContent = load > (window._transportTotalCap || 0) ? '\u26a0 Sobrepasa la capacidad de carga' : '';
      if (etaEl && window._transportDist != null) {
        var secs = Math.ceil((window._transportDist / (window._transportMinSpeed || 1)) * MISSION_FACTOR);
        etaEl.textContent = fmtTime(secs);
      }
    }

    async function executeTransportClick(destVillageId, tx, ty, isAllyDest) {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      var res = calcRes(vs);
      var aldLibres = res.aldeanos_libres || 0;
      
      // Validar tropas seleccionadas
      var selectedTroops = window._transportSelectedTroops || {};
      if (Object.keys(selectedTroops).length === 0) {
        showNotif('No hay tropas seleccionadas.', 'err');
        return;
      }
      
      // Validar que tenemos las tropas
      for (var k in selectedTroops) {
        var needed = selectedTroops[k];
        var available = (k === 'aldeano') ? aldLibres : (vs.troops[k] || 0);
        if (needed > available) {
          showNotif('No tienes suficientes ' + TROOP_TYPES[k].name + 's.', 'err');
          return;
        }
      }
      
      // Recoger recursos seleccionados
      var cargo = {}; var totalLoad = 0;
      ['madera','piedra','hierro','provisiones','esencia'].forEach(function(rk) {
        var el = document.getElementById('tr_' + rk);
        var v = parseInt((el && el.value) || 0);
        if (v > 0) { cargo[rk] = v; totalLoad += v; }
      });
      
      if (totalLoad <= 0) { showNotif('Selecciona al menos un recurso.', 'err'); return; }
      if (totalLoad > (window._transportTotalCap || 0)) { showNotif('Sobrepasa la capacidad de carga.', 'err'); return; }
      
      for (var rk in cargo) {
        if (cargo[rk] > Math.floor(vs.resources[rk] || 0)) { showNotif('No tienes suficientes ' + rk + '.', 'err'); return; }
      }
      
      document.getElementById('bldModal').style.display = 'none';
      
      var minSpeed = window._transportMinSpeed || 1;
      var dist = Math.max(Math.abs(tx - activeVillage.x), Math.abs(ty - activeVillage.y));
      var seconds = Math.ceil((dist / minSpeed) * MISSION_FACTOR);
      var finishAt = new Date(Date.now() + seconds * 1000).toISOString();
      
      snapshotResources(vs);
      
      // Descontar recursos
      for (var rk in cargo) vs.resources[rk] = Math.max(0, (vs.resources[rk] || 0) - cargo[rk]);
      
      // Descontar tropas temporalmente
      for (var k in selectedTroops) {
        if (k === 'aldeano') {
          vs.resources.aldeanos = Math.max(0, (vs.resources.aldeanos || 0) - selectedTroops[k]);
          vs.troops.aldeano = vs.resources.aldeanos; // mantener sincronizado
        } else {
          vs.troops[k] = Math.max(0, (vs.troops[k] || 0) - selectedTroops[k]);
        }
      }
      
      if (!vs.mission_queue) vs.mission_queue = [];
      vs.mission_queue.push({
        type: 'transport',
        status: 'going', // 'going' -> 'returning'
        tx: tx,
        ty: ty,
        targetId: destVillageId,
        troops: selectedTroops,
        resources: cargo,
        is_ally: isAllyDest,
        finish_at: finishAt,
        start_at: new Date().toISOString(),
        origin_village_id: activeVillage.id,
        minSpeed: minSpeed
      });
      
      await flushVillage();
      showNotif('📦 Transporte en camino • ' + fmtTime(seconds), 'ok');
      tick();
    }

    async function executeMove(m) {
      try {
        var destVillage = myVillages.find(function(v) { return v.id === m.targetId; });
        if (!destVillage) { await loadMyVillages(); destVillage = myVillages.find(function(v) { return v.id === m.targetId; }); }
        if (!destVillage) {
          await sendSystemReport(currentUser.id, '\u26a0\ufe0f MOVIMIENTO FALLIDO', 'Las tropas llegaron a [' + m.tx + ', ' + m.ty + '] pero la aldea no existe o ya no es tuya.');
          return;
        }
        var dvs = destVillage.state;
        
        // Entregar recursos si hay cargo
        var cargoMsg = '';
        if (m.cargo && Object.keys(m.cargo).length > 0) {
          var rr = await sbClient.from('resources').select('madera,piedra,hierro,prov,esencia').eq('village_id', m.targetId).single();
          if (!rr.error) {
            var newRes = {
              madera:      (Number(rr.data.madera) || 0) + (m.cargo.madera || 0),
              piedra:      (Number(rr.data.piedra) || 0) + (m.cargo.piedra || 0),
              hierro:      (Number(rr.data.hierro) || 0) + (m.cargo.hierro || 0),
              prov:        (Number(rr.data.prov)   || 0) + (m.cargo.provisiones || 0),
              esencia:     (Number(rr.data.esencia)|| 0) + (m.cargo.esencia || 0),
              last_update: new Date().toISOString()
            };
            await sbClient.from('resources').update(newRes).eq('village_id', m.targetId);
            dvs.resources.madera = newRes.madera;
            dvs.resources.piedra = newRes.piedra;
            dvs.resources.hierro = newRes.hierro;
            dvs.resources.provisiones = newRes.prov;
            dvs.resources.esencia = newRes.esencia;
            
            var cargoList = Object.keys(m.cargo).filter(function(k){ return m.cargo[k] > 0; })
              .map(function(k){ return fmt(m.cargo[k]) + ' ' + k; }).join(', ');
            cargoMsg = '\n📦 Entregaron: ' + cargoList;
          }
        }
        
        var freeSlots = Math.max(0, getBarracksCapacity(dvs.buildings) - getBarracksUsed(dvs));
        var slotsNeeded = 0;
        Object.keys(m.troops).forEach(function(k) {
          var count = m.troops[k] || 0;
          if (count > 0) slotsNeeded += (k === 'aldeano') ? count : count * ((TROOP_TYPES[k] && TROOP_TYPES[k].barracasSlots) || 1);
        });
        var pct = slotsNeeded > freeSlots ? freeSlots / slotsNeeded : 1;
        var accepted = {}, rejected = {}, anyRejected = false;
        Object.keys(m.troops).forEach(function(k) {
          var count = m.troops[k] || 0;
          var toAccept = Math.floor(count * pct);
          accepted[k] = toAccept;
          if (toAccept < count) { rejected[k] = count - toAccept; anyRejected = true; }
        });
        Object.keys(accepted).forEach(function(k) {
          if ((accepted[k] || 0) <= 0) return;
          if (TROOP_TYPES[k]) dvs.troops[k] = (dvs.troops[k] || 0) + accepted[k];
          else if (CREATURE_TYPES[k]) { if (!dvs.creatures) dvs.creatures = defaultCreatures(); dvs.creatures[k] = (dvs.creatures[k] || 0) + accepted[k]; }
        });
        await saveVillage(destVillage);
        if (anyRejected) {
          var origV = myVillages.find(function(v){ return v.id === m.origin_village_id; });
          if (origV) {
            Object.keys(rejected).forEach(function(k) {
              if ((rejected[k] || 0) <= 0) return;
              if (TROOP_TYPES[k]) origV.state.troops[k] = (origV.state.troops[k] || 0) + rejected[k];
              else if (CREATURE_TYPES[k]) origV.state.creatures[k] = (origV.state.creatures[k] || 0) + rejected[k];
            });
            await saveVillage(origV);
          }
        }
        var rejMsg = anyRejected ? '\n\u26a0\ufe0f Algunas tropas volvieron (barracas llenas en destino).' : '';
        await sendSystemReport(currentUser.id, '\u2694 TROPAS TRASLADADAS',
          'Tropas llegaron a ' + (destVillage.name || 'aldea') + ' [' + m.tx + ', ' + m.ty + '] y ya son de esa aldea.' + cargoMsg + rejMsg);
        renderMap();
      } catch(e) { console.error('executeMove error:', e); }
    }

    async function executeReinforce(m) {
      if (_guestTroopsTableExists === false) {
        // Tabla no disponible — devolver tropas a origen
        var origV = myVillages.find(function(v){ return v.id === m.origin_village_id; });
        if (origV) {
          Object.keys(m.troops).forEach(function(k) {
            if (TROOP_TYPES[k]) origV.state.troops[k] = (origV.state.troops[k] || 0) + (m.troops[k] || 0);
            else if (CREATURE_TYPES[k]) origV.state.creatures[k] = (origV.state.creatures[k] || 0) + (m.troops[k] || 0);
          });
          await saveVillage(origV);
        }
        await sendSystemReport(currentUser.id, '⚠️ REFUERZO NO DISPONIBLE',
          'El sistema de refuerzos a aliados aún no está activo. Las tropas han regresado a casa.');
        return;
      }
      try {
        var troopJson = JSON.stringify(m.troops);
        var r = await sbClient.from('guest_troops').insert({
          owner_id: m.origin_owner_id || currentUser.id,
          origin_village_id: m.origin_village_id,
          host_village_id: m.targetId,
          troops: troopJson,
          arrived_at: new Date().toISOString(),
          recall_requested: false
        });
        if (r.error) throw r.error;
        await sendSystemReport(currentUser.id, '\u{1f6e1}\ufe0f REFUERZO ENTREGADO',
          'Tus tropas llegaron a [' + m.tx + ', ' + m.ty + '] y est\u00e1n estacionadas. Pulsa "Volver" cuando quieras recuperarlas.');
        renderReinforcementsPanel();
      } catch(e) {
        console.error('executeReinforce error:', e);
        var origV = myVillages.find(function(v){ return v.id === m.origin_village_id; });
        if (origV) {
          Object.keys(m.troops).forEach(function(k) {
            if (TROOP_TYPES[k]) origV.state.troops[k] = (origV.state.troops[k] || 0) + (m.troops[k] || 0);
            else if (CREATURE_TYPES[k]) origV.state.creatures[k] = (origV.state.creatures[k] || 0) + (m.troops[k] || 0);
          });
          await saveVillage(origV);
        }
        await sendSystemReport(currentUser.id, '\u26a0\ufe0f REFUERZO FALLIDO',
          'Las tropas no pudieron llegar y volvieron a casa. Error: ' + (e.message || e));
      }
    }

    async function executeTransport(m) {
      try {
        var cargo = m.cargo || {};
        var rr = await sbClient.from('resources').select('madera,piedra,hierro,prov,esencia').eq('village_id', m.targetId).single();
        if (rr.error) throw rr.error;
        var newRes = {
          madera:      (Number(rr.data.madera) || 0) + (cargo.madera || 0),
          piedra:      (Number(rr.data.piedra) || 0) + (cargo.piedra || 0),
          hierro:      (Number(rr.data.hierro) || 0) + (cargo.hierro || 0),
          prov:        (Number(rr.data.prov)   || 0) + (cargo.provisiones || 0),
          esencia:     (Number(rr.data.esencia)|| 0) + (cargo.esencia || 0),
          last_update: new Date().toISOString()
        };
        await sbClient.from('resources').update(newRes).eq('village_id', m.targetId);
        var destV = myVillages.find(function(v){ return v.id === m.targetId; });
        if (destV) {
          destV.state.resources.madera = newRes.madera; destV.state.resources.piedra = newRes.piedra;
          destV.state.resources.hierro = newRes.hierro; destV.state.resources.provisiones = newRes.prov;
          destV.state.resources.esencia = newRes.esencia;
        }
        var cargoStr = Object.keys(cargo).filter(function(k){ return cargo[k] > 0; })
          .map(function(k){ return fmt(cargo[k]) + ' ' + k; }).join(', ');
        await sendSystemReport(currentUser.id, '\ud83d\udce6 CARAVANA LLEG\u00d3',
          'Tu caravana entreg\u00f3 ' + cargoStr + ' en [' + m.tx + ', ' + m.ty + '].');
        renderMap();
      } catch(e) {
        console.error('executeTransport error:', e);
        var origV = myVillages.find(function(v){ return v.id === m.origin_village_id; });
        if (origV && m.cargo) {
          Object.keys(m.cargo).forEach(function(rk) { origV.state.resources[rk] = (origV.state.resources[rk] || 0) + (m.cargo[rk] || 0); });
          await saveVillage(origV);
        }
        await sendSystemReport(currentUser.id, '\u26a0\ufe0f CARAVANA FALLIDA',
          'Los recursos volvieron a tu aldea. Error: ' + (e.message || e));
      }
    }

    var _guestTroopsTableExists = null; // null=unknown, true=yes, false=no

    async function renderReinforcementsPanel() {
      var card = document.getElementById('ovReinforcementsCard');
      var box = document.getElementById('ovReinforcementsBox');
      if (!card || !box || !activeVillage) return;
      // Si ya sabemos que la tabla no existe, no volver a intentar
      if (_guestTroopsTableExists === false) { card.style.display = 'none'; return; }
      try {
        var r = await sbClient.from('guest_troops')
          .select('id,owner_id,origin_village_id,host_village_id,troops,arrived_at,recall_requested')
          .eq('host_village_id', activeVillage.id);
        if (r.error) {
          // Tabla no existe o error de schema — desactivar silenciosamente
          _guestTroopsTableExists = false;
          card.style.display = 'none';
          return;
        }
        _guestTroopsTableExists = true;
        if (!r.data || r.data.length === 0) { card.style.display = 'none'; return; }
        card.style.display = '';
        var html = '';
        r.data.forEach(function(gt) {
          // Owner name: look up from profileCache if available
          var ownerName = (profileCache[gt.owner_id] && profileCache[gt.owner_id].username) ? profileCache[gt.owner_id].username : gt.owner_id.slice(0,8);
          // Look up origin village from local allVillages cache
          var origV = allVillages.find(function(v){ return v.id === gt.origin_village_id; })
                   || myVillages.find(function(v){ return v.id === gt.origin_village_id; });
          var origName = (origV && origV.name) ? origV.name : 'Aldea';
          var origCoords = origV ? '[' + origV.x + ',' + origV.y + ']' : '';
          var troops = typeof gt.troops === 'string' ? JSON.parse(gt.troops) : (gt.troops || {});
          var troopStr = Object.keys(troops).filter(function(k){ return (troops[k] || 0) > 0; })
            .map(function(k){ return troops[k] + ' ' + ((TROOP_TYPES[k] && TROOP_TYPES[k].icon) || k); }).join(', ');
          var isOwner = gt.owner_id === currentUser.id;
          html += '<div style="display:flex;align-items:center;justify-content:space-between;padding:6px 8px;background:var(--panel2);border-radius:6px;margin-bottom:6px;border:1px solid rgba(96,208,96,.2);">'
            + '<div><span style="color:var(--accent2);">\u{1f6e1}\ufe0f ' + escapeHtml(ownerName) + '</span>'
            + '<span style="color:var(--dim);font-size:.72rem;"> desde ' + escapeHtml(origName) + ' ' + origCoords + '</span>'
            + (gt.recall_requested ? '<span style="color:var(--danger);font-size:.68rem;"> \u00b7 \u21a9 RETIRO SOLICITADO</span>' : '')
            + '<br><span style="font-size:.75rem;">' + escapeHtml(troopStr || 'sin tropas') + '</span>'
            + '</div>'
            + '<button onclick="recallReinforcement(\'' + gt.id + '\')" style="padding:3px 8px;background:rgba(224,64,64,.1);border:1px solid var(--danger);color:var(--danger);border-radius:3px;font-size:.62rem;cursor:pointer;margin-left:8px;">'
            + (isOwner ? '\u21a9 Volver' : '\u21a9 Devolver') + '</button>'
            + '</div>';
        });
        box.innerHTML = html;
      } catch(e) { card.style.display = 'none'; }
    }

    async function recallReinforcement(guestTroopId) {
      var r = await sbClient.from('guest_troops').update({ recall_requested: true }).eq('id', guestTroopId);
      if (r.error) { showNotif('Error: ' + r.error.message, 'err'); return; }
      showNotif('\u21a9 Retiro solicitado. Las tropas volver\u00e1n a casa.', 'ok');
      renderReinforcementsPanel();
    }

    async function processRecalls() {
      if (!currentUser) return;
      if (_guestTroopsTableExists === false) return; // tabla no existe, no intentar
      try {
        var r = await sbClient.from('guest_troops')
          .select('id,origin_village_id,host_village_id,troops')
          .eq('owner_id', currentUser.id).eq('recall_requested', true);
        if (r.error || !r.data || r.data.length === 0) return;
        for (var i = 0; i < r.data.length; i++) {
          var gt = r.data[i];
          var origVillage = myVillages.find(function(v){ return v.id === gt.origin_village_id; });
          if (!origVillage) continue;
          var hv = allVillages.find(function(v){ return v.id === gt.host_village_id; });
          var tx = hv ? Number(hv.x) : 0, ty = hv ? Number(hv.y) : 0;
          var dist = Math.max(Math.abs(tx - origVillage.x), Math.abs(ty - origVillage.y));
          var troops = typeof gt.troops === 'string' ? JSON.parse(gt.troops) : (gt.troops || {});
          var minSpeed = 999;
          Object.keys(troops).forEach(function(k) {
            var td = TROOP_TYPES[k] || CREATURE_TYPES[k];
            if ((troops[k] || 0) > 0 && td && td.speed < minSpeed) minSpeed = td.speed;
          });
          if (minSpeed === 999) minSpeed = 1;
          var seconds = Math.ceil((dist / minSpeed) * MISSION_FACTOR);
          var finishAt = new Date(Date.now() + seconds * 1000).toISOString();
          if (!origVillage.state.mission_queue) origVillage.state.mission_queue = [];
          origVillage.state.mission_queue.push({
            type: 'return_reinforce', tx: origVillage.x, ty: origVillage.y,
            troops: troops, finish_at: finishAt, start_at: new Date().toISOString()
          });
          await saveVillage(origVillage);
          await sbClient.from('guest_troops').delete().eq('id', gt.id);
        }
      } catch(e) { console.warn('processRecalls error:', e); }
    }

    // ============================================================
    // SIMULADOR DE BATALLA
    // ============================================================
    function renderSimulator() {
      var box = document.getElementById('simulatorContent');
      if (!box) return;

      var knightOpts = (typeof NPC_CASTLES !== 'undefined' ? NPC_CASTLES : []).map(function(c) {
        var obj = (typeof playerObjectives !== 'undefined' ? playerObjectives : []).find(function(o){ return o.objective_id === c.id; });
        var cleared = obj && obj.status === 'cleared';
        var spied   = obj && obj.status === 'spied';
        return '<option value="' + c.id + '">' + c.name + (cleared ? ' ✅' : spied ? ' 👁️' : ' ❓') + '</option>';
      }).join('');

      // Build troop rows: quantity + weapon + armor for each non-creature type
      var troopRows = Object.keys(TROOP_TYPES).map(function(k) {
        var t = TROOP_TYPES[k];
        return '<tr style="border-bottom:1px solid rgba(255,255,255,.04);">'
          + '<td style="padding:6px 8px;font-size:.82rem;white-space:nowrap;">' + t.icon + ' ' + t.name + '</td>'
          + '<td style="padding:4px 6px;"><input type="number" id="sim-qty-'+k+'" value="0" min="0" style="width:60px;background:var(--panel2);border:1px solid var(--border);color:var(--text);border-radius:4px;padding:2px 5px;font-family:VT323,monospace;font-size:.82rem;"></td>'
          + '<td style="padding:4px 6px;"><input type="number" id="sim-wpn-'+k+'" value="'+t.weapon+'" min="0" max="99" style="width:50px;background:var(--panel2);border:1px solid var(--border);color:var(--text);border-radius:4px;padding:2px 5px;font-family:VT323,monospace;font-size:.82rem;"></td>'
          + '<td style="padding:4px 6px;"><input type="number" id="sim-arm-'+k+'" value="'+t.armor+'" min="0" max="99" style="width:50px;background:var(--panel2);border:1px solid var(--border);color:var(--text);border-radius:4px;padding:2px 5px;font-family:VT323,monospace;font-size:.82rem;"></td>'
          + '</tr>';
      }).join('');

      // Creature rows: only quantity, no weapon/armor
      var creatureRows = Object.keys(CREATURE_TYPES).map(function(k) {
        var c = CREATURE_TYPES[k];
        return '<tr style="border-bottom:1px solid rgba(255,255,255,.04);">'
          + '<td style="padding:6px 8px;font-size:.82rem;white-space:nowrap;color:var(--accent2);">' + c.icon + ' ' + c.name + '</td>'
          + '<td style="padding:4px 6px;"><input type="number" id="sim-qty-'+k+'" value="0" min="0" style="width:60px;background:var(--panel2);border:1px solid var(--border);color:var(--text);border-radius:4px;padding:2px 5px;font-family:VT323,monospace;font-size:.82rem;"></td>'
          + '<td style="padding:4px 6px;text-align:center;font-size:.65rem;color:var(--dim);">—</td>'
          + '<td style="padding:4px 6px;text-align:center;font-size:.65rem;color:var(--dim);">—</td>'
          + '</tr>';
      }).join('');

      box.innerHTML =
        '<div style="display:flex;flex-direction:column;gap:14px;max-width:560px;">'
        + (knightOpts ? '<div><label style="font-size:.72rem;color:var(--dim);">Objetivo:</label>'
          + '<select id="simKnightSel" style="width:100%;background:var(--panel2);border:1px solid var(--border);color:var(--text);border-radius:4px;padding:6px;margin-top:4px;font-family:VT323,monospace;">'
          + knightOpts + '</select></div>' : '')
        + '<div>'
        + '<div style="font-size:.72rem;color:var(--dim);margin-bottom:8px;">Configura tu ejército (cantidad · arma · armadura):</div>'
        + '<div style="overflow-x:auto;">'
        + '<table style="width:100%;border-collapse:collapse;">'
        + '<thead><tr style="font-size:.65rem;color:var(--dim);letter-spacing:.08em;">'
        + '<th style="padding:4px 8px;text-align:left;">TROPA</th>'
        + '<th style="padding:4px 6px;">CANTIDAD</th>'
        + '<th style="padding:4px 6px;">⚔️ ARMA</th>'
        + '<th style="padding:4px 6px;">🛡️ ARMADURA</th>'
        + '</tr></thead>'
        + '<tbody>' + troopRows + '</tbody>'
        + '<tbody style="border-top:2px solid rgba(255,255,255,.1);">' + creatureRows + '</tbody>'
        + '</table></div></div>'
        + '<button class="btn" onclick="runSimulation()" style="width:100%;">⚔️ Simular batalla</button>'
        + '<div id="simResult"></div></div>';
    }

    function runSimulation() {
      var myTroops = {};
      // Collect troops with custom weapon/armor
      Object.keys(TROOP_TYPES).forEach(function(k) {
        var qty = parseInt((document.getElementById('sim-qty-' + k) || {}).value) || 0;
        if (qty <= 0) return;
        var wpn = parseInt((document.getElementById('sim-wpn-' + k) || {}).value) || 0;
        var arm = parseInt((document.getElementById('sim-arm-' + k) || {}).value) || 0;
        var base = getTroopStatsWithLevel(k, 1);
        myTroops[k] = qty;
        // Store custom stats override in a temporary map
        window._simCustomStats = window._simCustomStats || {};
        window._simCustomStats[k] = Object.assign({}, base, { weapon: wpn, armor: arm, count: qty });
      });
      // Creatures: quantity only, no weapon/armor
      Object.keys(CREATURE_TYPES).forEach(function(k) {
        var qty = parseInt((document.getElementById('sim-qty-' + k) || {}).value) || 0;
        if (qty <= 0) return;
        myTroops[k] = qty;
      });

      var sel = document.getElementById('simKnightSel');
      var target = sel && typeof NPC_CASTLES !== 'undefined' ? NPC_CASTLES.find(function(c){ return c.id === sel.value; }) : null;
      var knightArmy = target ? { _knight: { count: 1, stats: {
        hp: target.hp, damage: target.damage,
        attacksPerTurn: target.attacksPerTurn, attackChance: target.attackChance,
        defense: target.defense, dexterity: target.dexterity, armor: 0, weapon: 0
      }}} : null;

      if (Object.keys(myTroops).length === 0) { showNotif('Pon al menos 1 tropa', 'err'); return; }
      if (!knightArmy) { showNotif('Selecciona un objetivo', 'err'); return; }

      var result = simulateBattle(myTroops, knightArmy, 0);
      var victoria = result.winner === 1;
      var bajasStr = Object.keys(myTroops).filter(function(k){ return (myTroops[k]||0) > 0; }).map(function(k) {
        var perdidas = (myTroops[k] || 0) - (result.survivors1[k] || 0);
        var tData = TROOP_TYPES[k] || CREATURE_TYPES[k];
        return perdidas > 0 ? (tData ? tData.icon : '') + ' -' + perdidas + ' ' + (tData ? tData.name : k) : null;
      }).filter(Boolean).join(', ') || 'Sin bajas';

      var box = document.getElementById('simResult');
      box.innerHTML = '<div style="padding:12px;border-radius:6px;margin-top:4px;background:var(--panel2);border:1px solid var(--border);">'
        + '<div style="font-size:1rem;font-weight:bold;color:' + (victoria ? 'var(--ok)' : 'var(--danger)') + ';">'
        + (victoria ? '🏆 VICTORIA ESTIMADA' : '💀 DERROTA ESTIMADA') + '</div>'
        + '<div style="font-size:.78rem;color:var(--dim);margin-top:8px;">'
        + 'Rondas: ' + result.rounds + '<br>Bajas estimadas: ' + bajasStr
        + (victoria && target ? '<br>🏆 XP: ' + fmt(target.rewards.experience) : '') + '</div>'
        + '<div style="font-size:.65rem;color:var(--dim);margin-top:6px;">⚠️ Estimación basada en combate simulado. El resultado real puede variar.</div>'
        + '</div>';
      window._simCustomStats = {};
    }

    function showPage(name, el) {
      document.querySelectorAll('.page').forEach(function (p) { p.classList.remove('active'); });
      document.querySelectorAll('.nav-item').forEach(function (n) { n.classList.remove('active'); });
      document.getElementById('page-' + name).classList.add('active');
      if (el) el.classList.add('active');
      setTimeout(function () { if (name === 'buildings') renderBuildings(); if (name === 'map') renderMap(); }, 50);
      if (name === 'ranking') renderRanking();
      if (name === 'alliances') renderAlliances();
      if (name === 'messages') { renderThreads(); renderMessagesHeader(); }
      if (name === 'recursos') renderRecursos();
      if (name === 'adminusers') loadAdminUsers();
      if (name === 'fleet') renderTroops();
      if (name === 'creatures') renderCreatures();
      if (name === 'simulator') {
        setTimeout(function(){ renderSimulator(); }, 50);
      }
      // Guardar página activa en sessionStorage para restaurar tras F5
      try { sessionStorage.setItem('EW_lastPage', name); } catch(e) {}
      // Resync recursos — solo si han pasado más de 2 minutos desde el último sync
      var _nowSync = Date.now();
      if (_nowSync - (_lastResourceSync || 0) > 120000) {
        _lastResourceSync = _nowSync;
        syncResourcesFromDB();
      }
    }

    // Resync ligero — actualiza recursos desde DB sin recargar todo el estado
    async function syncResourcesFromDB() {
      if (!activeVillage || !currentUser) return;
      try {
        var { data: res, error } = await sbClient
          .from('resources')
          .select('madera,piedra,hierro,prov,esencia,last_update')
          .eq('village_id', activeVillage.id)
          .single();
        if (error || !res) return;
        var s = activeVillage.state;
        // Solo actualizar si el valor de DB es más reciente
        var dbTime = new Date(res.last_update || 0).getTime();
        var localTime = new Date(s.last_updated || 0).getTime();
        if (dbTime >= localTime) {
          s.resources.madera       = Number(res.madera)  || 0;
          s.resources.piedra       = Number(res.piedra)  || 0;
          s.resources.hierro       = Number(res.hierro)  || 0;
          s.resources.provisiones  = Number(res.prov)    || 0;
          s.resources.esencia      = Number(res.esencia) || 0;
          s.last_updated = res.last_update;
          _elCache = {}; // limpiar cache DOM
          tick();
        }
      } catch(e) {
        console.warn('syncResourcesFromDB error:', e);
      }
    }

    // ============================================================
    // ALDEANOS — asignar / desasignar de granja
    // Guardado INMEDIATO al pulsar (no espera al timer)
    // ============================================================
    function updateGranjaPanel() {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      var res = calcRes(vs);
      var assigned = vs.aldeanos_assigned || defaultAssignments();
      if (assigned.esencia === undefined) assigned.esencia = 0;
      
      var totalAssigned = (assigned.madera || 0) + (assigned.piedra || 0) + (assigned.hierro || 0) 
                        + (assigned.provisiones || 0) + (assigned.esencia || 0);
      
      var aldTotal = (vs.troops && vs.troops.aldeano !== undefined) ? vs.troops.aldeano : 0;
      var aldLibres = Math.max(0, aldTotal - totalAssigned);

      // Mostrar aldeanos disponibles
      var el = document.getElementById('aldLibresDisplay');
      if (el) el.textContent = aldLibres + ' / ' + aldTotal;

      // Inputs para asignar
      ['madera', 'piedra', 'hierro', 'provisiones', 'esencia'].forEach(function(key) {
        var input = document.getElementById('aldInput_' + key);
        if (input) {
          input.value = assigned[key] || 0;
          input.max = aldLibres + (assigned[key] || 0); // Puede reasignar los que ya tiene + libres
        }
      });
    }

    function renderRecursos() {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      var res = calcRes(vs);
      var w = vs.aldeanos_assigned || defaultAssignments();
      if (w.esencia === undefined) w.esencia = 0;
      var base = getBaseProd(vs.buildings);
      var bon = getBonusPerWorker(vs.buildings);
      var p = getProd(vs.buildings, 0, w);
      var totalW = (w.madera || 0) + (w.piedra || 0) + (w.hierro || 0) + (w.provisiones || 0) + (w.esencia || 0);
      var barrCap = getBarracksCapacity(vs.buildings);
      var cap = getCapacity(vs.buildings);
      var stored = res.madera + res.piedra + res.hierro + res.provisiones;
      var almPct = cap > 0 ? Math.min(100, Math.round(stored / cap * 100)) : 0;

      var elFree = document.getElementById('recAldLibres'); if (elFree) elFree.textContent = (res.aldeanos_libres !== undefined ? res.aldeanos_libres : res.aldeanos);
      var elWork = document.getElementById('recAldWorking'); if (elWork) elWork.textContent = totalW;
      var elCap = document.getElementById('recAldCap'); if (elCap) elCap.textContent = barrCap;
      var elAlm = document.getElementById('recAlmPct'); if (elAlm) elAlm.textContent = almPct + '%';

      var RES_DEFS = [
        { key: 'madera', icon: '🌲', name: 'Madera', color: 'var(--madera)', base: base.madera, bon: bon.madera, prod: p.madera, inAlm: true },
        { key: 'piedra', icon: '⛰️', name: 'Piedra', color: 'var(--piedra)', base: base.piedra, bon: bon.piedra, prod: p.piedra, inAlm: true },
        { key: 'hierro', icon: '⚙️', name: 'Hierro', color: 'var(--hierro)', base: base.hierro, bon: bon.hierro, prod: p.hierro, inAlm: true },
        { key: 'provisiones', icon: '🌾', name: 'Provisiones', color: 'var(--prov)', base: base.provisiones, bon: bon.provisiones, prod: p.provisiones, inAlm: true },
        { key: 'esencia', icon: '✨', name: 'Esencia', color: 'var(--esencia)', base: base.esencia, bon: bon.esencia, prod: p.esencia, inAlm: false },
      ];

      var grid = document.getElementById('recursosGrid');
      if (!grid) return;

      var KEYS = ['madera', 'piedra', 'hierro', 'provisiones', 'esencia'];
      var totalLibres = res.aldeanos_libres !== undefined ? res.aldeanos_libres : res.aldeanos;

      grid.innerHTML = RES_DEFS.map(function (d) {
        var wk = w[d.key] || 0;
        var avl = totalLibres + wk; // disponibles = libres + ya asignados a este recurso
        return '<div class="card">'
          + '<div style="display:flex;align-items:baseline;gap:8px;margin-bottom:8px;">'
          + '<div class="h2" style="color:' + d.color + '">' + d.icon + ' ' + d.name + '</div>'
          + '<span style="font-size:.65rem;color:var(--dim);">' + (d.inAlm ? 'almacén' : 'sin límite') + '</span>'
          + '</div>'
          + '<div style="display:flex;gap:12px;flex-wrap:wrap;margin-bottom:10px;font-size:.78rem;">'
          + '<span>📊 <b id="rw_p_' + d.key + '" style="color:' + d.color + '">' + fmt(d.prod) + '</b>/h</span>'
          + '<span style="color:var(--dim)">base ' + d.base + ' · +<b>' + d.bon + '</b>/ald·h</span>'
          + '</div>'
          + '<div style="display:flex;align-items:center;gap:8px;margin-bottom:4px;">'
          + '<input type="range" min="0" max="' + avl + '" value="' + wk + '" id="rw_s_' + d.key + '"'
          + ' style="flex:1;accent-color:' + d.color + ';"'
          + ' oninput="syncWorkerInput(\'' + d.key + '\',this.value)">'
          + '<input type="number" min="0" max="' + avl + '" value="' + wk + '" id="rw_n_' + d.key + '"'
          + ' style="width:52px;background:rgba(255,255,255,.04);border:1px solid var(--border);border-radius:4px;padding:4px 6px;color:var(--text);font-family:VT323,monospace;font-size:.82rem;text-align:center;"'
          + ' oninput="syncWorkerSlider(\'' + d.key + '\',this.value,' + avl + ')">'
          + '</div>'
          + '<div id="rw_i_' + d.key + '" style="font-size:.68rem;color:var(--dim);">' + wk + ' asignados / ' + avl + ' disponibles</div>'
          + '</div>';
      }).join('')
      + '<div style="grid-column:1/-1;display:flex;justify-content:center;padding:10px 0 4px;">'
      + '<button onclick="applyAllWorkers()" style="'
      + 'padding:10px 32px;background:rgba(240,192,64,.12);border:1px solid var(--accent);'
      + 'border-radius:6px;color:var(--accent);font-family:VT323,monospace;font-size:1rem;'
      + 'letter-spacing:.08em;cursor:pointer;transition:background .2s;"'
      + ' onmouseover="this.style.background=\'rgba(240,192,64,.22)\'"'
      + ' onmouseout="this.style.background=\'rgba(240,192,64,.12)\'">'
      + '✓ Aplicar asignación'
      + '</button>'
      + '</div>';
    }

    // ============================================================
    // WORKER ASSIGNMENT — con reajuste reactivo de todas las barras
    // ============================================================
    function snapshotResources(vs) {
      var res = calcRes(vs);
      vs.resources.madera = res.madera;
      vs.resources.piedra = res.piedra;
      vs.resources.hierro = res.hierro;
      vs.resources.provisiones = res.provisiones;
      vs.resources.esencia = res.esencia;
      // Sincronizar resources.aldeanos desde troops.aldeano (fuente de verdad)
      vs.resources.aldeanos = res.aldeanos_total;
      vs.last_updated = new Date().toISOString();
      return res;
    }

    function debouncedSave() {
      scheduleSave();
    }


    function assignWorker(resource, amount) {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      if (!vs.aldeanos_assigned) vs.aldeanos_assigned = defaultAssignments();
      var res = calcRes(vs);
      amount = Math.max(0, Math.min(amount, res.aldeanos));
      if (amount <= 0) { showNotif('No hay aldeanos libres.', 'err'); return; }
      // Snapshot recursos materiales; aldeanos NO se toca (calcRes lo recalcula desde total)
      vs.resources.madera = res.madera; vs.resources.piedra = res.piedra;
      vs.resources.hierro = res.hierro; vs.resources.provisiones = res.provisiones;
      vs.resources.esencia = res.esencia;
      // aldeanos sigue siendo el TOTAL (no cambiar)
      vs.aldeanos_assigned[resource] = (vs.aldeanos_assigned[resource] || 0) + amount;
      vs.aldeanos_granja = vs.aldeanos_assigned.provisiones || 0;
      vs.last_updated = new Date().toISOString();
      debouncedSave(); tick(); updateRecursosSliders();
    }

    function unassignWorker(resource, amount) {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      if (!vs.aldeanos_assigned) vs.aldeanos_assigned = defaultAssignments();

      amount = Math.max(0, Math.min(amount, vs.aldeanos_assigned[resource] || 0));
      if (amount <= 0) return;

      // Ponemos el estado al día (incluye aldeanos TOTAL)
      snapshotResources(vs);

      vs.aldeanos_assigned[resource] = Math.max(0, (vs.aldeanos_assigned[resource] || 0) - amount);
      vs.aldeanos_granja = vs.aldeanos_assigned.provisiones || 0;

      // last_updated ya lo fijó snapshotResources()
      debouncedSave(); tick(); updateRecursosSliders();
    }

    // ============================================================
    // APPLY ALL WORKERS — botón global que lee los 5 sliders/inputs
    // de una vez y los escribe todos en state en una sola operación
    // ============================================================
    function applyAllWorkers() {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      if (!vs.aldeanos_assigned) vs.aldeanos_assigned = defaultAssignments();
      var w = vs.aldeanos_assigned;

      // 1) Snapshot para tener recursos y aldeanos al día
      var r = snapshotResources(vs);
      var totalLibres = r.aldeanos_libres !== undefined ? r.aldeanos_libres : r.aldeanos;
      var totalAld = r.aldeanos_total || (totalLibres + Object.values(w).reduce(function(a,b){return a+(b||0);},0));

      // 2) Leer los 5 valores del DOM tal como el usuario los ha dejado
      var KEYS = ['madera', 'piedra', 'hierro', 'provisiones', 'esencia'];
      var newVals = {};
      var sumNew = 0;
      KEYS.forEach(function(k) {
        var el = document.getElementById('rw_n_' + k);
        var v = Math.max(0, parseInt((el && el.value) || 0) || 0);
        newVals[k] = v;
        sumNew += v;
      });

      // 3) Validar: la suma no puede superar el total de aldeanos
      if (sumNew > totalAld) {
        showNotif('Solo tienes ' + totalAld + ' aldeanos. Estás asignando ' + sumNew + '.', 'err');
        return;
      }

      // 4) Aplicar todos de golpe
      KEYS.forEach(function(k) { w[k] = newVals[k]; });
      vs.aldeanos_granja = w.provisiones || 0;
      // last_updated ya lo fijó snapshotResources()

      showNotif('✓ Aldeanos asignados correctamente', 'ok');
      debouncedSave(); tick(); updateRecursosSliders();
    }

    // Llamado al soltar la barra o confirmar número — guarda y refresca todo
    function setWorker(resource, rawValue) {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      if (!vs.aldeanos_assigned) vs.aldeanos_assigned = defaultAssignments();
      var w = vs.aldeanos_assigned;

      // 1) Primero, aplicamos el offline-calc para que recursos/aldeanos estén al día
      var r = snapshotResources(vs);

      // 2) Los disponibles para este recurso = libres + los ya asignados a ESTE recurso
      var available = (r.aldeanos_libres || 0) + (w[resource] || 0);
      var value = Math.max(0, Math.min(parseInt(rawValue) || 0, available));

      // 3) Guardamos la asignación
      w[resource] = value;
      vs.aldeanos_granja = w.provisiones || 0; // compatibilidad
      // last_updated ya lo fijó snapshotResources()

      debouncedSave(); tick(); updateRecursosSliders();
    }

    // Sync instantáneo mientras se arrastra (sin guardar) — actualiza número + restricciones
    function syncWorkerInput(key, val) {
      var ni = document.getElementById('rw_n_' + key);
      if (ni) ni.value = val;
      _previewWorker(key, parseInt(val) || 0);
    }
    function syncWorkerSlider(key, val, available) {
      val = Math.max(0, Math.min(parseInt(val) || 0, available));
      var sl = document.getElementById('rw_s_' + key);
      if (sl) sl.value = val;
      _previewWorker(key, val);
    }

    // Vista previa: ajusta maxes de los demás sin guardar
    function _previewWorker(changedKey, newVal) {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      var w = vs.aldeanos_assigned || defaultAssignments();
      if (w.esencia === undefined) w.esencia = 0;
      var res = calcRes(vs);
      var delta = newVal - (w[changedKey] || 0);
      var freeNow = res.aldeanos - delta;
      var totalW = newVal;
      var KEYS = ['madera', 'piedra', 'hierro', 'provisiones', 'esencia'];
      KEYS.forEach(function (k) { if (k !== changedKey) totalW += (w[k] || 0); });

      KEYS.forEach(function (key) {
        if (key === changedKey) return;
        var cur = w[key] || 0;
        var newMax = cur + Math.max(0, freeNow);
        var sl = document.getElementById('rw_s_' + key); if (sl) sl.max = newMax;
        var ni = document.getElementById('rw_n_' + key); if (ni) ni.max = newMax;
        var info = document.getElementById('rw_i_' + key);
        if (info) info.textContent = cur + ' asignados / ' + newMax + ' disponibles';
      });
      var barrCap = getBarracksCapacity(vs.buildings);
      var elFree = document.getElementById('recAldLibres'); if (elFree) elFree.textContent = Math.max(0, barrCap - totalW);
      var elWork = document.getElementById('recAldWorking'); if (elWork) elWork.textContent = totalW;
    }

    // Refresca sliders + stats sin re-renderizar DOM
    function updateRecursosSliders() {
      if (!activeVillage) return;
      var vs = activeVillage.state;
      var res = calcRes(vs);
      var w = vs.aldeanos_assigned || defaultAssignments();
      if (w.esencia === undefined) w.esencia = 0;
      var p = getProd(vs.buildings, 0, w);
      var cap = getCapacity(vs.buildings);
      var totalW = (w.madera || 0) + (w.piedra || 0) + (w.hierro || 0) + (w.provisiones || 0) + (w.esencia || 0);
      var barrCap = getBarracksCapacity(vs.buildings);
      var stored = res.madera + res.piedra + res.hierro + res.provisiones;
      var almPct = cap > 0 ? Math.min(100, Math.round(stored / cap * 100)) : 0;

      var elFree = document.getElementById('recAldLibres'); if (elFree) elFree.textContent = (res.aldeanos_libres !== undefined ? res.aldeanos_libres : res.aldeanos);
      var elWork = document.getElementById('recAldWorking'); if (elWork) elWork.textContent = totalW;
      var elCap = document.getElementById('recAldCap'); if (elCap) elCap.textContent = barrCap;
      var elAlm = document.getElementById('recAlmPct'); if (elAlm) elAlm.textContent = almPct + '%';

      var prodMap = { madera: p.madera, piedra: p.piedra, hierro: p.hierro, provisiones: p.provisiones, esencia: p.esencia };
      ['madera', 'piedra', 'hierro', 'provisiones', 'esencia'].forEach(function (key) {
        var workers = w[key] || 0, available = (res.aldeanos_libres !== undefined ? res.aldeanos_libres : res.aldeanos) + workers;
        var sl = document.getElementById('rw_s_' + key); if (sl) { sl.max = available; sl.value = workers; }
        var ni = document.getElementById('rw_n_' + key); if (ni) { ni.max = available; ni.value = workers; }
        var info = document.getElementById('rw_i_' + key); if (info) info.textContent = workers + ' asignados / ' + available + ' disponibles';
        var prod = document.getElementById('rw_p_' + key); if (prod) prod.textContent = fmt(prodMap[key]) + '/h';
      });
      var bcEl = document.getElementById('barrCapDisplay'); if (bcEl) bcEl.textContent = barrCap;
      var usedSlotsRS = getBarracksUsed(vs);
      var buEl = document.getElementById('barrUsedDisplay'); if (buEl) buEl.textContent = usedSlotsRS;
      var bfEl = document.getElementById('barrFreeDisplay'); if (bfEl) bfEl.textContent = Math.max(0, barrCap - usedSlotsRS);
      var bpEl = document.getElementById('barrProdDisplay'); if (bpEl) bpEl.textContent = getAldeanosProd(vs.buildings);
    }

    // Legacy aliases

    // ============================================================
    // RENAME VILLAGE
    // ============================================================
    function startRename() {
      if (!activeVillage) return;
      var f = document.getElementById('renameForm');
      var inp = document.getElementById('renameInput');
      f.style.display = 'flex';
      inp.value = activeVillage.name;
      inp.focus();
      inp.select();
    }
    function cancelRename() {
      document.getElementById('renameForm').style.display = 'none';
    }
    async function confirmRename() {
      var inp = document.getElementById('renameInput');
      var newName = inp.value.trim();
      if (!newName) { showNotif('El nombre no puede estar vacio.', 'err'); return; }
      if (newName.length > 30) { showNotif('Maximo 30 caracteres.', 'err'); return; }
      var r = await sbClient.from('villages').update({ name: newName }).eq('id', activeVillage.id);
      if (r.error) { showNotif('Error al renombrar: ' + r.error.message, 'err'); return; }
      activeVillage.name = newName;
      // Update selector
      populateVillageSel();
      document.getElementById('villageSel').value = activeVillage.id;
      document.getElementById('renameForm').style.display = 'none';
      tick();
      showNotif('Aldea renombrada a: ' + newName, 'ok');
    }

    // ============================================================
    // NOTIFICATIONS
    // ============================================================
    function showNotif(msg, type) {
      type = type || '';
      var el = document.createElement('div');
      el.className = 'notif ' + type;
      el.textContent = msg;
      document.getElementById('notifWrap').appendChild(el);
      setTimeout(function () { el.remove(); }, 3000);
    }

    // ============================================================
    // FORMAT
    // ============================================================
    function fmt(n) {
      n = Math.floor(n);
      if (n >= 1000000) return (n / 1000000).toFixed(1) + 'M';
      if (n >= 1000) return (n / 1000).toFixed(1) + 'K';
      return '' + n;
    }


    // ============================================================
    // BUILDING DETAIL MODAL
    // Calculates levels up to 100, shows current up to current+10
    // ============================================================
    function fmtTime(secs) {
      if (secs < 60) return secs + 's';
      if (secs < 3600) return Math.floor(secs / 60) + 'm ' + (secs % 60) + 's';
      var h = Math.floor(secs / 3600), m = Math.floor((secs % 3600) / 60);
      return h + 'h ' + (m ? m + 'm' : '');
    }

    function openBuildingDetail(id) {
      if (!activeVillage) return;
      modalBuildingId = id;
      var vs = activeVillage.state;
      var def = BUILDINGS.find(function (b) { return b.id === id; });
      if (!def) return;
      var curLvl = (vs.buildings[id] && vs.buildings[id].level) || 0;
      var res = calcRes(vs);
      var icon = def.icon || '🏗️';
      var inQueue = vs.build_queue && vs.build_queue.id === id;
      var anyQueue = !!vs.build_queue;
      var endShow = Math.min(curLvl + 10, 100);

      // ── Cabeceras de tabla según el edificio ──────────────────
      var isReclutamiento = (id === 'reclutamiento');
      var isAlmacen = (id === 'almacen');
      var isGranja = (id === 'granja');
      var isBarracas = (id === 'barracas');

      var isTorre = (id === 'torre');
      var isTorreInv = (id === 'torreinvocacion');
      var isMuralla = (id === 'muralla');
      var thExtra = isReclutamiento ? '<th>⚡ Aldeanos/h</th>'
        : isBarracas ? '<th>🏠 Plazas barracas</th>'
          : isAlmacen ? '<th>🏛️ Capacidad</th>'
            : isGranja ? '<th>🌾 Prov./aldeano/h</th>'
              : isTorre ? '<th>👁️ Alcance</th>'
                : isTorreInv ? '<th>🔮 Reducción</th>'
                  : isMuralla ? '<th>🛡️ Defensa</th>'
                    : '<th>Producción</th>';

      var rowsHTML = '';
      for (var lvl = curLvl; lvl <= endShow; lvl++) {
        var isCur = (lvl === curLvl);
        var isNext = (lvl === curLvl + 1);
        var cost = def.cost(lvl);
        var prod = def.prod(lvl);
        var tsecs = def.time(lvl);

        var rowCls = isCur ? 'row-current' : (isNext ? 'row-next' : '');
        var badgeCls = isNext ? 'lvl-badge accent' : 'lvl-badge';
        var tagHTML = isCur ? '<span class="lvl-tag cur">actual</span>'
          : isNext ? '<span class="lvl-tag nxt">siguiente</span>' : '';

        // ── Columna de "efecto" según edificio ───────────────────
        var plines = '';

        if (isReclutamiento) {
          var prodAld = (lvl === 0) ? 0 : Math.max(2, Math.floor(2 + lvl * 2));
          // Calcular intervalo entre aldeanos para este nivel
          var fakeBldRec = {};
          BUILDINGS.forEach(function (b) { fakeBldRec[b.id] = { level: (vs.buildings[b.id] && vs.buildings[b.id].level) || 1 }; });
          fakeBldRec['reclutamiento'] = { level: lvl };
          var intMs = lvl === 0 ? Infinity : getAldeanosIntervalMs(fakeBldRec);
          var intStr = '';
          if (lvl === 0) {
            intStr = '<div class="pl" style="color:var(--danger)">Sin producción</div>';
          } else {
            var intSec = Math.round(intMs / 1000);
            var intLabel = intSec >= 60
              ? (intSec % 60 === 0 ? (intSec / 60) + ' min' : Math.floor(intSec / 60) + 'min ' + (intSec % 60) + 's')
              : intSec + 's';
            intStr = '<div class="pl" style="color:var(--accent2)">⚡ 1 aldeano cada <b>' + intLabel + '</b></div>'
              + '<div class="pl" style="color:var(--dim);font-size:.58rem;">(≈ ' + prodAld + ' aldeanos/h)</div>';
          }
          plines = intStr;

        } else if (isBarracas) {
          var plazas = (lvl === 0) ? 0 : 50 + (lvl - 1) * 20;
          plines = '<div class="pl" style="color:var(--aldeanos)">🏠 ' + plazas + ' plazas</div>';

        } else if (isAlmacen) {
          var cap = Math.floor(1000 * Math.pow(2, lvl));
          plines = '<div class="pl" style="color:var(--accent)">📦 ' + fmt(cap) + ' unidades</div>'
            + '<div class="pl none" style="font-size:.58rem;opacity:.7">(madera+piedra+hierro+provisiones — la Esencia NO usa almacén)</div>';

        } else if (isGranja) {
          var provPerAld = 5 + lvl;
          plines = '<div class="pl" style="color:var(--prov)">🌾 ' + provPerAld + ' prov./aldeano/h</div>';

        } else {
          // Simular el edificio actual a este nivel concreto, manteniendo el resto igual
          var fakeBlds = {};
          BUILDINGS.forEach(function (b) { fakeBlds[b.id] = { level: (vs.buildings[b.id] && vs.buildings[b.id].level) || 1 }; });
          fakeBlds[id] = { level: lvl };
          var bProd = getBaseProd(fakeBlds);
          var bBonus = getBonusPerWorker(fakeBlds);
          // Clave de workers según edificio
          var workerKey = id === 'aserradero' ? 'madera'
            : id === 'cantera' ? 'piedra'
            : id === 'minehierro' ? 'hierro'
            : id === 'circulo' ? 'esencia' : null;
          var wk = workerKey ? ((vs.aldeanos_assigned && vs.aldeanos_assigned[workerKey]) || 0) : 0;
          // Mostrar SOLO el recurso que produce este edificio concreto
          if (id === 'aserradero') {
            var totM = bProd.madera + wk * bBonus.madera;
            plines = '<div class="pl" style="color:var(--madera)">🌲 ' + fmt(bProd.madera) + '/h base'
              + (wk ? ' <span style="color:var(--aldeanos)">+' + fmt(bBonus.madera) + '/ald × ' + wk + ' = <b>' + fmt(totM) + '/h total</b></span>' : '') + '</div>';
          } else if (id === 'cantera') {
            var totP = bProd.piedra + wk * bBonus.piedra;
            plines = '<div class="pl" style="color:var(--piedra)">⛰️ ' + fmt(bProd.piedra) + '/h base'
              + (wk ? ' <span style="color:var(--aldeanos)">+' + fmt(bBonus.piedra) + '/ald × ' + wk + ' = <b>' + fmt(totP) + '/h total</b></span>' : '') + '</div>';
          } else if (id === 'minehierro') {
            var totH = bProd.hierro + wk * bBonus.hierro;
            plines = '<div class="pl" style="color:var(--hierro)">⚙️ ' + fmt(bProd.hierro) + '/h base'
              + (wk ? ' <span style="color:var(--aldeanos)">+' + fmt(bBonus.hierro) + '/ald × ' + wk + ' = <b>' + fmt(totH) + '/h total</b></span>' : '') + '</div>';
          } else if (id === 'circulo') {
            var totE = bProd.esencia + wk * bBonus.esencia;
            plines = '<div class="pl" style="color:var(--esencia)">✨ ' + fmt(bProd.esencia) + '/h base'
              + (wk ? ' <span style="color:var(--aldeanos)">+' + fmt(bBonus.esencia) + '/ald × ' + wk + ' = <b>' + fmt(totE) + '/h total</b></span>' : '') + '</div>';
          } else if (id === 'torre') {
            var range = lvl * 5;
            plines = lvl === 0
              ? '<div class="pl" style="color:var(--danger)">Sin alcance</div>'
              : '<div class="pl" style="color:var(--accent)">👁️ ' + range + ' casillas de alcance</div>';
          } else if (id === 'torreinvocacion') {
            var red = lvl * 5;
            plines = lvl === 0
              ? '<div class="pl" style="color:var(--danger)">Sin reducción</div>'
              : '<div class="pl" style="color:var(--esencia)">🔮 -' + red + '% tiempo invocación</div>';
          } else if (id === 'muralla') {
            var wallHPShow = lvl * 500;
            plines = lvl === 0
              ? '<div class="pl" style="color:var(--danger)">Sin muralla — tropas expuestas</div>'
              : '<div class="pl" style="color:var(--piedra)">🏰 ' + fmt(wallHPShow) + ' HP de escudo</div>'
                + '<div class="pl" style="color:var(--dim);font-size:.58rem;">Atacantes deben destruirlo antes de dañar tropas</div>';
          } else if (id === 'lab') {
            plines = lvl === 0
              ? '<div class="pl" style="color:var(--danger)">Sin nivel</div>'
              : '<div class="pl" style="color:var(--gold)">📜 Investigación activa<br><span style="font-size:.58rem;color:var(--dim)">Próximamente disponible</span></div>';
          } else {
            plines = '<div class="pl none">—</div>';
          }
        }

        // ── Coste para subir ESTE nivel al siguiente ──────────────
        var clines = '';
        if (lvl < 100) {
          var c = def.cost(lvl);
          if (c.madera) clines += '<div class="cl ' + (res.madera >= (c.madera || 0) ? 'can' : 'cant') + '">🌲 ' + fmt(c.madera) + '</div>';
          if (c.piedra) clines += '<div class="cl ' + (res.piedra >= (c.piedra || 0) ? 'can' : 'cant') + '">⛰️ ' + fmt(c.piedra) + '</div>';
          if (c.hierro) clines += '<div class="cl ' + (res.hierro >= (c.hierro || 0) ? 'can' : 'cant') + '">⚙️ ' + fmt(c.hierro) + '</div>';
          if (c.provisiones) clines += '<div class="cl ' + (res.provisiones >= (c.provisiones || 0) ? 'can' : 'cant') + '">🌾 ' + fmt(c.provisiones) + '</div>';
          if (c.esencia) clines += '<div class="cl ' + (res.esencia >= (c.esencia || 0) ? 'can' : 'cant') + '">✨ ' + fmt(c.esencia) + '</div>';
          if (!clines) clines = '<div class="cl can">—</div>';
        } else {
          clines = '<div class="cl can" style="color:var(--gold)">MAX</div>';
        }

        var timeHTML = (lvl < 100 && tsecs > 0)
          ? '<span class="ttime">' + fmtTime(tsecs) + '</span>'
          : (lvl >= 100)
            ? '<span class="ttime" style="color:var(--dim)">—</span>'
            : '<span class="ttime" style="color:var(--ok)">Instantáneo</span>';

        rowsHTML += '<tr class="' + rowCls + '">'
          + '<td><span class="' + badgeCls + '">' + lvl + '</span>' + tagHTML + '</td>'
          + '<td><div class="prod-lines">' + plines + '</div></td>'
          + '<td><div class="cost-lines">' + clines + '</div></td>'
          + '<td>' + timeHTML + '</td>'
          + '</tr>';
      }

      // ── Subtítulo contextual en la cabecera del modal ─────────
      var curBaseProd = getBaseProd(vs.buildings);
      var curBonusProd = getBonusPerWorker(vs.buildings);
      var curWorkers = vs.aldeanos_assigned || defaultAssignments();
      var modalSub = 'Nivel actual: ' + curLvl + '&nbsp;&nbsp;|&nbsp;&nbsp;Máximo: 100';
      if (isReclutamiento) {
        var curProd = (curLvl === 0) ? 0 : Math.max(2, Math.floor(2 + curLvl * 2));
        var curIntMs = getAldeanosIntervalMs(vs.buildings);
        var curIntSec = curIntMs === Infinity ? null : Math.round(curIntMs / 1000);
        var curIntLabel = curIntSec === null ? 'sin producción'
          : curIntSec >= 60
            ? (curIntSec % 60 === 0 ? (curIntSec / 60) + ' min' : Math.floor(curIntSec / 60) + 'min ' + (curIntSec % 60) + 's')
            : curIntSec + 's';
        modalSub = 'Nivel ' + curLvl + '&nbsp;·&nbsp;⚡ 1 aldeano cada ' + curIntLabel + ' (≈ ' + curProd + '/h)';
      } else if (isBarracas) {
        var curPlazas = (curLvl === 0) ? 0 : 50 + (curLvl - 1) * 20;
        modalSub = 'Nivel ' + curLvl + '&nbsp;·&nbsp;🏠 ' + curPlazas + ' plazas para tropas normales';
      } else if (isAlmacen) {
        var curCap = Math.floor(1000 * Math.pow(2, curLvl));
        modalSub = 'Nivel ' + curLvl + '&nbsp;·&nbsp;📦 Capacidad actual: ' + fmt(curCap) + ' unidades';
      } else if (isGranja) {
        modalSub = 'Nivel ' + curLvl + '&nbsp;·&nbsp;🌾 ' + (5 + curLvl) + ' provisiones/aldeano/h';
      } else if (id === 'aserradero') {
        var wk = curWorkers.madera || 0;
        var total = curBaseProd.madera + wk * curBonusProd.madera;
        modalSub = 'Nivel ' + curLvl + '&nbsp;·&nbsp;🌲 Base ' + fmt(curBaseProd.madera) + '/h' + (wk ? ' + ' + wk + ' ald. → ' + fmt(total) + '/h total' : '');
      } else if (id === 'cantera') {
        var wk = curWorkers.piedra || 0;
        var total = curBaseProd.piedra + wk * curBonusProd.piedra;
        modalSub = 'Nivel ' + curLvl + '&nbsp;·&nbsp;⛰️ Base ' + fmt(curBaseProd.piedra) + '/h' + (wk ? ' + ' + wk + ' ald. → ' + fmt(total) + '/h total' : '');
      } else if (id === 'minehierro') {
        var wk = curWorkers.hierro || 0;
        var total = curBaseProd.hierro + wk * curBonusProd.hierro;
        modalSub = 'Nivel ' + curLvl + '&nbsp;·&nbsp;⚙️ Base ' + fmt(curBaseProd.hierro) + '/h' + (wk ? ' + ' + wk + ' ald. → ' + fmt(total) + '/h total' : '');
      } else if (id === 'circulo') {
        var wk = curWorkers.esencia || 0;
        var total = curBaseProd.esencia + wk * curBonusProd.esencia;
        modalSub = 'Nivel ' + curLvl + '&nbsp;·&nbsp;✨ Base ' + fmt(curBaseProd.esencia) + '/h' + (wk ? ' + ' + wk + ' ald. → ' + fmt(total) + '/h total' : '');
      } else if (id === 'torre') {
        var rng = curLvl * 5;
        modalSub = curLvl === 0
          ? 'Sin nivel — sin alcance. Necesitas la Torre para atacar y espiar.'
          : 'Nivel ' + curLvl + '&nbsp;·&nbsp;👁️ Alcance actual: <b>' + rng + ' casillas</b>';
      } else if (id === 'torreinvocacion') {
        var red = curLvl * 5;
        modalSub = curLvl === 0
          ? 'Sin nivel — sin reducción de tiempo de invocación.'
          : 'Nivel ' + curLvl + '&nbsp;·&nbsp;🔮 Reducción actual: <b>-' + red + '%</b> tiempo de invocación';
      } else if (id === 'cuarteles') {
        var redCuar = Math.min(50, curLvl);
        modalSub = curLvl === 0
          ? 'Sin nivel — sin reducción de tiempo de entrenamiento.'
          : 'Nivel ' + curLvl + '&nbsp;·&nbsp;🎖️ Reducción actual: <b>-' + redCuar + '%</b> tiempo de entrenamiento (máx. 50%)';
      } else if (id === 'muralla') {
        var wallHPCur = curLvl * 500;
        modalSub = curLvl === 0
          ? 'Sin nivel — tus tropas están expuestas desde el primer golpe.'
          : 'Nivel ' + curLvl + '&nbsp;·&nbsp;🏰 Escudo actual: <b>' + fmt(wallHPCur) + ' HP</b> — el atacante los destruye antes de llegar a tus tropas';
      } else if (id === 'lab') {
        modalSub = 'Nivel ' + curLvl + '&nbsp;·&nbsp;📜 Módulo de Investigación — <span style="color:var(--gold)">Próximamente activo</span>';
      }

      // ── Botón footer ──────────────────────────────────────────
      var btnCls, btnTxt;
      if (curLvl >= 100) {
        btnCls = 'maxlvl'; btnTxt = 'Nivel máximo alcanzado (100)';
      } else if (inQueue) {
        btnCls = 'busy'; btnTxt = 'Construyendo nivel ' + (curLvl + 1) + '...';
      } else if (anyQueue) {
        btnCls = 'insuf'; btnTxt = 'Cola ocupada — espera a que termine';
      } else if (!canAfford(def.cost(curLvl), res)) {
        btnCls = 'insuf'; btnTxt = 'Recursos insuficientes para nivel ' + (curLvl + 1);
      } else {
        btnCls = 'avail'; btnTxt = 'Mejorar a Nivel ' + (curLvl + 1);
      }

      var html = '<div class="bld-modal-overlay" id="bldOverlay" onclick="closeBldOverlay(event)">'
        + '<div class="bld-modal">'
        + '<div class="bld-modal-head">'
        + '<div class="bld-modal-icon">' + icon + '</div>'
        + '<div><div class="bld-modal-title">' + def.name + '</div>'
        + '<div class="bld-modal-sub">' + modalSub + '</div></div>'
        + '<button class="bld-modal-close" onclick="document.getElementById(\'bldModal\').style.display=\'none\';">&#x2715; Cerrar</button>'
        + '</div>'
        + '<div class="bld-modal-body">'
        + '<div style="background:rgba(255,255,255,.04);border-radius:6px;padding:8px 12px;margin-bottom:10px;font-size:.75rem;color:var(--dim);line-height:1.5;border-left:3px solid var(--accent);">'
        + def.desc
        + '</div>'
        + '<div class="bld-modal-note">Costes en <span style="color:var(--danger)">rojo</span> = no puedes pagarlos ahora. Cada fila muestra el coste de subir ese nivel al siguiente.</div>'
        + '<table class="bld-lvl-table">'
        + '<thead><tr><th>Nivel</th>' + thExtra + '<th>Coste (subir)</th><th>Tiempo</th></tr></thead>'
        + '<tbody>' + rowsHTML + '</tbody>'
        + '</table>'
        + '</div>'
        + '<div class="bld-modal-footer">'
        + '<button class="bld-footer-btn ' + btnCls + '" onclick="startBuildCurrentModal()">' + btnTxt + '</button>'
        + '</div>'
        + '</div></div>';

      var wrap = document.getElementById('bldModal');
      wrap.innerHTML = html;
      wrap.style.display = 'block';
    }

    function closeBldOverlay(event) {
      if (event.target.id === 'bldOverlay') {
        document.getElementById('bldModal').style.display = 'none';
      }
    }

    function startBuildCurrentModal() {
      document.getElementById('bldModal').style.display = 'none';
      if (modalBuildingId) startBuild(modalBuildingId);
    }

    // ============================================================
    // STARS
    // ============================================================
    function createStars() {
      var c = document.getElementById('stars');
      for (var i = 0; i < 120; i++) {
        var s = document.createElement('div');
        s.className = 'star';
        var sz = Math.random() * 2 + .5;
        s.style.cssText = 'width:' + sz + 'px;height:' + sz + 'px;left:' + (Math.random() * 100) + '%;top:' + (Math.random() * 100) + '%;animation-duration:' + (Math.random() * 4 + 2) + 's;animation-delay:' + (Math.random() * 4) + 's;';
        c.appendChild(s);
      }
    }

    createStars();

    // Guardado "mejor esfuerzo" al ocultar la pestaña (no bloqueante).
    // Nota: ningún navegador garantiza 100% el guardado al cerrar, pero esto evita el XHR síncrono y la auth incorrecta.
    document.addEventListener('visibilitychange', function () {
      if (document.hidden) {
        try { flushVillage(); } catch (e) { }
      }
    });

    // Check existing session on load

    // ============================================================
    // EPIC WARRIOS V2 — SOCIAL + RANKING + TROOPS SYNC (v2)
    // ============================================================
    let currentThreadId = null;
    let currentThreadType = null;

    async function ensureLogged() {
      if (!currentUser) { showNotif('Inicia sesión primero.', 'err'); return false; }
      return true;
    }

    function escapeHtml(str) {
      return String(str ?? '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;').replace(/'/g, '&#39;');
    }

    function formatNumber(n) {
      if (n === null || n === undefined) return '0';
      const num = Number(n);
      if (isNaN(num)) return '0';
      if (num >= 1000000) return (num / 1000000).toFixed(1).replace(/\.0$/, '') + 'M';
      if (num >= 1000)    return (num / 1000).toFixed(1).replace(/\.0$/, '') + 'K';
      return num.toLocaleString('es-ES');
    }

    // ============================================================
    // RANKING — 1 tropa = 1 punto, caché 6h, suma todas las tropas del jugador
    // ============================================================
    let rankingCache = null;       // {data, fetchedAt}
    const RANKING_TTL_MS = 6 * 60 * 60 * 1000; // 6 horas

    async function renderRanking() {
      if (!(await ensureLogged())) return;
      const box = document.getElementById('rankingBox');

      // Muestra datos cacheados si son recientes
      const now = Date.now();
      if (rankingCache && (now - rankingCache.fetchedAt) < RANKING_TTL_MS) {
        renderRankingRows(box, rankingCache.data, rankingCache.fetchedAt);
        return;
      }

      box.innerHTML = '<div class="muted">Actualizando ranking…</div>';

      // Suma de tropas por jugador: cada fila en 'troops' tiene (village_id, troop_type, quantity)
      // Necesitamos agrupar por user_id a través de villages
      let rows = null;

      // Intenta la vista ranking primero (más eficiente si existe en Supabase)
      const v = await sbClient.from('ranking')
        .select('username, military_score, alliance_tag')
        .order('military_score', { ascending: false })
        .limit(200);

      if (!v.error && v.data && v.data.length > 0) {
        rows = v.data;
      } else {
        // Fallback: calcula desde profiles + troops + villages
        const p = await sbClient.from('profiles')
          .select('id, username')
          .limit(500);
        if (p.error || !p.data) {
          box.innerHTML = '<div class="muted">Error cargando ranking.</div>';
          return;
        }

        // Carga todas las tropas con su aldea (user_id viene de villages)
        // v0.19: Usamos * para obtener todas las columnas de tipos de tropa nuevas
        const t = await sbClient.from('troops')
          .select('*, villages(owner_id)')  // owner_id es la columna correcta en villages
          .limit(5000);

        // Agrupa tropas por owner_id
        const scoreMap = {};
        if (!t.error && t.data) {
          t.data.forEach(tr => {
            const uid = tr.villages && tr.villages.owner_id; // era user_id — bug corregido
            if (!uid) return;

            // Sumamos todas las clases de tropas definidas en el juego
            let playerTotalTroops = 0;
            Object.keys(TROOP_TYPES).forEach(k => {
              playerTotalTroops += (Number(tr[k]) || 0);
            });

            scoreMap[uid] = (scoreMap[uid] || 0) + playerTotalTroops;
          });
        }

        // Busca alianzas activas
        const am = await sbClient.from('alliance_members')
          .select('user_id, status, alliances(tag)')
          .eq('status', 'active')
          .limit(500);
        const allianceTagMap = {};
        if (!am.error && am.data) {
          am.data.forEach(r => {
            allianceTagMap[r.user_id] = r.alliances ? r.alliances.tag : null;
          });
        }

        rows = p.data.map(u => ({
          username: u.username,
          military_score: scoreMap[u.id] || 0,
          alliance_tag: allianceTagMap[u.id] || null
        })).sort((a, b) => b.military_score - a.military_score);
      }

      rankingCache = { data: rows, fetchedAt: Date.now() };
      renderRankingRows(box, rows, rankingCache.fetchedAt);
    }

    function renderRankingRows(box, rows, fetchedAt) {
      if (!rows || rows.length === 0) { box.innerHTML = '<div class="muted">Aún no hay datos.</div>'; return; }

      const myUsername = document.getElementById('ovUser') ? document.getElementById('ovUser').textContent : '';
      const nextUpdate = new Date(fetchedAt + RANKING_TTL_MS);
      const nextStr = nextUpdate.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });

      let html = '<div style="font-size:.6rem;color:var(--dim);margin-bottom:8px;">⏱ Próxima actualización: ~' + nextStr + ' (cada 6h) &nbsp;·&nbsp; 1 tropa = 1 punto militar</div>';
      html += '<div class="table"><div class="trow thead"><div>#</div><div>Usuario</div><div>Alianza</div><div>⚔️ Militar</div></div>';

      rows.forEach((r, i) => {
        const isMe = r.username === myUsername;
        const medal = i === 0 ? '🥇' : i === 1 ? '🥈' : i === 2 ? '🥉' : '' + (i + 1);
        const rowStyle = isMe ? 'background:rgba(240,192,64,.08);border-color:rgba(240,192,64,.3);' : '';
        html += '<div class="trow" style="' + rowStyle + '">'
          + '<div>' + medal + '</div>'
          + '<div style="' + (isMe ? 'color:var(--gold);font-weight:bold;' : '') + '">' + escapeHtml(r.username || '-') + (isMe ? ' ◀' : '') + '</div>'
          + '<div>' + escapeHtml(r.alliance_tag || '—') + '</div>'
          + '<div style="color:var(--accent)">' + fmt(Number(r.military_score || 0)) + '</div>'
          + '</div>';
      });
      html += '</div>';
      box.innerHTML = html;
    }

    // Botón para forzar refresh del ranking (ignora caché)
    function forceRefreshRanking() {
      rankingCache = null;
      renderRanking();
    }

    // ================================================================
    // ALIANZAS — sistema completo
    // ================================================================

    // Estado local de alianza del jugador actual
    var _myAllianceId = null;
    var _myAllianceRole = null; // 'leader' | 'member'
    var _myAllianceStatus = null; // 'active' | 'pending' | 'invited'

    // Oculta todos los sub-paneles de alianza
    function _alHideAll() {
      ['alNoAlliancePanel','alMemberPanel','alLeaderPanel','alPendingPanel'].forEach(function(id) {
        var el = document.getElementById(id);
        if (el) el.style.display = 'none';
      });
    }

    // Actualiza el tag en el overview
    function _alUpdateOverview(tag, name) {
      window._playerAllianceTag = tag || null;
      window._playerAllianceName = name || null;
      var el = document.getElementById('ovAlliance');
      if (el) {
        el.textContent = tag ? '[' + tag + '] ' + (name || '') : '';
      }
    }

    async function refreshMyAlliance() {
      if (!(await ensureLogged())) return;
      const box = document.getElementById('myAllianceBox');
      if (box) box.innerHTML = '<span class="muted">Cargando…</span>';

      // Paso 1: obtener fila de alliance_members SIN join (el join falla si no hay FK registrada)
      const r = await sbClient.from('alliance_members')
        .select('status,role,alliance_id')
        .eq('user_id', currentUser.id)
        .order('created_at', { ascending: false })
        .limit(5);

      if (r.error) {
        // 500 = error de servidor/RLS — no bloquear el juego, mostrar sin alianza
        console.warn('alliance_members error:', r.error.message, '— comprueba las políticas RLS de la tabla');
        if (box) box.innerHTML = '<span class="muted">No se pudo cargar alianza. <a href="#" onclick="refreshMyAlliance();return false;">Reintentar</a></span>';
        _alHideAll();
        var p = document.getElementById('alNoAlliancePanel');
        if (p) p.style.display = '';
        return;
      }

      const row = (r.data || []).find(x => x.status === 'active' || x.status === 'invited' || x.status === 'pending');

      _alHideAll();
      _myAllianceId = null;
      _myAllianceRole = null;
      _myAllianceStatus = null;

      if (!row) {
        if (box) box.innerHTML = '<span class="muted">No perteneces a ninguna alianza.</span>';
        _alUpdateOverview(null, null);
        var p = document.getElementById('alNoAlliancePanel');
        if (p) { p.style.display = ''; _loadAllianceList(); }
        return;
      }

      _myAllianceId = row.alliance_id;
      _myAllianceRole = row.role;
      _myAllianceStatus = row.status;

      // Paso 2: obtener datos de la alianza por separado
      const ar = await sbClient.from('alliances')
        .select('id,name,tag')
        .eq('id', row.alliance_id)
        .maybeSingle();

      var al = (ar.data) || { id: row.alliance_id, name: 'Alianza', tag: '???' };

      if (box) {
        box.innerHTML = '<b style="color:var(--accent)">[' + escapeHtml(al.tag || '') + '] ' + escapeHtml(al.name || '') + '</b>'
          + ' <span class="muted">&nbsp;&middot; Estado: ' + escapeHtml(row.status) + ' &middot; Rol: ' + escapeHtml(row.role) + '</span>';
      }

      if (row.status === 'pending' || row.status === 'invited') {
        _alUpdateOverview(null, null);
        var pp = document.getElementById('alPendingPanel');
        if (pp) pp.style.display = '';
        var sb = document.getElementById('alPendingStatusBox');
        var acts = document.getElementById('alPendingActions');
        if (sb) {
          sb.innerHTML = row.status === 'invited'
            ? '&#x1F4E8; Has sido <b>invitado</b> a <b>[' + escapeHtml(al.tag) + '] ' + escapeHtml(al.name) + '</b>. ¿Aceptas?'
            : '&#x23F3; Tu solicitud para unirte a <b>[' + escapeHtml(al.tag) + '] ' + escapeHtml(al.name) + '</b> está <b>pendiente de aprobación</b>.';
        }
        if (acts) {
          acts.innerHTML = row.status === 'invited'
            ? '<button class="btn" onclick="acceptInvite()">&#x2714; Aceptar invitación</button>'
              + '<button class="btn" style="background:rgba(224,64,64,.1);border-color:var(--danger);color:var(--danger);" onclick="declineOrCancel()">&#x2715; Rechazar</button>'
            : '<button class="btn" style="background:rgba(224,64,64,.1);border-color:var(--danger);color:var(--danger);" onclick="declineOrCancel()">&#x2715; Cancelar solicitud</button>';
        }
        return;
      }

      // status === 'active'
      _alUpdateOverview(al.tag, al.name);
      loadAllyUserIds(); // Actualizar set de aliados para el mapa

      if (row.role === 'leader') {
        var lp = document.getElementById('alLeaderPanel');
        if (lp) lp.style.display = '';
        _loadLeaderData(row.alliance_id);
      } else {
        var mp = document.getElementById('alMemberPanel');
        if (mp) mp.style.display = '';
        _loadMembersList(row.alliance_id, false);
      }
    }

    async function _loadAllianceList() {
      const box = document.getElementById('alliancesBox');
      if (!box) return;
      box.innerHTML = '<span class="muted">Cargando…</span>';
      const r = await sbClient.from('alliances').select('id,name,tag,created_at').order('created_at', { ascending: false }).limit(100);
      if (r.error) { box.innerHTML = '<span class="muted">Error: ' + escapeHtml(r.error.message) + '</span>'; return; }
      if (!r.data || r.data.length === 0) { box.innerHTML = '<span class="muted">No hay alianzas aún.</span>'; return; }
      let html = '<div class="table"><div class="trow thead"><div>TAG</div><div>Nombre</div><div></div></div>';
      r.data.forEach(al => {
        html += '<div class="trow"><div><b>[' + escapeHtml(al.tag) + ']</b></div><div>' + escapeHtml(al.name) + '</div>'
          + '<div><button class="btn btn-sm" onclick="requestJoinAlliance(' + al.id + ', \'' + escapeHtml(al.name) + '\')">Solicitar</button></div></div>';
      });
      html += '</div>';
      box.innerHTML = html;
    }

    async function _loadMembersList(allianceId, isLeader) {
      var boxId = isLeader ? 'alLeaderMembersList' : 'alMembersList';
      const box = document.getElementById(boxId);
      if (!box) return;
      box.innerHTML = '<span class="muted">Cargando…</span>';
      const r = await sbClient.from('alliance_members')
        .select('user_id,role,status,profiles(username)')
        .eq('alliance_id', allianceId)
        .eq('status', 'active');
      if (r.error) { box.innerHTML = '<span class="muted">Error.</span>'; return; }
      if (!r.data || r.data.length === 0) { box.innerHTML = '<span class="muted">Sin miembros activos.</span>'; return; }
      let html = '<div class="table"><div class="trow thead"><div>Jugador</div><div>Rol</div>' + (isLeader ? '<div></div>' : '') + '</div>';
      r.data.forEach(m => {
        var uname = (m.profiles && m.profiles.username) ? escapeHtml(m.profiles.username) : m.user_id.slice(0,8);
        var isMe = m.user_id === currentUser.id;
        html += '<div class="trow"><div>' + uname + (isMe ? ' <span style="color:var(--dim);font-size:.7rem;">(tú)</span>' : '') + '</div><div>' + escapeHtml(m.role) + '</div>';
        if (isLeader && !isMe) {
          html += '<div><button class="btn btn-sm" style="background:rgba(224,64,64,.1);border-color:var(--danger);color:var(--danger);" onclick="kickMember(\'' + m.user_id + '\', \'' + uname + '\')">Expulsar</button></div>';
        } else if (isLeader) {
          html += '<div></div>';
        }
        html += '</div>';
      });
      html += '</div>';
      box.innerHTML = html;
    }

    async function _loadPendingRequests(allianceId) {
      const box = document.getElementById('alPendingList');
      if (!box) return;
      box.innerHTML = '<span class="muted">Cargando…</span>';
      const r = await sbClient.from('alliance_members')
        .select('user_id,status,profiles(username)')
        .eq('alliance_id', allianceId)
        .in('status', ['pending', 'invited']);
      if (r.error) { box.innerHTML = '<span class="muted">Error.</span>'; return; }
      if (!r.data || r.data.length === 0) { box.innerHTML = '<span class="muted">Sin solicitudes pendientes.</span>'; return; }
      let html = '<div class="table"><div class="trow thead"><div>Jugador</div><div>Estado</div><div></div></div>';
      r.data.forEach(m => {
        var uname = (m.profiles && m.profiles.username) ? escapeHtml(m.profiles.username) : m.user_id.slice(0,8);
        var isPending = m.status === 'pending';
        html += '<div class="trow"><div>' + uname + '</div><div style="color:var(--accent);">' + escapeHtml(m.status) + '</div><div style="display:flex;gap:4px;">';
        if (isPending) {
          html += '<button class="btn btn-sm" onclick="acceptMember(\'' + m.user_id + '\', \'' + uname + '\')">&#x2714; Aceptar</button>'
               + '<button class="btn btn-sm" style="background:rgba(224,64,64,.1);border-color:var(--danger);color:var(--danger);" onclick="rejectMember(\'' + m.user_id + '\', \'' + uname + '\')">&#x2715; Rechazar</button>';
        } else {
          // invited — cancelar invitación
          html += '<button class="btn btn-sm" style="background:rgba(224,64,64,.1);border-color:var(--danger);color:var(--danger);" onclick="rejectMember(\'' + m.user_id + '\', \'' + uname + '\')">&#x2715; Cancelar</button>';
        }
        html += '</div></div>';
      });
      html += '</div>';
      box.innerHTML = html;
    }

    async function _loadLeaderData(allianceId) {
      await Promise.all([
        _loadMembersList(allianceId, true),
        _loadPendingRequests(allianceId)
      ]);
    }

    async function renderAlliances() {
      await refreshMyAlliance();
    }

    async function createAlliance() {
      if (!(await ensureLogged())) return;
      const msg = document.getElementById('createAllianceMsg');
      msg.textContent = '';
      msg.style.color = 'var(--danger)';

      // Validaciones
      const name = (document.getElementById('alName').value || '').trim();
      const tag = (document.getElementById('alTag').value || '').trim().toUpperCase();
      if (name.length < 3) { msg.textContent = 'Nombre demasiado corto (mín. 3 caracteres).'; return; }
      if (tag.length < 2 || tag.length > 6 || !/^[A-Z0-9]+$/.test(tag)) { msg.textContent = 'TAG inválido (2-6 letras/números sin espacios).'; return; }

      // ¿Ya está en una alianza?
      const chk = await sbClient.from('alliance_members').select('status').eq('user_id', currentUser.id).in('status', ['active','pending','invited']);
      if (chk.data && chk.data.length > 0) { msg.textContent = 'Ya perteneces o tienes solicitud en una alianza.'; return; }

      // ¿Tag ya existe?
      const tagChk = await sbClient.from('alliances').select('id').eq('tag', tag).maybeSingle();
      if (tagChk.data) { msg.textContent = 'Ese TAG ya está en uso.'; return; }

      let id = null;
      const rpc = await sbClient.rpc('create_alliance', { p_name: name, p_tag: tag });
      if (!rpc.error && rpc.data) {
        id = rpc.data;
      } else {
        const ins = await sbClient.from('alliances').insert({ name, tag, owner_id: currentUser.id }).select('id').single();
        if (ins.error) { msg.textContent = 'Error: ' + ins.error.message; return; }
        id = ins.data.id;
        const mem = await sbClient.from('alliance_members').insert({ alliance_id: id, user_id: currentUser.id, role: 'leader', status: 'active' });
        if (mem.error) { msg.textContent = 'Error al unirse: ' + mem.error.message; return; }
      }

      msg.style.color = 'var(--ok)';
      msg.textContent = '¡Alianza [' + tag + '] creada! ✅';
      document.getElementById('alName').value = '';
      document.getElementById('alTag').value = '';
      await refreshMyAlliance();
    }

    async function requestJoinAlliance(allianceId, allianceName) {
      if (!(await ensureLogged())) return;

      // ¿Ya tiene solicitud / está activo?
      const chk = await sbClient.from('alliance_members').select('status').eq('user_id', currentUser.id);
      if (chk.data && chk.data.length > 0) {
        var existing = chk.data.find(x => x.status === 'active' || x.status === 'pending' || x.status === 'invited');
        if (existing) { showNotif('Ya tienes una solicitud activa o perteneces a una alianza.', 'err'); return; }
      }

      const ins = await sbClient.from('alliance_members').insert({
        alliance_id: allianceId, user_id: currentUser.id, role: 'member', status: 'pending'
      });
      if (ins.error) { showNotif('Error: ' + ins.error.message, 'err'); return; }

      showNotif('Solicitud enviada a ' + (allianceName || 'la alianza') + ' ✅', 'ok');
      var pmsg = document.getElementById('alPendingMsg');
      if (pmsg) pmsg.textContent = 'Solicitud enviada. Espera a que el líder la acepte.';
      await refreshMyAlliance();
    }

    async function acceptInvite() {
      if (!(await ensureLogged())) return;
      if (!_myAllianceId) { showNotif('No tienes invitación pendiente.', 'err'); return; }
      const up = await sbClient.from('alliance_members')
        .update({ status: 'active' })
        .eq('alliance_id', _myAllianceId)
        .eq('user_id', currentUser.id);
      if (up.error) { showNotif('Error: ' + up.error.message, 'err'); return; }
      showNotif('¡Invitación aceptada! Bienvenido a la alianza ✅', 'ok');
      await refreshMyAlliance();
    }

    async function declineOrCancel() {
      if (!(await ensureLogged())) return;
      if (!_myAllianceId) return;
      const del = await sbClient.from('alliance_members')
        .delete()
        .eq('alliance_id', _myAllianceId)
        .eq('user_id', currentUser.id);
      if (del.error) { showNotif('Error: ' + del.error.message, 'err'); return; }
      showNotif('Solicitud/invitación cancelada.', 'ok');
      await refreshMyAlliance();
    }

    async function leaveAlliance() {
      if (!(await ensureLogged())) return;
      if (!_myAllianceId) { showNotif('No estás en ninguna alianza.', 'err'); return; }
      if (_myAllianceRole === 'leader') {
        showNotif('Eres el líder. Usa "Disolver alianza" o transfiere el liderazgo primero.', 'err');
        return;
      }
      if (!confirm('¿Seguro que quieres salir de la alianza?')) return;
      const del = await sbClient.from('alliance_members')
        .delete()
        .eq('alliance_id', _myAllianceId)
        .eq('user_id', currentUser.id);
      if (del.error) { showNotif('Error: ' + del.error.message, 'err'); return; }
      showNotif('Has salido de la alianza.', 'ok');
      _alUpdateOverview(null, null);
      await refreshMyAlliance();
    }

    async function dissolveAlliance() {
      if (!(await ensureLogged())) return;
      if (_myAllianceRole !== 'leader') { showNotif('Solo el líder puede disolver la alianza.', 'err'); return; }
      if (!confirm('¿Seguro? Esto eliminará la alianza y expulsará a todos sus miembros. Esta acción es IRREVERSIBLE.')) return;
      // Borrar todos los miembros y luego la alianza
      await sbClient.from('alliance_members').delete().eq('alliance_id', _myAllianceId);
      const del = await sbClient.from('alliances').delete().eq('id', _myAllianceId);
      if (del.error) { showNotif('Error: ' + del.error.message, 'err'); return; }
      showNotif('Alianza disuelta.', 'ok');
      _alUpdateOverview(null, null);
      await refreshMyAlliance();
    }

    async function inviteToAlliance() {
      if (!(await ensureLogged())) return;
      if (_myAllianceRole !== 'leader') { showNotif('Solo el líder puede invitar.', 'err'); return; }
      const msg = document.getElementById('alInviteMsg');
      msg.textContent = '';
      msg.style.color = 'var(--danger)';
      const username = (document.getElementById('alInviteUser').value || '').trim();
      if (!username) { msg.textContent = 'Escribe un nombre de usuario.'; return; }

      // Buscar el usuario por username
      const pu = await sbClient.from('profiles').select('id,username').ilike('username', username).maybeSingle();
      if (pu.error || !pu.data) { msg.textContent = 'Jugador "' + escapeHtml(username) + '" no encontrado.'; return; }
      const targetId = pu.data.id;
      if (targetId === currentUser.id) { msg.textContent = 'No puedes invitarte a ti mismo.'; return; }

      // ¿Ya tiene estado en alguna alianza?
      const chk = await sbClient.from('alliance_members').select('status,alliance_id').eq('user_id', targetId);
      if (chk.data && chk.data.length > 0) {
        var conflict = chk.data.find(x => x.status === 'active' || x.status === 'invited');
        if (conflict) { msg.textContent = 'Ese jugador ya pertenece a una alianza o tiene una invitación pendiente.'; return; }
        // Si tiene una pending en OTRA alianza, se puede invitar igualmente (queda a su elección)
        var pendingHere = chk.data.find(x => x.alliance_id === _myAllianceId);
        if (pendingHere) { msg.textContent = 'Ese jugador ya tiene una solicitud en tu alianza.'; return; }
      }

      const ins = await sbClient.from('alliance_members').insert({
        alliance_id: _myAllianceId, user_id: targetId, role: 'member', status: 'invited'
      });
      if (ins.error) { msg.textContent = 'Error: ' + ins.error.message; return; }

      msg.style.color = 'var(--ok)';
      msg.textContent = 'Invitación enviada a ' + escapeHtml(pu.data.username) + ' ✅';
      document.getElementById('alInviteUser').value = '';
      _loadPendingRequests(_myAllianceId);
    }

    async function acceptMember(userId, username) {
      if (!(await ensureLogged())) return;
      const up = await sbClient.from('alliance_members')
        .update({ status: 'active' })
        .eq('alliance_id', _myAllianceId)
        .eq('user_id', userId);
      if (up.error) { showNotif('Error: ' + up.error.message, 'err'); return; }
      showNotif(username + ' aceptado en la alianza ✅', 'ok');
      _loadLeaderData(_myAllianceId);
    }

    async function rejectMember(userId, username) {
      if (!(await ensureLogged())) return;
      const del = await sbClient.from('alliance_members')
        .delete()
        .eq('alliance_id', _myAllianceId)
        .eq('user_id', userId);
      if (del.error) { showNotif('Error: ' + del.error.message, 'err'); return; }
      showNotif(username + ' rechazado/expulsado.', 'ok');
      _loadLeaderData(_myAllianceId);
    }

    async function kickMember(userId, username) {
      if (!(await ensureLogged())) return;
      if (!confirm('¿Expulsar a ' + username + ' de la alianza?')) return;
      const del = await sbClient.from('alliance_members')
        .delete()
        .eq('alliance_id', _myAllianceId)
        .eq('user_id', userId);
      if (del.error) { showNotif('Error: ' + del.error.message, 'err'); return; }
      showNotif(username + ' expulsado de la alianza.', 'ok');
      _loadLeaderData(_myAllianceId);
    }

        // ---------------- MESSAGES ----------------

    // Cache de perfiles: userId -> {username, allianceTag}
    const profileCache = {};

    async function getProfileInfo(userId) {
      if (!userId) return { username: 'Sistema', allianceTag: null };
      if (profileCache[userId]) return profileCache[userId];
      try {
        const p = await sbClient.from('profiles').select('username').eq('id', userId).maybeSingle();
        const username = (p.data && p.data.username) ? p.data.username : 'Jugador';
        let allianceTag = null;
        const am = await sbClient.from('alliance_members')
          .select('status,alliances(tag)')
          .eq('user_id', userId).eq('status', 'active').maybeSingle();
        if (am.data && am.data.alliances) allianceTag = am.data.alliances.tag;
        const info = { username, allianceTag };
        profileCache[userId] = info;
        return info;
      } catch (e) {
        return { username: 'Jugador', allianceTag: null };
      }
    }

    // Detecta el subtipo de mensaje de sistema por el cuerpo del mensaje
    function getSystemMsgStyle(body) {
      if (!body) return { icon: '🔔', color: 'var(--esencia)', label: 'Sistema' };
      var b = body.toUpperCase();
      if (b.includes('ESPIONAJE') || b.includes('SPY') || b.includes('🔍'))
        return { icon: '🔍', color: 'var(--aldeanos)', label: 'Espionaje' };
      if (b.includes('BATALLA') || b.includes('ATTACK') || b.includes('⚔') || b.includes('🏆') || b.includes('💀'))
        return { icon: '⚔️', color: 'var(--danger)', label: 'Batalla' };
      return { icon: '🔔', color: 'var(--esencia)', label: 'Informe' };
    }

    // Tipo de hilo → icono + color + etiqueta
    function threadMeta(type) {
      if (type === 'system')   return { icon: '🔔', color: 'var(--esencia)',  label: 'Sistema'  };
      if (type === 'alliance') return { icon: '⚔️',  color: 'var(--accent2)', label: 'Alianza'  };
      return                          { icon: '✉️',  color: 'var(--accent)',  label: 'DM'       };
    }

    // Actualiza la cabecera del chat con el tipo de hilo y nombre
    function renderMessagesHeader(type, title) {
      const h = document.getElementById('chatHeader');
      const area = document.getElementById('chatInputArea');
      if (!type) {
        h.innerHTML = '<span style="color:var(--dim);font-size:.78rem;">Selecciona una conversación…</span>';
        if (area) area.style.display = 'none';
        return;
      }
      var m = threadMeta(type);
      var isSystem = (type === 'system');
      h.innerHTML = '<span style="font-size:1.1rem;">' + m.icon + '</span>'
        + '<div style="flex:1;">'
        + '<div style="font-size:.8rem;color:' + m.color + ';letter-spacing:.08em;">' + m.label + '</div>'
        + '<div style="font-size:.72rem;color:var(--dim);">' + escapeHtml(title || '') + '</div>'
        + '</div>';
      // Los mensajes de sistema son de solo lectura
      if (area) area.style.display = isSystem ? 'none' : 'flex';
    }

    async function renderThreads() {
      if (!(await ensureLogged())) return;
      const box = document.getElementById('threadsBox');
      box.innerHTML = '<div style="padding:10px 14px;font-size:.72rem;color:var(--dim);">Cargando…</div>';

      const r = await sbClient.from('thread_members')
        .select('thread_id,last_read_at,message_threads(thread_type,created_at)')
        .eq('user_id', currentUser.id)
        .order('thread_id', { ascending: false })
        .limit(100);

      if (r.error) {
        box.innerHTML = '<div style="padding:10px 14px;font-size:.7rem;color:var(--danger);">Error: ' + escapeHtml(r.error.message) + '</div>';
        return;
      }

      const rows = r.data || [];
      if (rows.length === 0) {
        box.innerHTML = '<div style="padding:14px;font-size:.75rem;color:var(--dim);text-align:center;">Sin conversaciones aún.<br>Espía a alguien o envía un DM.</div>';
        return;
      }

      var html = '';
      rows.forEach(function(x) {
        var t = (x.message_threads && x.message_threads.thread_type) || 'dm';
        var m = threadMeta(t);
        var isActive = (x.thread_id == currentThreadId);
        html += '<div onclick="openThread(\'' + x.thread_id + '\',\'' + t + '\')" style="'
          + 'display:flex;align-items:center;gap:10px;padding:9px 14px;cursor:pointer;'
          + 'border-left:3px solid ' + (isActive ? m.color : 'transparent') + ';'
          + 'background:' + (isActive ? 'rgba(255,255,255,.04)' : 'transparent') + ';'
          + 'transition:background .15s;"'
          + ' onmouseover="if(!this.classList.contains(\'active-thread\')) this.style.background=\'rgba(255,255,255,.03)\'"'
          + ' onmouseout="if(!this.classList.contains(\'active-thread\')) this.style.background=\'' + (isActive ? 'rgba(255,255,255,.04)' : 'transparent') + '\'">'
          + '<span style="font-size:1.1rem;flex-shrink:0;">' + m.icon + '</span>'
          + '<div style="flex:1;min-width:0;">'
          + '<div style="font-size:.75rem;color:' + m.color + ';white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">' + m.label + '</div>'
          + '<div style="font-size:.62rem;color:var(--dim);">#' + x.thread_id.toString().slice(-8) + '</div>'
          + '</div>'
          + '</div>';
      });
      box.innerHTML = html;
    }

    // Abre un hilo de sistema (el primero que encuentre de tipo system, o lo crea)
    async function openSystemThread() {
      if (!(await ensureLogged())) return;
      const r = await sbClient.from('thread_members')
        .select('thread_id,message_threads(thread_type)')
        .eq('user_id', currentUser.id)
        .limit(100);
      if (r.error) { showNotif('Error: ' + r.error.message, 'err'); return; }
      const sysRow = (r.data || []).find(x => x.message_threads && x.message_threads.thread_type === 'system');
      if (sysRow) {
        await openThread(sysRow.thread_id, 'system');
      } else {
        showNotif('No tienes informes de sistema aún. Espía a alguien.', 'err');
      }
    }

    async function openThread(id, type) {
      if (!(await ensureLogged())) return;
      currentThreadId = id;
      // Si no sabemos el tipo, intentar detectarlo
      var threadType = type || 'dm';
      renderMessagesHeader(threadType, threadType === 'system' ? 'Informes del sistema' : threadType === 'alliance' ? 'Chat de alianza' : 'Mensaje directo');
      subscribeToThread(id);
      await loadThreadMessages(threadType);
      await renderThreads(); // refrescar para marcar activo
    }

    function parseMessageBody(rawBody) {
      // Try to parse as JSON {title, body} — new format
      if (rawBody && rawBody.trim().startsWith('{')) {
        try {
          var parsed = JSON.parse(rawBody);
          if (parsed.title !== undefined) return parsed;
        } catch(e) {}
      }
      // Legacy format: first line is title, rest is body
      var lines = (rawBody || '').split('\n');
      var title = lines[1] || lines[0] || 'Informe'; // skip the date line
      return { title: title.trim(), body: rawBody };
    }

    function toggleMsgExpand(id) {
      var el = document.getElementById('msgBody_' + id);
      var btn = document.getElementById('msgToggle_' + id);
      if (!el) return;
      var expanded = el.style.display !== 'none';
      el.style.display = expanded ? 'none' : 'block';
      if (btn) btn.textContent = expanded ? '▼' : '▲';
    }

    async function loadThreadMessages(threadType) {
      const box = document.getElementById('chatBox');
      if (!currentThreadId) { box.innerHTML = ''; return; }
      box.innerHTML = '<div style="color:var(--dim);font-size:.75rem;text-align:center;padding:20px;">Cargando…</div>';

      const r = await sbClient.from('messages')
        .select('id,body,created_at,sender_id')
        .eq('thread_id', currentThreadId)
        .order('created_at', { ascending: false })
        .limit(80);

      if (r.error) {
        box.innerHTML = '<div style="color:var(--danger);font-size:.72rem;padding:10px;">Error: ' + escapeHtml(r.error.message) + '</div>';
        return;
      }

      const rows = (r.data || []).reverse();
      if (rows.length === 0) {
        box.innerHTML = '<div style="color:var(--dim);font-size:.75rem;text-align:center;padding:30px;">Sin mensajes aún.</div>';
        return;
      }

      const uniqueSenders = [...new Set(rows.map(function(m){ return m.sender_id; }))];
      await Promise.all(uniqueSenders.map(function(id){ return getProfileInfo(id); }));

      var isSystem = (threadType === 'system');
      // Build DOM directly for system messages (Gmail inbox style)
      box.innerHTML = '';

      for (const m of rows) {
        const mine = (m.sender_id === currentUser.id);
        const isSystemMsg = !m.sender_id || isSystem;
        const info = profileCache[m.sender_id] || { username: 'Sistema', allianceTag: null };
        const displayName = isSystemMsg ? 'Sistema'
          : mine ? 'Tú'
          : (info.username + (info.allianceTag ? ' [' + info.allianceTag + ']' : ''));

        if (isSystemMsg || isSystem) {
          // Parse title + body
          var parsed = parseMessageBody(m.body);
          var sStyle = getSystemMsgStyle(parsed.title + ' ' + (parsed.body || ''));
          var date = new Date(m.created_at);
          var timeStr = date.toLocaleDateString('es-ES', { day:'2-digit', month:'2-digit' })
            + ' ' + date.toLocaleTimeString('es-ES', { hour:'2-digit', minute:'2-digit' });

          // Render body: HTML if starts with <, else plain text
          var bodyHtml = '';
          if (parsed.body) {
            var b = parsed.body.trim();
            bodyHtml = b.startsWith('<') ? b : '<pre style="white-space:pre-wrap;font-family:inherit;font-size:.78rem;">' + escapeHtml(b) + '</pre>';
          }

          var row = document.createElement('div');
          row.style.cssText = 'border:1px solid ' + sStyle.color + '33;border-radius:8px;overflow:hidden;cursor:pointer;transition:background .15s;';
          row.setAttribute('onclick', 'toggleMsgExpand(' + m.id + ')');
          row.onmouseover = function(){ this.style.background = 'rgba(255,255,255,.03)'; };
          row.onmouseout  = function(){ this.style.background = ''; };

          // Header row (always visible)
          row.innerHTML = '<div style="display:flex;align-items:center;gap:8px;padding:9px 12px;background:' + sStyle.color + '0d;">'
            + '<span style="font-size:1rem;flex-shrink:0;">' + sStyle.icon + '</span>'
            + '<span style="font-size:.68rem;color:' + sStyle.color + ';letter-spacing:.06em;flex-shrink:0;min-width:60px;">' + sStyle.label.toUpperCase() + '</span>'
            + '<span style="flex:1;font-size:.78rem;color:var(--text);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">' + escapeHtml(parsed.title) + '</span>'
            + '<span style="font-size:.6rem;color:var(--dim);flex-shrink:0;margin-left:8px;">' + timeStr + '</span>'
            + '<span id="msgToggle_' + m.id + '" style="font-size:.6rem;color:var(--dim);margin-left:6px;">▼</span>'
            + '</div>'
            // Body (hidden by default, expands on click)
            + '<div id="msgBody_' + m.id + '" style="display:none;padding:12px 14px;border-top:1px solid ' + sStyle.color + '22;background:var(--bg);">'
            + bodyHtml
            + '</div>';

          box.appendChild(row);

        } else {
          // Mensajes DM / alianza: estilo Gmail colapsable igual que sistema
          var date2 = new Date(m.created_at);
          var timeStr2 = date2.toLocaleDateString('es-ES', { day:'2-digit', month:'2-digit' })
            + ' ' + date2.toLocaleTimeString('es-ES', { hour:'2-digit', minute:'2-digit' });
          var senderColor = mine ? 'rgba(240,192,64,.9)' : 'rgba(0,212,255,.9)';
          var senderBg = mine ? 'rgba(240,192,64,.1)' : 'rgba(0,212,255,.08)';
          var bodyContent = '<div style="padding:12px 14px;border-top:1px solid rgba(255,255,255,.06);background:var(--bg);font-size:.82rem;color:var(--text);line-height:1.5;white-space:pre-wrap;word-break:break-word;">' + escapeHtml(m.body) + '</div>';
          var preview = (m.body || '').slice(0, 80) + ((m.body || '').length > 80 ? '…' : '');

          var row = document.createElement('div');
          row.style.cssText = 'border:1px solid rgba(255,255,255,.07);border-radius:8px;overflow:hidden;cursor:pointer;transition:background .15s;margin-bottom:4px;';
          row.setAttribute('onclick', 'toggleMsgExpand(' + m.id + ')');
          row.onmouseover = function(){ this.style.background = 'rgba(255,255,255,.03)'; };
          row.onmouseout  = function(){ this.style.background = ''; };
          row.innerHTML = '<div style="display:flex;align-items:center;gap:8px;padding:9px 12px;background:' + senderBg + ';">'
            + '<span style="font-size:.85rem;flex-shrink:0;">' + (mine ? '👤' : '💬') + '</span>'
            + '<span style="font-size:.75rem;color:' + senderColor + ';font-weight:bold;flex-shrink:0;min-width:70px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">' + escapeHtml(displayName) + '</span>'
            + '<span style="flex:1;font-size:.75rem;color:var(--dim);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">' + escapeHtml(preview) + '</span>'
            + '<span style="font-size:.6rem;color:var(--dim);flex-shrink:0;margin-left:8px;">' + timeStr2 + '</span>'
            + '<span id="msgToggle_' + m.id + '" style="font-size:.6rem;color:var(--dim);margin-left:6px;">▼</span>'
            + '</div>'
            + '<div id="msgBody_' + m.id + '" style="display:none;">' + bodyContent + '</div>';
          box.appendChild(row);
        }
      }

      box.scrollTop = box.scrollHeight;
    }

    // ---- REALTIME ----
    let realtimeChannel = null;

    function subscribeToThread(threadId) {
      if (realtimeChannel) { sbClient.removeChannel(realtimeChannel); realtimeChannel = null; }
      if (!threadId) return;
      realtimeChannel = sbClient.channel('thread-' + threadId)
        .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'messages', filter: 'thread_id=eq.' + threadId },
          async function(payload) {
            const m = payload.new;
            if (!m) return;
            await getProfileInfo(m.sender_id);
            await loadThreadMessages(currentThreadType || 'dm');
          })
        .subscribe();
    }

    async function sendChatMsg() {
      if (!(await ensureLogged())) return;
      if (!currentThreadId) { showNotif('Elige una conversación primero.', 'err'); return; }
      const inp = document.getElementById('chatMsg');
      const body = (inp.value || '').trim();
      if (!body) return;
      const ins = await sbClient.from('messages').insert({ thread_id: currentThreadId, sender_id: currentUser.id, body });
      if (ins.error) { showNotif('No se pudo enviar: ' + ins.error.message, 'err'); return; }
      inp.value = '';
      await loadThreadMessages(currentThreadType || 'dm');
    }

    async function startDM() {
      if (!(await ensureLogged())) return;
      const uname = (document.getElementById('dmUser').value || '').trim();
      if (!uname) { showNotif('Escribe un username.', 'err'); return; }
      const u = await sbClient.from('profiles').select('id,username').eq('username', uname).maybeSingle();
      if (u.error || !u.data) { showNotif('Usuario no encontrado.', 'err'); return; }
      if (u.data.id === currentUser.id) { showNotif('No puedes enviarte un DM a ti mismo 😄', 'err'); return; }
      const r = await sbClient.rpc('create_dm_thread', { p_other: u.data.id });
      if (r.error) { showNotif('No se pudo abrir DM: ' + r.error.message, 'err'); return; }
      currentThreadId = r.data;
      currentThreadType = 'dm';
      renderMessagesHeader('dm', 'DM con ' + u.data.username);
      subscribeToThread(r.data);
      await renderThreads();
      await loadThreadMessages('dm');
    }

    async function openAllianceChat() {
      if (!(await ensureLogged())) return;
      const r = await sbClient.from('alliance_members').select('alliance_id,status').eq('user_id', currentUser.id);
      if (r.error) { showNotif(r.error.message, 'err'); return; }
      const a = (r.data || []).find(function(x){ return x.status === 'active'; });
      if (!a) { showNotif('No estás en una alianza activa.', 'err'); return; }
      const t = await sbClient.rpc('get_or_create_alliance_chat', { p_alliance_id: a.alliance_id });
      if (t.error) { showNotif('No se pudo abrir chat: ' + t.error.message, 'err'); return; }
      currentThreadId = t.data;
      currentThreadType = 'alliance';
      renderMessagesHeader('alliance', 'Chat de alianza');
      subscribeToThread(t.data);
      await renderThreads();
      await loadThreadMessages('alliance');
    }

    // ============================================================
    // ADMIN — rol leído desde Supabase profiles.role
    // ============================================================
    let currentUserRole = 'player';
    let _usernameChanged = false;

    async function loadUserRole() {
      if (!currentUser) return;
      try {
        // Usamos maybeSingle para no crashear si RLS bloquea o no existe fila
        const r = await sbClient
          .from('profiles')
          .select('role, username_changed')
          .eq('id', currentUser.id)
          .maybeSingle();
        if (r.data) {
          currentUserRole = r.data.role || 'player';
          _usernameChanged = r.data.username_changed || false;
        } else {
          // Columna role puede no existir en instancias antiguas — fallback a player
          currentUserRole = 'player';
        }
      } catch (e) {
        console.warn('loadUserRole error:', e);
        currentUserRole = 'player';
      }
      checkAdminButton();
    }

    // ADMIN - Solo para sementalac@gmail.com
    function isAdmin() {
      // Comprobación directa al email
      return currentUser && currentUser.email === 'sementalac@gmail.com';
    }

    function checkAdminButton() {
      var btn = document.getElementById('adminBtn');
      var nav = document.getElementById('adminNavSection');
      if (btn) btn.style.display = isAdmin() ? 'inline-block' : 'none';
      if (nav) nav.style.display = isAdmin() ? 'block' : 'none';
    }

    // ── Admin recursos panel ──
    // ── Admin Control Panel (Universal v0.19) ──
    let adEditingVillage = null;

    function openAdmin() {
      if (!isAdmin()) { showNotif('Acceso denegado.', 'err'); return; }
      document.getElementById('adSearchInp').value = '';
      document.getElementById('adSearchResults').style.display = 'none';
      document.getElementById('adVillagesBox').style.display = 'none';
      document.getElementById('adEditBox').style.display = 'none';
      document.getElementById('adminMsg').textContent = '';
      document.getElementById('adminOverlay').classList.remove('hidden');
    }

    async function searchAdminPlayer() {
      const q = document.getElementById('adSearchInp').value.trim();
      if (q.length < 3) { showNotif('Escribe al menos 3 letras.', 'err'); return; }

      const box = document.getElementById('adSearchResults');
      const list = document.getElementById('adPlayersList');
      list.innerHTML = '<div class="muted">Buscando...</div>';
      box.style.display = 'block';

      // Mejoramos la consulta: si no parece un UUID, no filtramos por ID para evitar error de tipo
      const isUuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(q);

      let res;
      if (isUuid) {
        res = await sbClient.from('profiles').select('id, username')
          .or(`id.eq.${q}, username.ilike.%${q}%`)
          .limit(10);
      } else {
        res = await sbClient.from('profiles').select('id, username')
          .ilike('username', `%${q}%`)
          .limit(10);
      }

      list.innerHTML = '';
      if (res.error) {
        list.innerHTML = `<div class="muted" style="color:var(--danger)">Error: ${res.error.message}</div>`;
        return;
      }

      if (!res.data?.length) {
        list.innerHTML = '<div class="muted">No se encontraron jugadores.</div>';
      } else {
        res.data.forEach(p => {
          const div = document.createElement('div');
          div.className = 'admin-village-item';
          div.textContent = `👤 ${p.username} (${p.id.substring(0, 8)}...)`;
          div.onclick = () => loadAdminVillages(p.id);
          list.appendChild(div);
        });
      }
    }

    async function loadAdminVillages(userId) {
      // Usamos owner_id que es el nombre real en esta versión
      const res = await sbClient.from('villages').select('id, name').eq('owner_id', userId);
      const box = document.getElementById('adVillagesBox');
      const list = document.getElementById('adVillagesList');
      list.innerHTML = '';

      if (res.error || !res.data?.length) {
        list.innerHTML = '<div class="muted">Este jugador no tiene aldeas o error: ' + (res.error?.message || 'Ninguna') + '</div>';
      } else {
        res.data.forEach(v => {
          const div = document.createElement('div');
          div.className = 'admin-village-item';
          div.textContent = `🏘️ ${v.name} (ID: ${v.id})`;
          div.onclick = () => selectAdminVillage(v);
          list.appendChild(div);
        });
      }
      box.style.display = 'block';
      document.getElementById('adEditBox').style.display = 'none';
    }

    async function selectAdminVillage(village) {
      adEditingVillage = village;
      document.getElementById('adEditingName').textContent = village.name;
      document.getElementById('adminMsg').textContent = 'Cargando datos de aldea...';

      // Cargamos recursos y tropas para editar
      const r = await sbClient.from('resources').select('*').eq('village_id', village.id).maybeSingle();
      const t = await sbClient.from('troops').select('*').eq('village_id', village.id).maybeSingle();

      const vRes = r.data || { madera: 0, piedra: 0, hierro: 0, prov: 0, esencia: 0 };
      const vTrp = t.data || { aldeano: 0 };

      document.getElementById('adMadera').value = vRes.madera || 0;
      document.getElementById('adPiedra').value = vRes.piedra || 0;
      document.getElementById('adHierro').value = vRes.hierro || 0;
      document.getElementById('adProv').value = vRes.prov || 0;
      document.getElementById('adEsencia').value = vRes.esencia || 0;
      document.getElementById('adAldeanos').value = vTrp.aldeano || 0;

      // Get experience from profile (which is in the village search results)
      const player = adLastSearchResults.players.find(p => p.id === village.owner_id);
      document.getElementById('adExperience').value = player?.experience || 0;

      document.getElementById('adEditBox').style.display = 'block';
      document.getElementById('adminMsg').textContent = '';

      // Highlight selection
      document.querySelectorAll('#adVillagesList .admin-village-item').forEach(el => {
        el.classList.toggle('active', el.textContent.includes(village.name));
      });
    }

    async function adminApplyUniversal() {
      if (!adEditingVillage) return;

      const madera = parseInt(document.getElementById('adMadera').value) || 0;
      const piedra = parseInt(document.getElementById('adPiedra').value) || 0;
      const hierro = parseInt(document.getElementById('adHierro').value) || 0;
      const prov = parseInt(document.getElementById('adProv').value) || 0;
      const esencia = parseInt(document.getElementById('adEsencia').value) || 0;
      const aldeanos = parseInt(document.getElementById('adAldeanos').value) || 0;
      const experience = parseInt(document.getElementById('adExperience').value) || 0;

      showNotif('Guardando cambios en tablas...', 'ok');

      // Update Resources
      const updRes = await sbClient.from('resources')
        .update({ madera, piedra, hierro, prov, esencia, last_update: new Date().toISOString() })
        .eq('village_id', adEditingVillage.id);

      // Update Troops (Aldeanos)
      const updTrp = await sbClient.from('troops')
        .update({ aldeano: aldeanos })
        .eq('village_id', adEditingVillage.id);

      // Update Experience in Profiles
      const updPrf = await sbClient.from('profiles')
        .update({ experience: experience })
        .eq('id', adEditingVillage.owner_id);

      if (updRes.error || updTrp.error) {
        showNotif('Error guardando: ' + (updRes.error?.message || updTrp.error?.message), 'err');
      } else {
        showNotif('✓ Datos actualizados con éxito', 'ok');
        document.getElementById('adminMsg').textContent = `✓ Guardado: ${fmt(madera)}🌲 ${fmt(piedra)}⛰️ ${fmt(hierro)}⚙️ ${fmt(prov)}🌾`;

        // Si es nuestra propia aldea activa, forzamos recarga para ver cambios
        if (activeVillage && activeVillage.id === adEditingVillage.id) {
          await loadMyVillages();
          switchVillage(activeVillage.id);
        }
      }
    }

    function closeAdmin() { document.getElementById('adminOverlay').classList.add('hidden'); }

    // ── Admin usuarios ──
    async function loadAdminUsers() {
      if (!isAdmin()) return;
      var box = document.getElementById('adminUsersBox');
      var count = document.getElementById('adminUserCount');
      if (box) box.innerHTML = '<div class="muted">Cargando usuarios…</div>';

      // Carga perfiles con aldeas
      const p = await sbClient.from('profiles').select('id,username,role,username_changed').order('username');
      if (p.error) { if (box) box.innerHTML = '<div class="muted">Error: ' + escapeHtml(p.error.message) + '</div>'; return; }
      const users = p.data || [];
      if (count) count.textContent = users.length + ' usuarios registrados';

      let html = '<table class="admin-users-table"><thead><tr>'
        + '<th>Usuario</th><th>Email (ID)</th><th>Rol</th><th>Nombre cambiado</th><th>Acción</th>'
        + '</tr></thead><tbody>';

      users.forEach(u => {
        const isMe = u.id === currentUser.id;
        html += '<tr>'
          + '<td><b>' + escapeHtml(u.username || '-') + '</b>' + (isMe ? ' <span style="color:var(--gold)">(tú)</span>' : '') + '</td>'
          + '<td style="font-size:.6rem;color:var(--dim)">' + escapeHtml(u.id.substring(0, 12)) + '…</td>'
          + '<td class="' + (u.role === 'admin' ? 'admin-role' : '') + '">' + escapeHtml(u.role || 'player') + '</td>'
          + '<td>' + (u.username_changed ? '✅' : '—') + '</td>'
          + '<td>' + (isMe ? '<span style="color:var(--dim);font-size:.6rem">No puedes borrarte</span>'
            : '<button class="admin-del-btn" onclick="adminDeleteUser(\'' + u.id + '\',\'' + escapeHtml(u.username || '-') + '\')">🗑 Borrar</button>') + '</td>'
          + '</tr>';
      });
      html += '</tbody></table>';
      if (box) box.innerHTML = html;
    }

    async function adminDeleteUser(userId, username) {
      if (!isAdmin()) return;
      if (!confirm('¿Borrar la cuenta de "' + username + '"?\nEsto eliminará su aldea y todos sus datos.\nEsta acción no se puede deshacer.')) return;
      // Borrar tropas
      await sbClient.from('troops').delete().eq('user_id', userId);
      // Borrar aldeas
      const vDel = await sbClient.from('villages').delete().eq('user_id', userId);
      if (vDel.error) { showNotif('Error borrando aldeas: ' + vDel.error.message, 'err'); return; }
      // Borrar perfil
      const pDel = await sbClient.from('profiles').delete().eq('id', userId);
      if (pDel.error) { showNotif('Error borrando perfil: ' + pDel.error.message, 'err'); return; }
      // Nota: auth.users no se puede borrar desde el cliente (requiere service_role)
      // El trigger on_auth_user_deleted lo borrará si está activo en Supabase
      showNotif('✓ Perfil+aldeas de "' + username + '" borrados. El usuario de auth se borrará solo si el trigger está activo.', 'ok');
      await loadAdminUsers();
    }

    // ============================================================
    // PERFIL DE USUARIO — cambio de nombre (1 vez) + eliminar cuenta
    // ============================================================
    function openProfile() {
      if (!currentUser) return;
      var myUser = document.getElementById('ovUser') ? document.getElementById('ovUser').textContent : currentUser.email;
      document.getElementById('profUsername').textContent = myUser;
      document.getElementById('profEmail').textContent = currentUser.email;
      document.getElementById('profRole').textContent = currentUserRole;
      document.getElementById('profNewName').value = '';
      document.getElementById('profMsg').textContent = '';
      document.getElementById('profMsg').className = 'profile-msg';
      // Botón cambiar nombre: solo si no lo ha cambiado aún
      var changBtn = document.getElementById('profChangeNameBtn');
      if (changBtn) {
        changBtn.disabled = _usernameChanged;
        changBtn.title = _usernameChanged ? 'Ya has usado tu cambio de nombre' : 'Cambiar nombre (1 vez)';
      }
      document.getElementById('profileOverlay').classList.remove('hidden');
    }
    function closeProfile() { document.getElementById('profileOverlay').classList.add('hidden'); }

    async function doChangeUsername() {
      if (_usernameChanged) { showNotif('Ya usaste tu cambio de nombre.', 'err'); return; }
      var raw = (document.getElementById('profNewName').value || '').trim();
      var msg = document.getElementById('profMsg');
      msg.className = 'profile-msg';

      var shape = isUsernameShapeValid(raw);
      if (!shape.ok) { msg.textContent = shape.msg; msg.className = 'profile-msg err'; return; }
      var normalized = normUsername(raw);
      if (await isUsernameBanned(normalized)) { msg.textContent = 'Nombre no permitido.'; msg.className = 'profile-msg err'; return; }
      var av = await isUsernameAvailable(normalized);
      if (!av.ok) { msg.textContent = av.msg || 'No disponible.'; msg.className = 'profile-msg err'; return; }

      const r = await sbClient.from('profiles').update({
        username: raw,
        normalized_username: normalized,
        username_changed: true
      }).eq('id', currentUser.id);

      if (r.error) { msg.textContent = 'Error: ' + r.error.message; msg.className = 'profile-msg err'; return; }

      _usernameChanged = true;
      document.getElementById('profUsername').textContent = raw;
      document.getElementById('ovUser').textContent = raw;
      var tu = document.getElementById('topbarUsername');
      if (tu) tu.textContent = raw;
      document.getElementById('profChangeNameBtn').disabled = true;
      msg.textContent = '✓ Nombre cambiado a ' + raw + '. No podrás volver a cambiarlo.';
      msg.className = 'profile-msg ok';
      showNotif('Nombre actualizado: ' + raw, 'ok');
    }

    async function doDeleteAccount() {
      var raw = (document.getElementById('profNewName').value || '').trim();
      var myName = document.getElementById('profUsername').textContent;
      var msg = document.getElementById('profMsg');
      if (raw !== myName) {
        msg.textContent = 'Escribe exactamente tu nombre de usuario para confirmar.';
        msg.className = 'profile-msg err';
        document.getElementById('profNewName').placeholder = 'Escribe: ' + myName;
        return;
      }
      if (!confirm('¿Estás SEGURO de que quieres eliminar tu cuenta? Todos tus datos se perderán.')) return;
      // Borrar aldeas
      await sbClient.from('villages').delete().eq('user_id', currentUser.id);
      // Borrar perfil
      await sbClient.from('profiles').delete().eq('id', currentUser.id);
      // Cerrar sesión (el usuario de auth.users queda; si quieres borrarlo del todo necesitas el trigger)
      await sbClient.auth.signOut();
      location.reload();
    }

    // Guardar inmediatamente antes de cerrar/recargar — protege misiones en curso
    window.addEventListener('beforeunload', function () {
      if (activeVillage && currentUser) {
        // Sync save (no await — beforeunload no permite async)
        try {
          var s = activeVillage.state;
          sbClient.from('villages').update({
            build_queue: s.build_queue,
            mission_queue: s.mission_queue || [],
            last_aldeano_at: s.last_aldeano_at || null
          }).eq('id', activeVillage.id);
        } catch(e) {}
      }
    });

    (async function () {
      var r = await sbClient.auth.getSession();
      if (r.data && r.data.session) {
        currentUser = r.data.session.user;
        document.getElementById('authScreen').style.display = 'none';
        document.getElementById('gameWrapper').classList.add('visible');
        await initGame();
      }
    })();

    // ── Protección doble pestaña ──────────────────────────────────────────────
    // Cuando el jugador vuelve a esta pestaña después de tenerla en segundo plano,
    // recargamos los recursos desde Supabase antes de continuar. Esto evita que
    // dos pestañas abiertas al mismo tiempo se sobreescriban mutuamente.
    document.addEventListener('visibilitychange', async function () {
      if (document.visibilityState !== 'visible') return;
      if (!currentUser || !activeVillage) return;

      try {
        // Leer estado actual de recursos desde Supabase (fuente de verdad)
        const { data: res, error } = await sbClient
          .from('resources')
          .select('madera,piedra,hierro,prov,esencia,w_madera,w_piedra,w_hierro,w_prov,w_esencia,last_update')
          .eq('village_id', activeVillage.id)
          .single();

        if (error || !res) return;

        // Actualizar estado local con datos frescos de la DB
        const s = activeVillage.state;
        s.resources.madera      = Number(res.madera)  || 0;
        s.resources.piedra      = Number(res.piedra)  || 0;
        s.resources.hierro      = Number(res.hierro)  || 0;
        s.resources.provisiones = Number(res.prov)    || 0;
        s.resources.esencia     = Number(res.esencia) || 0;
        s.aldeanos_assigned.madera      = Number(res.w_madera) || 0;
        s.aldeanos_assigned.piedra      = Number(res.w_piedra) || 0;
        s.aldeanos_assigned.hierro      = Number(res.w_hierro) || 0;
        s.aldeanos_assigned.provisiones = Number(res.w_prov)   || 0;
        s.aldeanos_assigned.esencia     = Number(res.w_esencia)|| 0;
        s.last_updated = res.last_update || s.last_updated;

        // Limpiar cache DOM para que se refresque con nuevos valores
        _elCache = {};

        tick();
      } catch (e) {
        console.warn('visibilitychange sync error:', e);
      }
    });
  
/* --- TRANSPORTE UI — helpers llamados desde HTML inline --- */
function updateTransportUI() {
    let totalCap = 0;
    let totalTroops = 0;
    Object.keys(TROOP_TYPES).forEach(id => {
        const input = document.getElementById('mUnits_' + id);
        if (input) {
            const val = parseInt(input.value) || 0;
            totalCap += val * (TROOP_TYPES[id].capacity || 0);
            totalTroops += val;
        }
    });
    const capSpan = document.getElementById('displayCap');
    const costSpan = document.getElementById('displayCost');
    if(capSpan) capSpan.innerText = totalCap;
    if(costSpan) costSpan.innerText = totalTroops;
    validateTransportRes();
}

function validateTransportRes() {
    const cap = parseInt(document.getElementById('displayCap')?.innerText) || 0;
    const w = parseInt(document.getElementById('mWood')?.value) || 0;
    const s = parseInt(document.getElementById('mStone')?.value) || 0;
    const i = parseInt(document.getElementById('mIron')?.value) || 0;
    const btn = document.getElementById('btnSendMission');
    if (btn) {
        if ((w + s + i) > cap) {
            btn.innerText = "¡EXCESO CARGA!";
            btn.disabled = true;
        } else {
            btn.innerText = "¡Enviar!";
            btn.disabled = false;
        }
    }
}
// processMissions eliminado: resolveMissions (tick cada segundo) gestiona todos los tipos de misión incluyendo transport.


</script>


  <div id="bldModal" style="display:none"></div>

  <!-- PERFIL MODAL -->
  <div class="profile-overlay hidden" id="profileOverlay">
    <div class="profile-box">
      <div class="profile-title">👤 MI PERFIL</div>
      <div class="profile-row"><span class="profile-label">Usuario</span><span class="profile-val"
          id="profUsername">—</span></div>
      <div class="profile-row"><span class="profile-label">Email</span><span class="profile-val" id="profEmail"
          style="color:var(--dim)">—</span></div>
      <div class="profile-row"><span class="profile-label">Rol</span><span class="profile-val"
          id="profRole">player</span></div>
      <hr class="profile-sep">
      <div class="profile-section">Cambiar nombre de usuario (solo 1 vez)</div>
      <div class="profile-row">
        <input class="profile-input" id="profNewName" placeholder="Nuevo nombre..." maxlength="15">
      </div>
      <div style="font-size:.62rem;color:var(--dim);margin-bottom:10px;">4-15 caracteres, letras/números/_/-. Solo
        puedes cambiarlo una vez.</div>
      <div class="profile-actions">
        <button class="profile-btn save" id="profChangeNameBtn" onclick="doChangeUsername()">✓ Cambiar nombre</button>
      </div>
      <hr class="profile-sep">
      <div class="profile-section" style="color:var(--danger);">⚠ Zona de peligro — Eliminar cuenta</div>
      <div style="font-size:.62rem;color:var(--dim);margin-bottom:8px;">Escribe tu nombre de usuario en el campo de
        arriba y pulsa el botón. Esta acción es irreversible.</div>
      <div class="profile-actions">
        <button class="profile-btn danger" onclick="doDeleteAccount()">🗑 Eliminar mi cuenta</button>
        <button class="profile-btn cancel" onclick="closeProfile()">Cerrar</button>
      </div>
      <div class="profile-msg" id="profMsg"></div>
    </div>
  </div>

  <!-- ADMIN RECURSOS PANEL (v0.19) -->
  <div class="admin-overlay hidden" id="adminOverlay">
    <div class="admin-box">
      <div class="admin-title">⚙ PANEL DE CONTROL SUPREMO</div>

      <!-- Buscador de jugadores -->
      <div style="margin-bottom: 10px; font-size: 0.7rem; color: var(--dim);">BUSCAR JUGADOR (EMAIL O USERNAME)</div>
      <div class="admin-search-wrap">
        <input class="admin-input-search" id="adSearchInp" placeholder="Ej: jesus_33..."
          onkeypress="if(event.key==='Enter') searchAdminPlayer()">
        <button class="admin-btn search" onclick="searchAdminPlayer()">Buscar</button>
      </div>

      <div id="adSearchResults" class="admin-results-box">
        <div style="font-size: 0.8rem; margin-bottom: 8px; color: var(--accent);">Resultados:</div>
        <div id="adPlayersList"></div>
      </div>

      <div id="adVillagesBox" class="admin-results-box" style="border-color: var(--danger);">
        <div style="font-size: 0.8rem; margin-bottom: 8px; color: var(--danger);">Aldeas del jugador:</div>
        <div id="adVillagesList"></div>
      </div>

      <div id="adEditBox" style="display:none; border-top: 1px solid var(--border); padding-top: 20px;">
        <div style="font-size: 0.8rem; margin-bottom: 15px; color: var(--text); text-align:center;">
          Editando aldea: <b id="adEditingName" style="color:var(--accent2)">-</b>
        </div>

        <div class="admin-row"><span class="admin-label">🌲 Madera</span><input class="admin-input" id="adMadera"
            type="number"></div>
        <div class="admin-row"><span class="admin-label">⛰️ Piedra</span><input class="admin-input" id="adPiedra"
            type="number"></div>
        <div class="admin-row"><span class="admin-label">⚙️ Hierro</span><input class="admin-input" id="adHierro"
            type="number"></div>
        <div class="admin-row"><span class="admin-label">🌾 Prov.</span><input class="admin-input" id="adProv"
            type="number"></div>
        <div class="admin-row"><span class="admin-label">✨ Esencia</span><input class="admin-input" id="adEsencia"
            type="number"></div>
        <div class="admin-row"><span class="admin-label">👤 Aldeanos</span><input class="admin-input" id="adAldeanos"
            type="number"></div>
        <div class="admin-row"><span class="admin-label">⭐ Experiencia</span><input class="admin-input"
            id="adExperience" type="number"></div>

        <div class="admin-actions" style="display:flex; gap:10px; margin-top:20px;">
          <button class="admin-btn apply" style="flex:1" onclick="adminApplyUniversal()">✓ Guardar Cambios</button>
          <button class="admin-btn cancel" onclick="closeAdmin()">Cerrar</button>
        </div>
      </div>

      <div id="adminMsg" style="font-size:.7rem; margin-top:15px; min-height:16px; text-align:center; color:var(--ok);">
      </div>
    </div>
  </div>

  <div class="version-footer" id="versionFooter">EPIC WARRIORS v0.87</div>
</body>

</html>
